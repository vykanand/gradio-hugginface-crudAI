<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>CONTROL CENTER</title>
    <link rel="stylesheet" href="assets/css/theme.css" />
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          Oxygen, Ubuntu, Cantarell, sans-serif;
        background: #f5f7fa;
        color: var(--body-text);
        overflow: auto;
      }

      /* Ensure the page and panels can use full height so flex children
         (like the properties panel) can scroll correctly. */
      html,
      body {
        height: 100%;
      }

      .header {
        background: var(--brand-gradient);
        color: var(--brand-text);
        padding: 1rem 2rem;
        display: flex;
        justify-content: space-between;
        align-items: center;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      }

      .header h1 {
        font-size: 1.5rem;
        font-weight: 600;
      }

      .header-subtitle {
        font-size: 0.85rem;
        opacity: 0.9;
        margin-top: 0.25rem;
      }

      .tabs {
        display: flex;
        gap: 0.5rem;
      }

      .tab {
        padding: 0.5rem 1rem;
        background: rgba(255, 255, 255, 0.2);
        border: none;
        border-radius: 6px;
        color: white;
        cursor: pointer;
        font-size: 0.9rem;
        transition: all 0.2s;
      }

      .tab:hover {
        background: rgba(255, 255, 255, 0.3);
      }

      .tab.active {
        background: white;
        color: var(--active-tab-text);
        font-weight: 600;
      }

      .main {
        display: flex;
        flex: 1 1 auto;
        min-height: 0; /* allows children to scroll inside flex */
      }

      .sidebar {
        width: 280px;
        background: white;
        border-right: 1px solid #e1e8ed;
        overflow-y: auto;
        padding: 1.5rem;
      }

      .sidebar h3 {
        font-size: 0.75rem;
        text-transform: uppercase;
        color: #8899a6;
        margin-bottom: 1rem;
        font-weight: 600;
        letter-spacing: 0.5px;
      }

      .node-type {
        padding: 0.75rem;
        margin-bottom: 0.5rem;
        background: #f7f9fc;
        border: 1px solid #e1e8ed;
        border-radius: 6px;
        cursor: grab;
        display: flex;
        align-items: center;
        gap: 0.75rem;
        transition: all 0.2s;
      }

      .node-type:hover {
        background: #eef2f7;
        border-color: var(--hover-border);
        transform: translateX(4px);
      }

      .node-type:active {
        cursor: grabbing;
      }

      .node-icon {
        width: 32px;
        height: 32px;
        border-radius: 6px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1.2rem;
        flex-shrink: 0;
      }

      .node-info {
        flex: 1;
      }

      .node-name {
        font-weight: 600;
        font-size: 0.9rem;
        color: #2c3e50;
      }

      .node-desc {
        font-size: 0.75rem;
        color: #8899a6;
        margin-top: 0.15rem;
      }

      .canvas-container {
        flex: 1 1 auto;
        position: relative;
        overflow: auto;
        background: #fafbfc;
        min-height: 0;
      }

      .canvas {
        width: 100%;
        height: 100%;
        position: relative;
        cursor: default;
      }

      .workflow-node {
        position: absolute;
        background: white;
        border: 2px solid #e1e8ed;
        border-radius: 8px;
        padding: 1rem;
        min-width: 180px;
        cursor: move;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        transition: all 0.2s;
        z-index: 4;
        -webkit-user-select: none;
        -ms-user-select: none;
        user-select: none;
      }

      .workflow-node:hover {
        border-color: #667eea;
        box-shadow: 0 4px 12px rgba(102, 126, 234, 0.15);
      }

      .workflow-node.selected {
        border-color: #667eea;
        box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.2);
      }

      /* draggable column styles (used by modal and drag/drop) */
      .db-column {
        padding: 6px 8px;
        border-radius: 6px;
        margin-bottom: 4px;
        background: #f7f9fc;
        cursor: grab;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      .db-column:active {
        cursor: grabbing;
      }

      /* droppable inputs styles */
      .droppable-input {
        transition: all 0.12s ease;
        border: 1px dashed transparent;
      }
      .droppable-input.droppable {
        border-color: #cfe9ff;
        background: #fbfdff;
      }
      .droppable-input.drag-over {
        box-shadow: 0 0 0 4px rgba(102, 126, 234, 0.12);
        border-color: #667eea;
        background: #f0f7ff;
      }

      /* draggable connect pills */
      .connect-pill {
        cursor: grab;
        transition: all 0.1s ease;
      }
      .connect-pill:active {
        cursor: grabbing;
      }
      .connect-pill:hover {
        transform: translateY(-1px);
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      }

      .workflow-node-header {
        display: flex;
        align-items: center;
        gap: 0.75rem;
        margin-bottom: 0.75rem;
      }

      .workflow-node-title {
        font-weight: 600;
        font-size: 0.9rem;
        flex: 1;
      }

      .workflow-node-type {
        font-size: 0.7rem;
        padding: 0.25rem 0.5rem;
        background: #f0f3f7;
        border-radius: 4px;
        color: #657786;
        text-transform: uppercase;
        font-weight: 600;
        letter-spacing: 0.5px;
      }

      .workflow-node-content {
        font-size: 0.85rem;
        color: #657786;
        line-height: 1.5;
      }

      .connection-point {
        width: 12px;
        height: 12px;
        background: white;
        border: 2px solid #667eea;
        border-radius: 50%;
        position: absolute;
        cursor: pointer;
        transition: all 0.2s;
        -webkit-user-select: none;
        -ms-user-select: none;
        user-select: none;
      }

      .connection-point.snap {
        box-shadow: 0 0 0 8px rgba(102, 126, 234, 0.15);
        background: #667eea;
        transform: scale(1.4) translateY(-50%);
        transition: box-shadow 0.12s, transform 0.12s, background 0.12s;
      }

      .connection-point.input {
        top: 50%;
        left: -6px;
        transform: translateY(-50%);
      }

      .connection-point.output {
        top: 50%;
        right: -6px;
        transform: translateY(-50%);
      }

      .connection-point:hover {
        background: #667eea;
        transform: scale(1.3) translateY(-50%);
      }

      .properties-panel {
        width: 320px;
        background: white;
        border-left: 1px solid #e1e8ed;
        overflow-y: auto;
        min-height: 0;
      }

      .properties-panel h3 {
        font-size: 1rem;
        margin-bottom: 1.5rem;
        color: #2c3e50;
      }

      .form-group {
        margin-bottom: 1.25rem;
      }

      .form-label {
        display: block;
        font-size: 0.85rem;
        font-weight: 600;
        color: #2c3e50;
        margin-bottom: 0.5rem;
      }

      .form-input,
      .form-select,
      .form-textarea {
        width: 100%;
        padding: 0.625rem;
        border: 1px solid #e1e8ed;
        border-radius: 6px;
        font-size: 0.9rem;
        font-family: inherit;
        transition: all 0.2s;
      }

      .form-input:focus,
      .form-select:focus,
      .form-textarea:focus {
        outline: none;
        border-color: #667eea;
        box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
      }

      .form-textarea {
        min-height: 80px;
        resize: vertical;
      }

      .btn {
        padding: 0.625rem 1.25rem;
        border: none;
        border-radius: 6px;
        font-size: 0.9rem;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s;
      }

      .btn-primary {
        background: #667eea;
        color: white;
      }

      .btn-primary:hover {
        background: #5568d3;
      }

      .btn-secondary {
        background: #e1e8ed;
        color: #2c3e50;
      }

      .btn-secondary:hover {
        background: #d1d8dd;
      }

      .btn-danger {
        background: #e74c3c;
        color: white;
      }

      .btn-danger:hover {
        background: #c0392b;
      }

      .toolbar {
        display: flex;
        align-items: center;
        gap: 0.75rem;
        padding: 0.75rem 1rem;
        background: white;
        border-bottom: 1px solid #e1e8ed;
        flex-wrap: wrap;
        position: sticky;
        top: 0;
        z-index: 6;
      }

      /* Utility to push an item to the far right of the toolbar */
      .toolbar-right {
        margin-left: auto;
      }

      /* Small responsive tweak: allow selects/buttons to shrink on small screens */
      .toolbar .form-select,
      .toolbar .btn {
        flex: 0 0 auto;
      }

      .empty-state {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        height: 100%;
        color: #8899a6;
        padding: 2rem;
        text-align: center;
      }

      .empty-state-icon {
        font-size: 4rem;
        margin-bottom: 1rem;
        opacity: 0.5;
      }

      .empty-state-text {
        font-size: 1.1rem;
        font-weight: 600;
        margin-bottom: 0.5rem;
      }

      .empty-state-hint {
        font-size: 0.9rem;
      }

      /* Tab panels */
      .tab-panel {
        display: none;
        height: 100%;
        /* ensure panels are column flex containers so toolbar sits above content */
        flex-direction: column;
        /* allow panels to flex and let their children (like .main) size correctly */
        flex: 1 1 auto;
        min-height: 0;
      }

      .tab-panel.active {
        display: flex;
        flex-direction: column;
        flex: 1 1 auto;
        min-height: 0;
      }

      /* List styles for taxonomy and rules */
      .list-item {
        padding: 1rem;
        background: #f7f9fc;
        border: 1px solid #e1e8ed;
        border-radius: 6px;
        margin-bottom: 0.75rem;
      }
      .list-item-title {
        font-weight: 600;
        font-size: 0.95rem;
        color: #2c3e50;
        margin-bottom: 0.25rem;
      }

      .list-item-desc {
        font-size: 0.85rem;
        color: #8899a6;
      }

      .badge {
        font-weight: 600;
        color: #222;
      }

      .content-area {
        flex: 1 1 auto;
        overflow-y: auto;
        padding: 2rem;
        min-height: 0;
      }

      /* Grouped list UI */
      #concepts-list,
      #events-list,
      #actions-list,
      #rules-list {
        max-height: 360px;
        overflow-y: auto;
        padding-right: 8px; /* avoid content under scrollbar */
        margin-bottom: 1rem;
      }

      .group-container {
        margin-bottom: 0.9rem;
        border-radius: 8px;
        overflow: hidden;
        border: 1px solid #e9eef6;
        background: white;
      }

      .group-container.collapsed .group-items {
        display: none;
      }
      .group-items {
        max-height: 280px;
        overflow: auto;
        padding: 0.75rem;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 8px;
        cursor: pointer;
      }

      .group-header .chev {
        font-size: 0.95rem;
        margin-right: 8px;
        display: inline-block;
        width: 18px;
        text-align: center;
      }

      /* merged .group-items definition above */

      /* Type-specific header colors */
      .concept-group .group-header {
        background: linear-gradient(90deg, #e8f4ff, #f3fbff);
        border-bottom: 1px solid #eef7ff;
      }
      .event-group .group-header {
        background: linear-gradient(90deg, #fff8e8, #fffdf4);
        border-bottom: 1px solid #fff4dd;
      }
      .action-group .group-header {
        background: linear-gradient(90deg, #fff2f8, #fff7fb);
        border-bottom: 1px solid #ffeef8;
      }
      .rules-group .group-header {
        background: linear-gradient(90deg, #eefdf4, #f7fff9);
        border-bottom: 1px solid #eaffef;
      }

      .list-item.type-concept {
        border-left: 4px solid #67a8ff;
      }
      .list-item.type-event {
        border-left: 4px solid #ffa726;
      }
      .list-item.type-action {
        border-left: 4px solid #f06292;
      }
      .list-item.type-rule {
        border-left: 4px solid #66bb6a;
      }

      .svg-connections {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: auto; /* enable clicking on connection paths */
        z-index: 1; /* keep SVG behind node elements so nodes remain visible */
      }

      .conn-pulse {
        animation: pulse 700ms ease-in-out;
      }

      @keyframes pulse {
        0% {
          stroke-width: 6;
          opacity: 1;
        }
        50% {
          stroke-width: 10;
          opacity: 0.65;
        }
        100% {
          stroke-width: 6;
          opacity: 1;
        }
      }

      .workflow-nodes-container {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 2;
      }
      /* Connect pills and field styles (compact, accessible) */
      .connect-pill {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 6px 10px;
        background: #eef6ff;
        border: 1px solid #d6e9ff;
        border-radius: 999px;
        color: #0b3a66;
        font-size: 0.85rem;
        cursor: grab;
        user-select: none;
      }
      .connect-pill:active { cursor: grabbing; }

      .connect-field {
        padding: 4px 6px;
        background: #f7f9fc;
        border: 1px solid #e6eef6;
        border-radius: 4px;
        cursor: pointer;
        font-family: monospace;
        font-size: 0.85rem;
        color: #223;
      }

      .connect-node { background: #fff; border: 1px solid #eef2f7; border-radius: 6px; padding: 8px; }
      .connect-field-label { font-family: monospace; color: #223; }

      .form-group { margin-bottom: 12px; }
    </style>
    <!-- Variable System & Modal Components -->
    <script src="builder-tabs/variable-registry.js"></script>
    <script src="builder-tabs/event-data-modal.js"></script>
    <script src="builder-tabs/db-picker-modal.js"></script>
    <script src="builder-tabs/variable-insertion.js"></script>
  </head>
  <body>
    <div class="header">
      <div>
        <h1>üß† BILLION CONTROL CENTER</h1>
        <div class="header-subtitle">
          Metadata-driven, no-code workflow designer for enterprise operations
        </div>
      </div>
      <div class="tabs">
        <button class="tab active" onclick="switchTab('workflows', event)">
          Workflows
        </button>
        <button class="tab" onclick="switchTab('taxonomy', event)">
          Taxonomy
        </button>
        <button class="tab" onclick="switchTab('rules', event)">Rules</button>
        <button class="tab" onclick="switchTab('custom-logic', event)">Custom Logic</button>
        <button class="tab" onclick="switchTab('events', event)">Events</button>
        <button class="tab" onclick="switchTab('actions', event)">
          DB Actions
        </button>
        <button class="tab" onclick="switchTab('executions', event)">
          Executions
        </button>
      </div>
    </div>

    <!-- Workflows Tab -->
    <div id="workflows-panel" class="tab-panel active">
      <div class="toolbar">
        <button class="btn btn-primary" onclick="newWorkflow()">
          ‚ûï New Workflow
        </button>
        <button class="btn btn-secondary" onclick="loadWorkflows()">
          üîÑ Refresh
        </button>
        <button class="btn btn-secondary" onclick="saveCurrentWorkflow()">
          üíæ Save
        </button>
        <button class="btn btn-primary" onclick="showTestRunModal()">
          ‚ñ∂Ô∏è Test Run
        </button>
          <input id="workflow-name-input" class="form-input toolbar-right" style="width:260px; margin-left:8px" placeholder="Workflow name" />
        <button
          class="btn btn-secondary"
          onclick="globalThis.location.href='/event-registry.html'"
          title="Open Event Registry"
        >
          üìö Event Registry
        </button>
        <!-- Auto-connect removed: connections are explicit by user or bindings -->
        <select
          id="workflow-selector"
          class="form-select toolbar-right"
          style="width: 200px"
          onchange="loadWorkflowById(this.value)"
        >
          <option value="">Select Workflow...</option>
        </select>
      </div>
      <div class="main">
        <div class="sidebar">
          <h3>Workflow Nodes</h3>
          <div class="node-type" draggable="true" data-node-type="action">
            <div class="node-icon" style="background: #e3f2fd; color: #0d47a1">
              ‚ö°
            </div>
            <div class="node-info">
              <div class="node-name">DB Action</div>
              <div class="node-desc">Execute a business action</div>
            </div>
          </div>

          <div class="node-type" draggable="true" data-node-type="event">
            <div class="node-icon" style="background: #e6ffed; color: #087f5b">üîî</div>
            <div class="node-info">
              <div class="node-name">Event Trigger</div>
              <div class="node-desc">Start workflow from an event</div>
            </div>
          </div>

          <div class="node-type" draggable="true" data-node-type="connect">
            <div class="node-icon" style="background: #e8f0ff; color: #123478">üîó</div>
            <div class="node-info">
              <div class="node-name">Connect</div>
              <div class="node-desc">Connect node for external data inputs</div>
            </div>
          </div>

          <div class="node-type" draggable="true" data-node-type="decision">
            <div class="node-icon" style="background: #fff3e0; color: #bf360c">
              üîÄ
            </div>
            <div class="node-info">
              <div class="node-name">Decision</div>
              <div class="node-desc">Conditional branch using rules</div>
            </div>
          </div>
          <div class="node-type" draggable="true" data-node-type="human-task">
            <div class="node-icon" style="background: #fce4ec; color: #880e4f">
              üë§
            </div>
            <div class="node-info">
              <div class="node-name">Human Task</div>
              <div class="node-desc">Approval or manual action</div>
            </div>
          </div>
          <div class="node-type" draggable="true" data-node-type="parallel">
            <div class="node-icon" style="background: #f3e5f5; color: #4a148c">
              ‚´ø
            </div>
            <div class="node-info">
              <div class="node-name">Parallel</div>
              <div class="node-desc">Execute multiple branches</div>
            </div>
          </div>
          <div class="node-type" draggable="true" data-node-type="loop">
            <div class="node-icon" style="background: #e8f5e9; color: #145214">
              üîÑ
            </div>
            <div class="node-info">
              <div class="node-name">Loop</div>
              <div class="node-desc">Repeat steps</div>
            </div>
          </div>
          <div class="node-type" draggable="true" data-node-type="end">
            <div class="node-icon" style="background: #ffebee; color: #7a1010">
              üèÅ
            </div>
            <div class="node-info">
              <div class="node-name">End</div>
              <div class="node-desc">Complete workflow</div>
            </div>
          </div>
        </div>
        <div class="canvas-container">
          <div class="canvas" id="workflow-canvas">
            <svg class="svg-connections" id="svg-connections"></svg>
            <div class="workflow-nodes-container" id="workflow-nodes"></div>
          </div>
        </div>
        <div class="properties-panel" id="properties-panel">
          <div class="empty-state">
            <div class="empty-state-icon">üìã</div>
            <div class="empty-state-text">No node selected</div>
            <div class="empty-state-hint">
              Click a node to edit its properties
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Taxonomy Tab -->
    <div id="taxonomy-panel" class="tab-panel">
      <div class="toolbar">
        <button class="btn btn-primary" onclick="showAddConceptDialog()">
          ‚ûï Add Concept
        </button>
        <button class="btn btn-primary" onclick="showAddEventDialog()">
          ‚ûï Add Event
        </button>
        <button class="btn btn-primary" onclick="showAddActionDialog()">
          ‚ûï Add Action
        </button>
        <button class="btn btn-secondary" onclick="loadTaxonomy()">
          üîÑ Refresh
        </button>
      </div>
      <div
        style="padding: 1rem; border-top: 1px solid #eef2f7; background: #fff"
      >
        <small style="color: #657786"
          >Tip: Click an item to edit. Use the + buttons to add new taxonomy
          entries.</small
        >
      </div>
      <div class="main">
        <div class="content-area">
          <h2 style="margin-bottom: 2rem">
            Business Taxonomy - The Language Layer
          </h2>

          <div
            style="
              display: flex;
              gap: 8px;
              align-items: center;
              margin-bottom: 12px;
            "
          >
            <div style="font-weight: 700; font-size: 1.25rem">
              Business Taxonomy
            </div>
            <div style="margin-left: 12px; color: #657786">
              Choose a tab to view Concepts, Events or DB Actions
            </div>
          </div>

          <div
            class="taxonomy-tabs"
            style="display: flex; gap: 8px; margin-bottom: 12px"
          >
            <button
              id="taxTabConcepts"
              class="btn btn-secondary"
              onclick="switchTaxonomyTab('concepts')"
            >
              Concepts
            </button>
          </div>

          <div id="taxContent">
            <div id="tax-concepts" style="display: none">
              <h3 style="margin-bottom: 1rem; color: #667eea">
                Business Concepts
              </h3>
              <div id="concepts-list" style="margin-bottom: 2rem"></div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Tab panels are lazy-loaded from builder-tabs/ (events, actions, rules, executions)
         Lightweight placeholders below ensure tabs remain visible if lazy-loading fails. -->

    <!-- Events Tab Placeholder -->
    <div id="events-panel" class="tab-panel" style="display: none">
      <div class="toolbar">
        <button class="btn btn-primary" onclick="showAddEventDialog()">
          ‚ûï Add Event
        </button>
        <button class="btn btn-secondary" onclick="loadEvents()">
          üîÑ Refresh
        </button>
        <input
          id="events-search"
          placeholder="Search events..."
          style="margin-left: 8px; padding: 6px 8px; min-width: 220px"
          oninput="scheduleLoadEvents()"
        />
      </div>
      <div class="main">
        <div class="content-area">
          <h2 style="margin-bottom: 1rem">Business Events</h2>
          <div id="events-main-list">Loading...</div>
        </div>
      </div>
    </div>

    <!-- Actions Tab (refined) -->
    <div id="actions-panel" class="tab-panel" style="display: none; position: relative;">
      <div class="toolbar">
        <button class="btn btn-primary" id="btn-new-action">
          ‚ûï New Action
        </button>
        <button class="btn btn-secondary" id="btn-refresh-actions">
          üîÑ Refresh
        </button>
        <div style="margin-left: 12px; flex: 1 1 auto; max-width: 420px">
          <input
            id="actions-search"
            placeholder="Search actions..."
            class="form-input"
            style="width: 100%"
          />
        </div>
        <div
          id="actions-debug"
          style="margin-left: 12px; color: #657786; font-size: 12px"
        >
          &nbsp;
        </div>
      </div>

      <div class="main" style="display: flex; gap: 12px; position: relative;">
        <!-- Left: Actions list -->
        <div
          style="
            width: 320px;
            background: white;
            border-right: 1px solid #eef2f7;
            padding: 12px;
            overflow: auto;
          "
        >
          <h3 style="margin-bottom: 8px">Actions</h3>
          <div id="actions-panel-list">Loading...</div>
        </div>

        <!-- Center: Editor -->
        <div style="flex: 1; padding: 12px; overflow: auto">
          <h3 id="action-editor-title">Action Editor</h3>
          <div style="display: flex; gap: 12px">
            <div style="flex: 1">
              <div class="form-group">
                <label class="form-label" for="action-id">ID</label>
                <input
                  id="action-id"
                  class="form-input"
                  placeholder="unique-id"
                />
              </div>
              <div class="form-group">
                <label class="form-label" for="action-name">Name</label>
                <input id="action-name" class="form-input" />
              </div>
              
              <!-- Connect Inputs Section (DB Actions now consume data from Connect nodes only) -->
              <div
                class="form-group"
                style="
                  border: 2px solid #e1e8ed;
                  border-radius: 8px;
                  padding: 12px;
                  background: #f8f9fa;
                "
              >
                <div
                  style="
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    margin-bottom: 8px;
                  "
                >
                  <div class="form-label" style="margin: 0">
                    üîó Connect Inputs
                  </div>
                  <div style="font-size:0.85rem;color:#657786">Configure input mappings on Connect nodes in the Workflow Editor</div>
                </div>
                <div id="connect-input-pills-area" style="margin-top:8px;">
                  <div style="color:#8899a6;font-size:0.85rem;text-align:center;padding:8px;">No Connect inputs detected for this workflow/action.</div>
                </div>
              </div>
              <!-- DB Picker Section -->
              <div
                class="form-group"
                style="
                  border: 2px solid #e1e8ed;
                  border-radius: 8px;
                  padding: 12px;
                  background: #f8f9fa;
                  margin-top: 12px;
                "
              >
                <div
                  style="
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    margin-bottom: 8px;
                  "
                >
                  <div class="form-label" style="margin: 0">
                    üóÑÔ∏è DB Picker
                  </div>
                  <button
                    class="btn btn-secondary"
                    id="add-db-attribute"
                    type="button"
                    style="padding: 4px 12px; font-size: 0.85rem"
                    disabled
                  >
                    + Pick DB Column
                  </button>
                </div>
                <div
                  id="db-attributes-list"
                  style="
                    display: flex;
                    flex-direction: column;
                    gap: 8px;
                    min-height: 40px;
                  "
                >
                  <div
                    style="
                      color: #8899a6;
                      font-size: 0.85rem;
                      text-align: center;
                      padding: 12px;
                    "
                  >
                    No DB attributes selected. Click "Add DB Attribute" to pick table columns to persist as mappings.
                  </div>
                </div>
              </div>

              <div class="form-group">
                <label class="form-label" for="action-desc">Description</label>
                <textarea
                  id="action-desc"
                  class="form-textarea droppable-input"
                  placeholder="Describe your business use case..."
                  disabled
                ></textarea>
                <div
                  style="
                    margin-top: 8px;
                    display: flex;
                    gap: 8px;
                    align-items: center;
                  "
                >
                  <button
                    class="btn btn-secondary"
                    id="generate-query-btn"
                    type="button"
                    aria-label="Generate query from description"
                    disabled
                  >
                    <svg
                      width="16"
                      height="16"
                      viewBox="0 0 24 24"
                      fill="none"
                      xmlns="http://www.w3.org/2000/svg"
                      style="vertical-align: middle; margin-right: 6px"
                      aria-hidden="true"
                      focusable="false"
                    >
                      <rect
                        x="3"
                        y="3"
                        width="18"
                        height="6"
                        rx="1.5"
                        fill="#E6EEF6"
                        stroke="#9CA3AF"
                      />
                      <rect
                        x="6"
                        y="11"
                        width="12"
                        height="8"
                        rx="1"
                        fill="#F8FAFC"
                        stroke="#9CA3AF"
                      />
                      <circle cx="17.5" cy="6.5" r="1.5" fill="#6B7280" />
                      <text
                        x="6"
                        y="15.5"
                        font-family="Arial,Helvetica,sans-serif"
                        font-size="6"
                        fill="#374151"
                      >
                        AI
                      </text>
                    </svg>
                    <span style="vertical-align: middle"
                      >Generate Query from Description</span
                    >
                  </button>
                  <div
                    id="generate-query-status"
                    style="color: #657786; font-size: 0.85rem"
                  ></div>
                </div>
                <div
                  id="query-preview-section"
                  style="
                    display: none;
                    margin-top: 12px;
                    padding: 12px;
                    background: #f8f9fa;
                    border-radius: 8px;
                    border: 1px solid #e1e8ed;
                  "
                >
                  <div
                    style="font-weight: 600; margin-bottom: 8px; color: #2c3e50"
                  >
                    üìä Query Preview
                  </div>
                  <div
                    id="query-preview-content"
                    style="
                      background: white;
                      padding: 10px;
                      border-radius: 6px;
                      font-family: monospace;
                      font-size: 0.9rem;
                      overflow-x: auto;
                    "
                  ></div>
                  <div style="margin-top: 8px; display: flex; gap: 8px">
                    <button
                      class="btn btn-primary"
                      id="use-generated-query"
                      type="button"
                    >
                      Use This Query
                    </button>
                    <button
                      class="btn btn-secondary"
                      id="test-generated-query"
                      type="button"
                    >
                      Test Query
                    </button>
                  </div>
                  <div id="test-results" style="margin-top: 12px"></div>
                </div>
              </div>
            </div>

                  <!-- Event Data removed ‚Äî Connect inputs are used instead -->
            <div style="flex: 1">
              <!-- SQL Parameter Mapping -->
              <div
                class="form-group"
                style="
                  border: 2px solid #e1e8ed;
                  border-radius: 8px;
                  padding: 12px;
                  background: #fff8e8;
                "
              >
              <div class="form-group">
                <label class="form-label" for="action-query">SQL / Query</label>
                <textarea
                  id="action-query"
                  class="form-textarea droppable-input"
                  placeholder="INSERT INTO users (id, email) VALUES ({{connect_node_1.email}}, {{connect_node_1.id}}) -- Click Connect inputs below to insert"
                  disabled
                  style="font-family: 'Courier New', monospace"
                ></textarea>
                <div
                  style="margin-top: 6px; font-size: 0.75rem; color: #657786"
                >
                  üí° Tip: Click the Connect input fields below to insert
                  variables into your SQL. Placeholders use the format
                  <code style="font-family:monospace">{{connect_&lt;nodeId&gt;.&lt;path&gt;}}</code>.
                </div>
                <!-- Live SQL Preview: shows query with placeholders resolved to sample values -->
                <div id="sql-preview-container" style="margin-top:10px; border:1px solid #e6eef8; background:#fbfdff; padding:10px; border-radius:6px; display:none;">
                  <div style="font-size:0.78rem;color:#2c3e50;margin-bottom:6px;font-weight:600;">SQL Preview (live)</div>
                  <pre id="sql-preview-area" style="white-space:pre-wrap;word-break:break-word;margin:0;font-family: 'Courier New', monospace;color:#0b2545;">-- SQL preview will appear here</pre>
                </div>
                <div id="variable-mapping-area" style="margin-top:10px;">
                  <div style="color:#8899a6;font-size:0.85rem;text-align:center;padding:8px;">Click Connect input fields below to insert variables. Detected variables will appear here.</div>
                </div>
              </div>

              <!-- Preview & Test Section -->
              <div
                class="form-group"
                style="
                  border: 2px solid #e1e8ed;
                  border-radius: 8px;
                  padding: 12px;
                  background: #f0f7ff;
                "
              >
                <div
                  style="
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    margin-bottom: 8px;
                  "
                >
                  <div class="form-label" style="margin: 0">
                    üîç Preview & Test
                  </div>
                  <div style="display: flex; gap: 6px">
                    <button
                      class="btn btn-secondary"
                      id="test-with-real-events"
                      type="button"
                      style="padding: 4px 12px; font-size: 0.85rem"
                      disabled
                      title="Test SQL with multiple real event samples"
                    >
                      üé≤ Test with Real Events
                    </button>
                    
                  </div>
                </div>
                <div id="test-execution-area" style="display: none">
                  <div id="test-results-area" style="margin-top: 12px"></div>
                </div>
              </div>

              <div style="display: flex; gap: 8px; align-items: center">
                <button class="btn btn-primary" id="action-save" disabled>
                  Save
                </button>
                <button class="btn btn-secondary" id="action-delete" disabled>
                  Delete
                </button>
                <div
                  id="action-status"
                  style="margin-left: 12px; color: #657786"
                >
                  Idle
                </div>
              </div>
            </div>
          </div>
        </div>

      </div>

      <script>
        // Runtime config for AI integration
        async function ensureRuntimeConfig() {
          if (globalThis.__RUNTIME_CONFIG__) {
            globalThis.RUNTIME_CONFIG = globalThis.__RUNTIME_CONFIG__;
            return globalThis.RUNTIME_CONFIG;
          }
          try {
            const res = await fetch("/runtime-config");
            const cfg = await res.json();
            globalThis.RUNTIME_CONFIG = cfg;
            return cfg;
          } catch (e) {
            console.warn("Could not load runtime config, using defaults", e);
            globalThis.RUNTIME_CONFIG = {
              ai: { mode: "proxy", directUrl: "/large" },
            };
            return globalThis.RUNTIME_CONFIG;
          }
        }

        // Load all schema metadata for AI context
        let cachedSchemaMetadata = null;
        async function loadSchemaMetadata() {
          if (cachedSchemaMetadata) return cachedSchemaMetadata;

          try {
            // Try to load from schema store first
            const idx = await fetch("/schema-store");
            if (idx.ok) {
              const indexData = await idx.json();
              if (
                indexData &&
                indexData.index &&
                indexData.index.tables &&
                indexData.index.tables.length > 0
              ) {
                const metadata = {
                  tables: {},
                  tablesList: indexData.index.tables,
                };

                // Load each table's schema
                for (const tableName of indexData.index.tables) {
                  try {
                    const tableRes = await fetch(
                      `/schema-store/table/${tableName}`
                    );
                    if (tableRes.ok) {
                      const tableData = await tableRes.json();
                      if (tableData.table && tableData.table.schema) {
                        metadata.tables[tableName] = tableData.table.schema;
                      }
                    }
                  } catch (e) {
                    console.warn(`Could not load table ${tableName}:`, e);
                  }
                }

                cachedSchemaMetadata = metadata;
                return metadata;
              }
            }
          } catch (e) {
            console.warn("Schema store not available, trying API:", e);
          }

          // Fallback to /api/db/schema
          try {
            const r = await fetch("/api/db/schema");
            if (r.ok) {
              const data = await r.json();
              if (data && data.tables) {
                const metadata = {
                  tables: data.tables,
                  tablesList: Object.keys(data.tables),
                };
                cachedSchemaMetadata = metadata;
                return metadata;
              }
            }
          } catch (e) {
            console.warn("API schema not available, trying config file:", e);
          }

          // Final fallback to config/database.json
          try {
            const r2 = await fetch("/config/database.json");
            if (r2.ok) {
              const meta = await r2.json();
              let tables = {};
              if (meta && meta.tables) {
                tables = meta.tables;
              } else if (Array.isArray(meta)) {
                meta.forEach((t) => {
                  if (t && t.name) tables[t.name] = t.columns || t.fields || [];
                });
              } else if (typeof meta === "object") {
                Object.keys(meta).forEach((k) => {
                  const v = meta[k];
                  if (Array.isArray(v)) tables[k] = v;
                  else if (v && v.columns) tables[k] = v.columns;
                });
              }
              const metadata = {
                tables: tables,
                tablesList: Object.keys(tables),
              };
              cachedSchemaMetadata = metadata;
              return metadata;
            }
          } catch (e) {
            console.error("Could not load any schema metadata:", e);
          }

          return { tables: {}, tablesList: [] };
        }

        (function () {
          let autosaveTimer = null;
          let currentAction = null; // object being edited
          let pendingChanges = false; // track unsaved edits; only save on explicit Save
          let variableMappings = {}; // {varName: {eventId, field, type}}

          // Initialize AI and event handlers on load
          (async function initAI() {
            await ensureRuntimeConfig();

            // Wait for DOM to be ready before setting up handlers
            if (document.readyState === "loading") {
              document.addEventListener("DOMContentLoaded", setupHandlers);
            } else {
              setupHandlers();
            }

            function setupHandlers() {
              // Event Data flow removed; use Connect inputs instead
                // Setup DB attribute handlers
                setupDbAttributeHandlers();
                // Connect inputs rendering removed (pills handled elsewhere)

              // Setup SQL parameter detection
              setupSQLParameterDetection();

              // Enable variable drag-and-drop on query textarea
              if (typeof VariableInsertion !== 'undefined') {
                const queryTextarea = document.getElementById("action-query");
                const descTextarea = document.getElementById("action-desc");
                if (queryTextarea) VariableInsertion.enableDropZone(queryTextarea);
                if (descTextarea) VariableInsertion.enableDropZone(descTextarea);
              }

              // Setup preview/test handlers
              setupPreviewHandlers();

              // Setup Generate Query button
              const generateBtn = document.getElementById("generate-query-btn");
              if (generateBtn) {
                generateBtn.addEventListener(
                  "click",
                  generateQueryFromDescription
                );
                // wire description input to update enablement
                const descEl = document.getElementById("action-desc");
                if (descEl) {
                  descEl.addEventListener('input', updateGenerateEnabled);
                }
                // initial check
                setTimeout(updateGenerateEnabled, 0);
              }

              // Setup Use Generated Query button
              const useQueryBtn = document.getElementById(
                "use-generated-query"
              );
              if (useQueryBtn) {
                useQueryBtn.addEventListener("click", () => {
                  const previewContent = document.getElementById(
                    "query-preview-content"
                  );
                  const queryTextarea = document.getElementById("action-query");
                  if (previewContent && queryTextarea) {
                    queryTextarea.value = previewContent.textContent;
                    showToast("Query copied to SQL field", "success");
                  }
                });
              }

              // Setup Test Query button
              const testQueryBtn = document.getElementById(
                "test-generated-query"
              );
              if (testQueryBtn) {
                testQueryBtn.addEventListener("click", testGeneratedQuery);
              }
            }
          })();

          async function generateQueryFromDescription() {
            const descTextarea = document.getElementById("action-desc");
            const statusDiv = document.getElementById("generate-query-status");
            const previewSection = document.getElementById(
              "query-preview-section"
            );
            const previewContent = document.getElementById(
              "query-preview-content"
            );

            const businessUseCase = descTextarea.value.trim();

            if (!businessUseCase) {
              showToast(
                "Please enter a business use case in the Description field",
                "error"
              );
              return;
            }

            try {
              statusDiv.textContent = "Loading schema metadata...";
              const schema = await loadSchemaMetadata();

              if (!schema.tablesList || schema.tablesList.length === 0) {
                showToast(
                  "No database schema available. Please ensure the schema is loaded.",
                  "error"
                );
                statusDiv.textContent = "";
                return;
              }

              statusDiv.textContent = "Generating query with AI...";

              // Build context similar to db-explorer
              let context = `Available tables: ${schema.tablesList.join(
                ", "
              )}\n\n`;
              context += "Schema information:\n";

              schema.tablesList.forEach((tableName) => {
                const tableSchema = schema.tables[tableName];
                context += `\nTable: ${tableName}\n`;

                if (tableSchema && tableSchema.columns) {
                  const columns = Array.isArray(tableSchema.columns)
                    ? tableSchema.columns
                    : Object.values(tableSchema.columns);
                  context += `Columns: ${columns
                    .map((c) => {
                      const colName =
                        typeof c === "string"
                          ? c
                          : c.Field || c.name || c.COLUMN_NAME || "";
                      const colType =
                        typeof c === "string" ? "" : c.Type || c.type || "";
                      return colType ? `${colName} (${colType})` : colName;
                    })
                    .join(", ")}\n`;

                  if (tableSchema.rowCount) {
                    context += `Row count: ${tableSchema.rowCount}\n`;
                  }
                } else if (Array.isArray(tableSchema)) {
                  context += `Columns: ${tableSchema
                    .map((c) => {
                      const colName =
                        typeof c === "string"
                          ? c
                          : c.Field || c.name || c.COLUMN_NAME || "";
                      const colType =
                        typeof c === "string" ? "" : c.Type || c.type || "";
                      return colType ? `${colName} (${colType})` : colName;
                    })
                    .join(", ")}\n`;
                }
              });

              // Include any selected DB attributes (persisted in variableMappings.dbAttributes)
              if (variableMappings && Array.isArray(variableMappings.dbAttributes) && variableMappings.dbAttributes.length > 0) {
                context += '\nSelected DB attributes (persisted):\n';
                variableMappings.dbAttributes.forEach(a => {
                  context += ` - ${a.table}.${a.column}\n`;
                });
                context += '\n';
              }

              // Event data flow removed; no event context included for AI generation
              let eventContext = "";

              const prompt = `${context}\n\n${eventContext}Business Use Case: ${businessUseCase}\n\nIMPORTANT ‚Äî Event SQL language and binder rules (must follow exactly):\n\n1) Table/Column mapping: Use the event metadata to determine the target table and column names. Treat the event's 'module' value as the literal SQL table name, and the event's 'field' value as the literal column name. Do NOT put table or column names inside braces or quotes ‚Äî they must be plain SQL identifiers matching the schema provided in the context.\n\n2) Dynamic values / binder placeholders: For any dynamic value coming from an event payload, use ONLY the exact placeholders listed in the "Exact placeholders detected" section above. Each dynamic value must use the event-bridge binder placeholder format exactly: {{<bindingName>.<fieldPath>}} where <bindingName> is the event binding identifier (the same string used in the bindings list, e.g. appsthink_crm:phone_number:added) and <fieldPath> is the exact path inside the event payload (for example value, detail.phone_number, or data.someField). Do NOT invent or assume any other field names or paths. Example: {{appsthink_crm:phone_number:added.value}}.\n\n3) Resolution behavior: The executor (eventBridge.tryResolveQuery) will replace each {{...}} placeholder with a properly SQL-quoted literal (it handles escaping and NULL). Therefore DO NOT quote or escape {{...}} placeholders yourself ‚Äî write SQL so that placeholders appear exactly where a SQL literal value belongs (e.g. VALUES ({{...}})).\n\n4) Preferred field access: Use the exact paths provided in the placeholders list (do not replace with ".value" unless that exact placeholder appears in the list). If the payload nests the value under detail or data, use detail.<name> or data.<name> exactly as listed.\n\n5) Output requirements: Produce a single, executable Event-SQL statement (or a minimal set of statements) that uses literal table/column names from the metadata and {{...}} placeholders for values. Return ONLY the SQL (no explanation, no markdown, no additional tags).\n\nExample (for clarity only; use actual metadata and bindings from the context above):\nINSERT INTO appsthink_crm (phone_number) VALUES ({{appsthink_crm:phone_number:added.value}});\n\nGenerate the SQL now for the Business Use Case. Use the schema and metadata provided in the context above, and prefer actual event sample values only for guidance ‚Äî do not hardcode example literal values into the SQL.`;

              const aiTarget =
                globalThis.RUNTIME_CONFIG &&
                globalThis.RUNTIME_CONFIG.ai &&
                globalThis.RUNTIME_CONFIG.ai.mode === "direct"
                  ? globalThis.RUNTIME_CONFIG.ai.directUrl
                  : "/ai/send";

              const response = await fetch(aiTarget, {
                method: "POST",
                headers: {
                  "Content-Type": "application/json",
                },
                body: JSON.stringify({
                  sessionId: "orchestration-builder-" + Date.now(),
                  aiquestion: prompt,
                }),
                timeout: 120000,
              });

              if (!response.ok) {
                throw new Error(
                  `AI request failed: ${response.status} ${response.statusText}`
                );
              }

              const result = await response.json();

              // Parse the AI response
              let sqlQuery = "";
              if (result && typeof result === "object") {
                if (result.ok === false) {
                  const errText =
                    result.error ||
                    (result.diagnostics && result.diagnostics.message) ||
                    `AI request failed (HTTP ${result.statusCode})`;
                  showToast(`AI Error: ${errText}`, "error");
                  statusDiv.textContent = "";
                  return;
                }

                const payload = result.data || result;
                if (typeof payload === "string") {
                  try {
                    const parsed = JSON.parse(payload);
                    sqlQuery = parsed.response || payload;
                  } catch (e) {
                    sqlQuery = payload;
                  }
                } else if (typeof payload === "object") {
                  sqlQuery = payload.response || payload;
                } else {
                  sqlQuery = String(payload);
                }
              } else if (typeof result === "string") {
                try {
                  const parsed = JSON.parse(result);
                  sqlQuery = parsed.response || parsed.data || result;
                } catch (e) {
                  sqlQuery = result;
                }
              }

              // Clean up the SQL query - remove markdown code blocks
              sqlQuery = sqlQuery
                .replace(/```sql\n?/gi, "")
                .replace(/```\n?/g, "")
                .trim();

              if (!sqlQuery) {
                showToast("AI did not return a valid SQL query", "error");
                statusDiv.textContent = "";
                return;
              }

              // Display in preview
              previewContent.textContent = sqlQuery;
              previewSection.style.display = "block";
              statusDiv.textContent = "Query generated successfully!";

              setTimeout(() => {
                statusDiv.textContent = "";
              }, 3000);
            } catch (error) {
              console.error("Generate query error:", error);
              showToast(`Error generating query: ${error.message}`, "error");
              statusDiv.textContent = "";
            }
          }

          async function testGeneratedQuery() {
            const previewContent = document.getElementById(
              "query-preview-content"
            );
            const testResults = document.getElementById("test-results");

            const query = previewContent.textContent.trim();

            if (!query) {
              showToast("No query to test", "error");
              return;
            }

            // Extract table name from query
            let table = null;
            // Try to extract from query (simple heuristic)
            const fromMatch = query.match(/FROM\s+([a-zA-Z_][a-zA-Z0-9_]*)/i);
            if (fromMatch) {
              table = fromMatch[1];
            }

            if (!table) {
              showToast(
                "Could not extract table name from query. Please ensure the query has a FROM clause.",
                "error"
              );
              return;
            }

            try {
              testResults.innerHTML =
                '<div style="color: #657786;">‚è≥ Executing query...</div>';

              const response = await fetch(`/${table}`, {
                method: "POST",
                headers: {
                  "Content-Type": "application/json",
                },
                body: JSON.stringify({ prompt: query }),
                timeout: 30000,
              });

              if (!response.ok) {
                throw new Error(
                  `Query execution failed: ${response.status} ${response.statusText}`
                );
              }

              const result = await response.json();

              if (!result.data || !Array.isArray(result.data)) {
                testResults.innerHTML = `
                  <div style="padding: 10px; background: white; border-radius: 6px; border: 1px solid #e1e8ed;">
                    <strong style="color: #28a745;">‚úì Query executed successfully</strong><br>
                    <code style="color: #657786;">${
                      result.executedQuery || result.query || query
                    }</code><br><br>
                    No rows returned.
                  </div>
                `;
                return;
              }

              const data = result.data;
              const columns = Object.keys(data[0] || {});

              let html = `
                <div style="padding: 10px; background: white; border-radius: 6px; border: 1px solid #e1e8ed;">
                  <strong style="color: #28a745;">‚úì Query executed successfully</strong><br>
                  <code style="color: #657786;">${result.executedQuery || result.query || query}</code>
                </div>
                <div style="margin-top: 10px; max-height: 300px; overflow: auto; background: white; border-radius: 6px; border: 1px solid #e1e8ed;">
                  <table style="width: 100%; border-collapse: collapse; font-size: 0.85rem;">
                    <thead>
                      <tr style="background: #f8f9fa;">
                        ${columns
                          .map(
                            (col) =>
                              `<th style="padding: 8px; text-align: left; border-bottom: 2px solid #e1e8ed;">${col}</th>`
                          )
                          .join("")}
                      </tr>
                    </thead>
                    <tbody>
              `;

              data.slice(0, 100).forEach((row) => {
                html += "<tr>";
                columns.forEach((col) => {
                  html += `<td style="padding: 8px; border-bottom: 1px solid #eef2f7;">${
                    row[col] !== null
                      ? row[col]
                      : "<em style='color: #999;'>NULL</em>"
                  }</td>`;
                });
                html += "</tr>";
              });

              html += "</tbody></table></div>";

              if (data.length > 100) {
                html += `<p style="margin-top: 8px; color: #657786; font-size: 0.85rem;">Showing first 100 rows of ${data.length} total rows.</p>`;
              }

              testResults.innerHTML = html;
              showToast("Query test successful!", "success");
              try {
                const examples = normalizeSqlResult(result);
                if (typeof currentAction !== 'undefined' && currentAction) {
                  currentAction.variableMappings = currentAction.variableMappings || {};
                  currentAction.variableMappings._exampleOutputs = examples;
                  currentAction.variableMappings.template = result.executedQuery || query;
                }
                if (selectedNode && selectedNode.type === 'action') {
                  selectedNode.data = selectedNode.data || {};
                  selectedNode.data.variableMappings = selectedNode.data.variableMappings || {};
                  selectedNode.data.variableMappings._exampleOutputs = examples;
                  selectedNode.data.variableMappings.template = result.executedQuery || query;
                }
                try { pendingChanges = true; } catch(e) {}
                try { document.getElementById("action-status").textContent = "Pending changes..."; } catch(e) {}
              } catch (e) { console.warn('persist example outputs failed', e); }
            } catch (error) {
              console.error("Test query error:", error);
              testResults.innerHTML = `
                <div style="padding: 10px; background: #fff3cd; border-radius: 6px; border: 1px solid #ffc107; color: #856404;">
                  <strong>‚ö† Query Execution Failed</strong><br>
                  ${error.message}
                </div>
              `;
              showToast(`Query test failed: ${error.message}`, "error");
            }
          }

          // ====== EVENT BINDING & PAYLOAD MAPPING SYSTEM (NEW MODAL SYSTEM) ======

          // Event binding UI removed ‚Äî Connect inputs are used instead

          // Event Data modal removed ‚Äî Connect inputs provide mapping and samples

          async function setupDbAttributeHandlers() {
            const addDbBtn = document.getElementById('add-db-attribute');
            if (addDbBtn) {
              // enable button only when schema is available
              try {
                const schema = await loadSchemaMetadata();
                if (schema && Array.isArray(schema.tablesList) && schema.tablesList.length > 0) addDbBtn.disabled = false;
              } catch (e) {}
              addDbBtn.addEventListener('click', showDbPickerModal);
            }
            // render initial list
            try { renderDbAttributesList(); } catch(e){}
          }

          async function showDbPickerModal() {
            try {
              // Get current DB variables
              const preSelected = (variableMappings && variableMappings.dbAttributes) || [];
              
              // Show modal
              const selected = await DbPickerModal.show({ preSelected });
              
              // Save selected variables
              if (!variableMappings) variableMappings = {};
              variableMappings.dbAttributes = selected;
              
              // Register in variable registry
              selected.forEach(col => {
                const varPath = col.path || `{{db.${col.table}.${col.column}}}`;
                VariableRegistry.register(varPath, { 
                  source: 'db', 
                  table: col.table, 
                  column: col.column 
                });
              });
              
              // Mark changes and render
              try { pendingChanges = true; } catch(e) {}
              try { document.getElementById("action-status").textContent = "Pending changes..."; } catch(e) {}
              renderDbAttributesList();
              
              showToast(`${selected.length} DB columns selected`, 'success');
            // Event selector removed ‚Äî event binding flow deprecated in favor of Connect inputs
              const eventsData = await eventsRes.json();
              const registry =
                eventsData && eventsData.registry ? eventsData.registry : {};

              // Parse registry into a deduplicated flat list of events
              const eventsMap = new Map();
              const rawKeys = Object.keys(registry || {});

              for (const k of rawKeys) {
                if (!k) continue;
                // Skip special keys
                if (typeof k === "string" && (k.startsWith("evt:") || k.startsWith("dlq:"))) continue;

                const val = registry[k];

                // If value looks like a module (has .events), extract all events
                if (val && typeof val === "object" && val.events) {
                  Object.keys(val.events).forEach((eventName) => {
                    const id = eventName;
                    const cnt = Number(val.events[eventName]) || 1;
                    if (!eventsMap.has(id)) {
                      eventsMap.set(id, { id, name: id, module: k, count: cnt });
                    } else {
                      const existing = eventsMap.get(id);
                      existing.count = (existing.count || 0) + cnt;
                    }
                  });
                } else {
                  // Otherwise treat key as an event name
                  const eventName = k;
                  const moduleName = typeof eventName === "string" && eventName.includes(":") ? String(eventName).split(":")[0] : "misc";

                  let cnt = 0;
                  if (val && typeof val === "object" && (val.total || val.count)) cnt = val.total || val.count;
                  else if (typeof val === "number") cnt = val;
                  else cnt = 1;

                  if (!eventsMap.has(eventName)) {
                    eventsMap.set(eventName, { id: eventName, name: eventName, module: moduleName, count: cnt });
                  } else {
                    const existing = eventsMap.get(eventName);
                    existing.count = (existing.count || 0) + cnt;
                  }
                }
              }

              // Convert map to sorted array (most frequent first)
              const eventsList = Array.from(eventsMap.values()).sort((a, b) => (b.count || 0) - (a.count || 0));

              if (eventsList.length === 0) {
                showToast(
                  "No events available. Trigger some events first.",
                  "info"
                );
                return;
              }

              // Build event selector modal
              const modal = document.createElement("div");
              modal.style.cssText = "max-height: 400px; overflow-y: auto;";

              eventsList.forEach((event) => {
                const eventItem = document.createElement("div");
                eventItem.style.cssText =
                  "padding: 12px; margin: 8px 0; border: 1px solid #e1e8ed; border-radius: 6px; cursor: pointer; transition: all 0.2s;";
                eventItem.innerHTML = `
                  <div style="display: flex; justify-content: space-between; align-items: center;">
                    <div>
                      <div style="font-weight: 600; color: #2c3e50;">${event.name}</div>
                      <div style="font-size: 0.75rem; color: #8899a6; margin-top: 2px;">Module: ${event.module}</div>
                    </div>
                    <div style="font-size: 0.75rem; color: #657786; background: #f0f3f5; padding: 4px 8px; border-radius: 12px;">
                      ${event.count} fired
                    </div>
                  </div>
                `;

                eventItem.addEventListener("mouseenter", () => {
                  eventItem.style.background = "#f8f9fa";
                  eventItem.style.borderColor = "#667eea";
                });

                eventItem.addEventListener("mouseleave", () => {
                  eventItem.style.background = "white";
                  eventItem.style.borderColor = "#e1e8ed";
                });

                eventItem.addEventListener("click", () => {
                  addEventBinding(event);
                  document.querySelector(".modal-overlay").remove();
                });

                modal.appendChild(eventItem);
              });

              await _createModal({
                title: "Select Event to Bind",
                bodyEl: modal,
                showCancel: true,
                confirmText: "Cancel",
              });
            } catch (error) {
              console.error("Error showing event selector:", error);
              showToast("Error loading events: " + error.message, "error");
            }
          }

          // addEventBinding removed ‚Äî event binding flow deprecated in favor of Connect inputs

          async function fetchEventPayloadSchema(event) {
            // Fetch actual event records to extract real payload schema
            try {
              const response = await fetch(
                `/api/event-records?module=${encodeURIComponent(
                  event.module
                )}&event=${encodeURIComponent(event.name)}`
              );

              if (!response.ok) {
                console.warn(
                  "Could not fetch event records, using default schema"
                );
                return getDefaultSchema();
              }

              const data = await response.json();
              const records = data && data.records ? data.records : [];

              if (records.length === 0) {
                console.warn("No event records found, using default schema");
                return getDefaultSchema();
              }

              // Get the most recent record to infer schema
              const latestRecord = records[0];

              // Extract payload from the record
              let payload =
                latestRecord.payload || latestRecord.data || latestRecord;

              // If payload is a string, try to parse it
              if (typeof payload === "string") {
                try {
                  payload = JSON.parse(payload);
                } catch (e) {
                  console.warn("Could not parse payload JSON");
                }
              }

              // Infer schema from actual payload, prioritizing business data
              return inferSchemaFromSample(payload);
            } catch (error) {
              console.error("Error fetching event payload schema:", error);
              return getDefaultSchema();
            }
          }

          function getDefaultSchema() {
            return {
              primaryFields: {
                value: {
                  type: "string",
                  description: "Event value",
                  sample: null,
                },
              },
              metadataFields: {
                id: { type: "string", description: "Event ID" },
                timestamp: { type: "datetime", description: "Event timestamp" },
              },
            };
          }

          function inferSchemaFromSample(sample) {
            const schema = {
              primaryFields: {},
              metadataFields: {},
            };

            if (typeof sample === "object" && sample !== null) {
              // Extract detail/data object as primary fields (business data)
              const detailObj = sample.detail || sample.data || sample.payload;

              if (detailObj && typeof detailObj === "object") {
                // Process detail fields as primary (these are the business data)
                Object.keys(detailObj).forEach((key) => {
                  const value = detailObj[key];
                  const fieldType = inferFieldType(value);

                  schema.primaryFields[key] = {
                    type: fieldType,
                    description: `${key} (${fieldType})`,
                    sample: value,
                    path: `detail.${key}`, // Track the actual path
                  };
                });
              } else {
                // No detail object, treat first-level non-metadata fields as primary
                Object.keys(sample).forEach((key) => {
                  const value = sample[key];
                  const fieldType = inferFieldType(value);

                  // Identify metadata vs business fields
                  const metadataKeys = [
                    "id",
                    "event",
                    "module",
                    "domain",
                    "version",
                    "ts",
                    "publishedTs",
                    "producer",
                    "actor",
                    "status",
                    "attempts",
                    "level",
                    "canonicalEvent",
                    "field",
                  ];

                  if (metadataKeys.includes(key)) {
                    schema.metadataFields[key] = {
                      type: fieldType,
                      description: `${key} (${fieldType})`,
                      sample: value,
                    };
                  } else {
                    schema.primaryFields[key] = {
                      type: fieldType,
                      description: `${key} (${fieldType})`,
                      sample: value,
                    };
                  }
                });
              }

              // Always add ALL standard metadata fields if they exist
              const standardMetadataKeys = [
                "id",
                "event",
                "module",
                "domain",
                "version",
                "ts",
                "publishedTs",
                "status",
                "attempts",
                "level",
                "field",
                "canonicalEvent",
              ];
              standardMetadataKeys.forEach((key) => {
                if (sample[key] !== undefined && !schema.metadataFields[key]) {
                  const value = sample[key];
                  const fieldType = inferFieldType(value);
                  schema.metadataFields[key] = {
                    type: fieldType,
                    description: `${key} (metadata)`,
                    sample: value,
                  };
                }
              });

              // Extract nested metadata: actor (user, role, group)
              if (sample.actor && typeof sample.actor === "object") {
                Object.keys(sample.actor).forEach((actorKey) => {
                  const actorValue = sample.actor[actorKey];
                  const fieldKey = `actor.${actorKey}`;
                  if (!schema.metadataFields[fieldKey]) {
                    schema.metadataFields[fieldKey] = {
                      type: inferFieldType(actorValue),
                      description: `${actorKey} (actor metadata)`,
                      sample: actorValue,
                      path: `actor.${actorKey}`,
                    };
                  }
                });
              }

              // Extract nested metadata: producer (service, instance)
              if (sample.producer && typeof sample.producer === "object") {
                Object.keys(sample.producer).forEach((producerKey) => {
                  const producerValue = sample.producer[producerKey];
                  const fieldKey = `producer.${producerKey}`;
                  if (!schema.metadataFields[fieldKey]) {
                    schema.metadataFields[fieldKey] = {
                      type: inferFieldType(producerValue),
                      description: `${producerKey} (producer metadata)`,
                      sample: producerValue,
                      path: `producer.${producerKey}`,
                    };
                  }
                });
              }
            }

            return schema;
          }

          function inferFieldType(value) {
            if (value === null) return "null";
            if (Array.isArray(value)) return "array";
            if (
              value instanceof Date ||
              (typeof value === "string" &&
                !Number.isNaN(Date.parse(value)) &&
                value.includes("T"))
            ) {
              return "datetime";
            }
            if (typeof value === "number") {
              return Number.isInteger(value) ? "integer" : "number";
            }
            if (typeof value === "object") return "object";
            return typeof value;
          }

          // Event bindings UI removed ‚Äî Connect inputs drive parameter mapping now

          globalThis.toggleMetadata = function (id) {
            const el = document.getElementById(id);
            const toggleIcon = document.getElementById(
              "metadata-toggle-" + id.split("-")[1]
            );
            if (el) {
              if (el.style.display === "none") {
                el.style.display = "block";
                if (toggleIcon) toggleIcon.textContent = "‚ñº";
              } else {
                el.style.display = "none";
                if (toggleIcon) toggleIcon.textContent = "‚ñ∂";
              }
            }
          };

          // Event payload helpers removed ‚Äî use Connect input insertion helpers instead

          function setupSQLParameterDetection() {
            const queryTextarea = document.getElementById("action-query");
            if (queryTextarea) {
              queryTextarea.addEventListener("input", () => {
                detectSQLParameters();
                triggerAutosave();
              });
            }
          }

          function detectSQLParameters() {
            const query = document.getElementById("action-query").value;
            // Match placeholders like {{binding:module:entity:action.fieldPath}} or {{eventName.field}}
            // capture binding identifier (allow colons, dashes, letters, numbers, underscores) and field path (anything until closing brace or whitespace)
            const paramRegex = /\{\{([^\.\}\s]+)\.([^\}\s]+)\}\}/g;
            const params = [];
            let match;

            while ((match = paramRegex.exec(query)) !== null) {
              params.push({
                eventName: match[1],
                fieldName: match[2],
                fullMatch: match[0],
              });
            }

            renderVariableMappings(params);
          }

          // Resolve connect placeholders and render live SQL preview
          function renderSQLPreview() {
            try {
              const ta = document.getElementById('action-query');
              const previewContainer = document.getElementById('sql-preview-container');
              const previewArea = document.getElementById('sql-preview-area');
              if (!ta || !previewArea || !previewContainer) return;
              const q = ta.value || '';
              if (!q.trim()) {
                previewArea.textContent = '-- SQL preview will appear here';
                previewContainer.style.display = 'none';
                return;
              }
              // replace {{connect_nodeId.path}} placeholders with sample values
              const replaced = q.replace(/\{\{\s*connect_([\w-]+)\.([^\}]+)\s*\}\}/g, function (m, nodeId, path) {
                try {
                  const nd = (nodes || []).find(n => String(n.id) === String(nodeId));
                  if (!nd) return m;
                  // prefer persisted example outputs -> mappingPreview -> examplePayload
                  const trySources = [];
                  if (nd.data && nd.data.variableMappings && Array.isArray(nd.data.variableMappings._exampleOutputs) && nd.data.variableMappings._exampleOutputs.length > 0) trySources.push(nd.data.variableMappings._exampleOutputs[0]);
                  if (nd.data && nd.data.mappingPreview) trySources.push(nd.data.mappingPreview);
                  if (nd.data && nd.data.examplePayload) trySources.push(nd.data.examplePayload);
                  let val;
                  for (const s of trySources) {
                    if (!s) continue;
                    // try exact path then try stored parser-friendly path
                    val = safeGetGlobal(s, path);
                    if (val !== undefined) break;
                  }
                  if (val === undefined) return 'NULL';
                  return escapeForSQL(val);
                } catch (e) { return m; }
              });
              previewArea.textContent = replaced;
              previewContainer.style.display = 'block';
            } catch (e) { /* ignore */ }
          }

          // Make renderSQLPreview globally callable
          try { if (typeof globalThis !== 'undefined') globalThis.renderSQLPreview = renderSQLPreview; } catch (e) {}

          function escapeForSQL(v) {
            if (v === null) return 'NULL';
            if (typeof v === 'number') return String(v);
            if (typeof v === 'boolean') return v ? 'TRUE' : 'FALSE';
            // objects/arrays: JSON stringify
            if (typeof v === 'object') {
              try { return `'${String(JSON.stringify(v)).replace(/'/g, "''")}'`; } catch (e) { return 'NULL'; }
            }
            // string: escape single quotes
            try { return `'${String(v).replace(/'/g, "''")}'`; } catch (e) { return 'NULL'; }
          }

          function renderVariableMappings(params) {
            const container = document.getElementById("variable-mapping-area");

            if (!container) return;

            if (params.length === 0) {
              container.innerHTML =
                '<div style="color: #8899a6; font-size: 0.85rem; text-align: center; padding: 8px;">Click Connect input fields below to insert variables. Variables will appear here.</div>';

              // Even if there are no placeholders in SQL yet, still show available Connect inputs.
              try { renderDbAttributesList(); } catch (e) {}
              try {
                if (typeof renderConnectInputPills === 'function' && typeof currentAction !== 'undefined' && currentAction && (currentAction.id || currentAction.name)) {
                  try { renderConnectInputPills(currentAction.id || currentAction.name); } catch (e) { console.warn('renderConnectInputPills call failed', e); }
                }
              } catch (e) { /* ignore */ }
              return;
            }

            container.innerHTML = `
              <div style="font-size: 0.85rem; color: #2c3e50; margin-bottom: 8px;">
                <strong>Detected Parameters:</strong>
              </div>
              <div id="selected-db-attributes" style="margin-bottom:8px;">
              </div>
              ${params
                .map((param) => {
                  // param is now {eventName, fieldName, fullMatch}
                  const eventName = param.eventName;
                  const fieldName = param.fieldName;

                  // Find which event binding this refers to (match by eventId or eventName)
                  let sourceEvent = null;
                  let fieldInfo = null;
                  let isPrimary = false;
                  let isValid = false;

                  // Event binding flow removed ‚Äî we cannot map event placeholders anymore.
                  // Show detected placeholder but advise using Connect inputs instead.
                  sourceEvent = null;
                  fieldInfo = null;
                  isPrimary = false;
                  isValid = false;

                  const sampleDisplay =
                    fieldInfo?.sample !== undefined &&
                    fieldInfo?.sample !== null
                      ? typeof fieldInfo.sample === "object"
                        ? JSON.stringify(fieldInfo.sample).substring(0, 40)
                        : String(fieldInfo.sample).substring(0, 40)
                      : "";

                  return `
                  <div style="background: ${
                    isValid ? (isPrimary ? "#f0f7ff" : "#f8f9fa") : "#fff3cd"
                  }; padding: 8px; border-radius: 6px; margin-bottom: 6px; border-left: 3px solid ${
                    isValid ? (isPrimary ? "#667eea" : "#95a5a6") : "#ffc107"
                  };">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                      <div>
                        <code style="background: ${
                          isValid ? (isPrimary ? "#e8f4ff" : "#e1e8ed") : "#fff9e6"
                        }; padding: 2px 6px; border-radius: 3px; font-size: 0.85rem;">${param.fullMatch}</code>
                        ${
                          sourceEvent
                            ? `<span style="color: #8899a6; font-size: 0.75rem; margin-left: 8px;">from ${
                                sourceEvent.eventName
                              } ${isPrimary ? "üì¶" : "üè∑Ô∏è"}</span>`
                            : `<span style="color: #8899a6; font-size: 0.75rem; margin-left: 8px;">Event variable mapping detected in SQL</span>`
                        }
                      </div>
                    </div>
                    ${
                      sampleDisplay
                        ? `<div style="font-size: 0.75rem; color: #657786; margin-top: 4px;">Sample: <code style="background: white; padding: 1px 4px; border-radius: 2px;">${sampleDisplay}</code></div>`
                        : ""
                    }
                    ${
                      fieldInfo && fieldInfo.description
                        ? `<div style="font-size: 0.75rem; color: #8899a6; margin-top: 4px;">${fieldInfo.description}</div>`
                        : ""
                    }
                  </div>
                `;
                })
                .join("")}
            `;

            // DB attributes are rendered in the dedicated DB Attributes section
            try { renderDbAttributesList(); } catch (e) {}

            // Ensure Connect input pills are rendered after variable mappings UI is produced
            try {
              if (typeof renderConnectInputPills === 'function' && typeof currentAction !== 'undefined' && currentAction && (currentAction.id || currentAction.name)) {
                try { renderConnectInputPills(currentAction.id || currentAction.name); } catch (e) { console.warn('renderConnectInputPills call failed', e); }
              }
            } catch (e) { /* ignore */ }
          }

          // Render clickable pills for Connect node inputs that are upstream of an action
          function renderConnectInputPills(actionId) {
            try {
              console.debug('renderConnectInputPills: actionId=', actionId, 'nodes=', nodes && nodes.length, 'connections=', connections && connections.length);
              const pillContainer = document.getElementById('connect-input-pills-area') || document.getElementById('variable-mapping-area');
              if (!pillContainer) return;

              // find action nodes in the current workflow that reference this action id
              const actionNodes = (nodes || []).filter(n => n.type === 'action' && n.data && (String(n.data.action) === String(actionId) || String(n.data.action) === String((currentAction && currentAction.name) || '')));

              // collect upstream connect nodes by BFS
              const connectNodes = new Map();
              function collectUpstream(startId) {
                const q = [String(startId)];
                const seen = new Set();
                while (q.length) {
                  const nid = q.shift();
                  connections.forEach(c => {
                    if (String(c.to) === String(nid)) {
                      const from = (nodes || []).find(n => String(n.id) === String(c.from));
                      if (!from) return;
                      if (from.type === 'connect') {
                        connectNodes.set(from.id, from);
                      } else if (!seen.has(from.id)) {
                        seen.add(from.id);
                        q.push(from.id);
                      }
                    }
                  });
                }
              }

              actionNodes.forEach(n => collectUpstream(n.id));

              // Build pills UI using DOM nodes (safer than string concatenation)
              console.debug('renderConnectInputPills: actionNodes=', actionNodes.map(an => an.id));
              console.debug('renderConnectInputPills: connectNodes ids=', Array.from(connectNodes.keys()));
              // Clear pill container
              pillContainer.innerHTML = '';

              if (connectNodes.size === 0) {
                console.debug('renderConnectInputPills: no connect nodes found upstream');
                const empty = document.createElement('div');
                empty.style.color = '#8899a6';
                empty.style.fontSize = '0.85rem';
                empty.style.textAlign = 'center';
                empty.style.padding = '8px';
                empty.textContent = 'No Connect inputs detected for this workflow/action.';
                pillContainer.appendChild(empty);
                return;
              }

              const header = document.createElement('div');
              header.style.marginBottom = '8px';
              const headerStrong = document.createElement('strong');
              headerStrong.textContent = 'Connect Inputs (from workflow)';
              header.appendChild(headerStrong);
              pillContainer.appendChild(header);

              connectNodes.forEach((cn) => {
                const mapping = (cn.data && (cn.data.mapping || {}));
                // Determine preview source (prefer persisted example outputs)
                let preview = {};
                try {
                  if (cn.data && cn.data.variableMappings && Array.isArray(cn.data.variableMappings._exampleOutputs) && cn.data.variableMappings._exampleOutputs.length > 0) {
                    preview = cn.data.variableMappings._exampleOutputs[0] || {};
                  } else if (cn.data && cn.data.mappingPreview && Object.keys(cn.data.mappingPreview || {}).length > 0) {
                    preview = cn.data.mappingPreview || {};
                  } else if (cn.data && cn.data.examplePayload && Object.keys(cn.data.examplePayload || {}).length > 0) {
                    preview = cn.data.examplePayload || {};
                  } else {
                    preview = {};
                  }
                } catch (e) { preview = {}; }
                const title = cn.name || cn.id;
                const keys = Object.keys(mapping).length ? Object.keys(mapping) : (Object.keys(preview).length ? Object.keys(preview) : []);
                console.debug('renderConnectInputPills: connect node', cn.id, 'mappingKeys=', keys);
                const row = document.createElement('div');
                row.style.display = 'flex';
                row.style.flexWrap = 'wrap';
                row.style.gap = '8px';
                row.style.marginBottom = '8px';
                row.style.alignItems = 'center';

                const nameDiv = document.createElement('div');
                nameDiv.style.fontWeight = '600';
                nameDiv.style.marginRight = '8px';
                nameDiv.textContent = title;
                row.appendChild(nameDiv);

                if (!keys.length) {
                  const note = document.createElement('div');
                  note.style.marginBottom = '6px';
                  note.style.color = '#657786';
                  note.textContent = `${title} ‚Äî no mapping defined`;
                  row.appendChild(note);
                } else {
                  keys.forEach(k => {
                    // mapping may map logical key -> path; resolve path and try to get sample from multiple sources
                    const mappedPath = mapping && mapping[k] ? mapping[k] : k;
                    let sampleVal = undefined;

                    // Helper to try resolution from an object using several strategies
                    function tryResolveFrom(obj) {
                      if (!obj) return undefined;
                      // exact key
                      if (Object.prototype.hasOwnProperty.call(obj, k)) return obj[k];
                      // exact mapped key
                      if (mapping && mapping[k] && Object.prototype.hasOwnProperty.call(obj, mapping[k])) return obj[mapping[k]];
                      // dotted path resolution
                      if (mapping && mapping[k]) {
                        const v = getByPath(obj, mapping[k]);
                        if (v !== undefined) return v;
                      }
                      const v2 = getByPath(obj, k);
                      if (v2 !== undefined) return v2;
                      return undefined;
                    }

                    try {
                      // 1) variableMappings._exampleOutputs (first row)
                      if (cn.data && cn.data.variableMappings && Array.isArray(cn.data.variableMappings._exampleOutputs) && cn.data.variableMappings._exampleOutputs.length > 0) {
                        sampleVal = tryResolveFrom(cn.data.variableMappings._exampleOutputs[0]);
                      }
                      // 2) mappingPreview
                      if (sampleVal === undefined && cn.data && cn.data.mappingPreview && Object.keys(cn.data.mappingPreview || {}).length > 0) {
                        sampleVal = tryResolveFrom(cn.data.mappingPreview);
                      }
                      // 3) examplePayload
                      if (sampleVal === undefined && cn.data && cn.data.examplePayload && Object.keys(cn.data.examplePayload || {}).length > 0) {
                        sampleVal = tryResolveFrom(cn.data.examplePayload);
                      }
                      // 4) mapping values could be paths to nested sample in variableMappings._exampleOutputs
                      if (sampleVal === undefined && cn.data && cn.data.variableMappings && Array.isArray(cn.data.variableMappings._exampleOutputs) && cn.data.variableMappings._exampleOutputs.length > 0) {
                        sampleVal = tryResolveFrom(cn.data.variableMappings._exampleOutputs[0]);
                      }
                      // 5) fallback: mapping keys themselves (presence indicates structure even if value null)
                      if (sampleVal === undefined && preview && Object.keys(preview).length > 0) {
                        sampleVal = tryResolveFrom(preview);
                      }
                    } catch (e) {
                      console.debug('sample resolution error for', cn.id, k, e);
                    }

                    // For debugging, log what we tried
                    console.debug('renderConnectInputPills: resolve', { connectId: cn.id, key: k, mappedPath: mappedPath, sampleValRaw: sampleVal, previewSourceKeys: Object.keys(preview || {}) });

                    let sampleText = '';
                    if (sampleVal === undefined) {
                      sampleText = '';
                    } else if (sampleVal === null) {
                      sampleText = '<NULL>';
                    } else if (typeof sampleVal === 'object') {
                      try { sampleText = JSON.stringify(sampleVal); } catch (e) { sampleText = String(sampleVal); }
                    } else {
                      sampleText = String(sampleVal);
                    }

                    const btn = document.createElement('button');
                    btn.className = 'btn btn-sm btn-secondary connect-pill';
                    btn.type = 'button';
                    btn.draggable = true;
                    btn.title = `Drag to insert {{connect_${cn.id}.${mappedPath}}} into SQL or Description`;
                    btn.textContent = k;
                    // Add drag functionality
                    btn.addEventListener('dragstart', function (e) {
                      try {
                        const payload = { connectNodeId: cn.id, path: mappedPath, key: k };
                        e.dataTransfer.setData('application/json', JSON.stringify(payload));
                        e.dataTransfer.effectAllowed = 'copy';
                      } catch (err) {
                        console.warn('dragstart failed', err);
                      }
                    });
                    if (sampleText) {
                      const span = document.createElement('span');
                      span.style.color = '#8899a6';
                      span.style.fontSize = '0.75rem';
                      span.style.marginLeft = '6px';
                      span.style.fontStyle = (sampleText === '<NULL>') ? 'italic' : 'normal';
                      span.textContent = sampleText.substring(0, 40);
                      btn.appendChild(span);
                    } else {
                      // show mapped path so user knows what was mapped
                      const meta = document.createElement('span');
                      meta.style.color = '#a0a6ad';
                      meta.style.fontSize = '0.75rem';
                      meta.style.marginLeft = '6px';
                      meta.textContent = `(mapped: ${mappedPath})`;
                      btn.appendChild(meta);
                      // Add small open-node control
                      const openBtn = document.createElement('button');
                      openBtn.className = 'btn btn-sm';
                      openBtn.style.marginLeft = '8px';
                      openBtn.style.padding = '4px 8px';
                      openBtn.textContent = 'Open node';
                      openBtn.addEventListener('click', function (ev) {
                        ev.stopPropagation && ev.stopPropagation();
                        try { selectNode(cn); } catch (e) { try { showNodeProperties(cn); } catch (err) { console.warn(err); } }
                      });
                      row.appendChild(openBtn);
                    }
                    // attach safe event listener
                    btn.addEventListener('click', function () {
                      try {
                        insertConnectField(cn.id, mappedPath);
                      } catch (e) { console.warn(e); }
                    });
                    row.appendChild(btn);
                  });
                }

                pillContainer.appendChild(row);
              });

              // Ensure editor state reflects Connect presence
              try { setActionsEditState(); } catch (e) {}
            } catch (e) {
              console.warn('renderConnectInputPills failed', e);
            }
          }

          

              // Delete a mapping key from a Connect node and refresh UI
              function deleteConnectMapping(connectNodeId, colKey, path) {
                try {
                  const nd = (nodes || []).find(n => n.id === connectNodeId);
                  if (!nd) {
                    showToast('Connect node not found', 'error');
                    return;
                  }

                  // Remove from mapping and mappingPreview if present
                  if (nd.data) {
                    if (nd.data.mapping && Object.prototype.hasOwnProperty.call(nd.data.mapping, colKey)) {
                      delete nd.data.mapping[colKey];
                    }
                    if (nd.data.mappingPreview && Object.prototype.hasOwnProperty.call(nd.data.mappingPreview, colKey)) {
                      delete nd.data.mappingPreview[colKey];
                    }
                  }

                  // If currentAction references this connect placeholder, remove related inputMapping entries
                  try {
                    const placeholder = `{{connect_${connectNodeId}.${path}}}`;
                    if (currentAction && currentAction.variableMappings && currentAction.variableMappings.inputMapping) {
                      Object.keys(currentAction.variableMappings.inputMapping).forEach(k => {
                        const v = currentAction.variableMappings.inputMapping[k];
                        if (typeof v === 'string' && v.indexOf(placeholder) !== -1) {
                          delete currentAction.variableMappings.inputMapping[k];
                        }
                      });
                    }

                    if (selectedNode && selectedNode.data && selectedNode.data.variableMappings && selectedNode.data.variableMappings.inputMapping) {
                      Object.keys(selectedNode.data.variableMappings.inputMapping).forEach(k => {
                        const v = selectedNode.data.variableMappings.inputMapping[k];
                        if (typeof v === 'string' && v.indexOf(placeholder) !== -1) {
                          delete selectedNode.data.variableMappings.inputMapping[k];
                        }
                      });
                    }
                  } catch (e) { /* ignore mapping cleanup errors */ }

                  // Mark as changed and refresh UI
                  try { pendingChanges = true; } catch (e) {}
                  try { document.getElementById('action-status').textContent = 'Pending changes...'; } catch (e) {}
                  try { setActionsEditState(); } catch (e) {}

                  showToast('Connect mapping deleted', 'success');
                } catch (e) {
                  console.warn('deleteConnectMapping failed', e);
                  showToast('Failed to delete mapping', 'error');
                }
              }

            // Helper: return true when current action or selected node has a Connect input mapping
            function ensureBindingsOrConnectPresent() {
              try {
                // Check currentAction (actions editor)
                const hasActionMapping = currentAction && currentAction.variableMappings && currentAction.variableMappings.inputMapping && Object.keys(currentAction.variableMappings.inputMapping).length > 0;
                if (hasActionMapping) return true;

                // Check selected node in workflow (when editing action node properties)
                const nodeHasConnect = selectedNode && selectedNode.type === 'action' && selectedNode.data && (
                  (selectedNode.data.variableMappings && selectedNode.data.variableMappings.inputMapping && Object.keys(selectedNode.data.variableMappings.inputMapping).length > 0) ||
                  (selectedNode.data.inputSource && selectedNode.data.inputSource.type === 'connect')
                );
                if (nodeHasConnect) return true;

                showToast('Please configure a Connect input mapping for this action', 'info');
                return false;
              } catch (e) {
                console.warn('ensureBindingsOrConnectPresent failed', e);
                showToast('Missing Connect mapping', 'info');
                return false;
              }
            }

          function insertConnectField(connectNodeId, path) {
            try {
              const queryTextarea = document.getElementById('action-query');
              if (!queryTextarea) return;
              const placeholder = `{{connect_${connectNodeId}.${path}}}`;
              insertAtCursor(queryTextarea, placeholder);
              // re-detect parameters
              setTimeout(() => detectSQLParameters(), 80);
              showToast('Inserted connect input placeholder', 'success');
            } catch (e) {
              console.warn('insertConnectField failed', e);
            }
          }

          // Disable/enable DB Actions editing controls depending on whether any Connect inputs exist
          function setActionsEditState() {
            try {
              const hasConnect = (nodes || []).some(n => {
                if (!n || n.type !== 'connect' || !n.data) return false;
                const m = n.data.mapping || null;
                const p = n.data.mappingPreview || null;
                const hasMapping = m && typeof m === 'object' && Object.keys(m).length > 0;
                const hasPreview = p && typeof p === 'object' && Object.keys(p).length > 0;
                return hasMapping || hasPreview;
              });
              const ids = ['action-query','action-desc','generate-query-btn','use-generated-query','test-generated-query','test-with-real-events','action-save','action-delete','add-db-attribute'];
              ids.forEach(id => {
                const el = document.getElementById(id);
                if (!el) return;
                try {
                  el.disabled = !hasConnect;
                } catch (e) { /* ignore */ }
              });

              // visually mark variable mapping area when disabled
              const varArea = document.getElementById('variable-mapping-area');
              if (varArea) {
                if (!hasConnect) {
                  varArea.style.opacity = '0.6';
                } else {
                  varArea.style.opacity = '1';
                }
              }
            } catch (e) {
              console.warn('setActionsEditState failed', e);
            }
          }
          

          function setupPreviewHandlers() {
            const testRealBtn = document.getElementById("test-with-real-events");
            if (testRealBtn) {
              testRealBtn.addEventListener("click", testWithRealEvents);
            }
            // Live preview: update SQL preview on input
            try {
              const qta = document.getElementById('action-query');
              if (qta) qta.addEventListener('input', () => { try { if (globalThis.renderSQLPreview) globalThis.renderSQLPreview(); } catch (e){} });
              const dta = document.getElementById('action-desc');
              if (dta) dta.addEventListener('input', () => { try { if (globalThis.renderSQLPreview) globalThis.renderSQLPreview(); } catch (e){} });
            } catch (e) { /* ignore */ }
          }

          

          // ====== ENHANCED AI & REAL EVENT TESTING SYSTEM ======

          async function testWithRealEvents() {
            try {
              // Determine the query to test (from current action editor or selected action node)
              const queryEl = document.getElementById('action-query');
              const tpl = queryEl && queryEl.value ? queryEl.value.trim() : (selectedNode && selectedNode.data && (selectedNode.data.query || (selectedNode.data.variableMappings && selectedNode.data.variableMappings.template))) || '';
              if (!tpl) return showToast('No SQL template available to test', 'error');

              // Collect connect placeholders from the query: matches like {{connect_node_2.phone_number}}
              const placeholderRegex = /\{\{([^\.\}\s]+)\.([^\}\s]+)\}\}/g;
              const placeholders = [];
              let m;
              while ((m = placeholderRegex.exec(tpl)) !== null) {
                placeholders.push({ full: m[0], ns: m[1], path: m[2] });
              }

              if (placeholders.length === 0) {
                showToast('No Connect placeholders detected in query. Use Connect inputs to insert variables first.', 'info');
                return;
              }

              // Group by connect node id (expect ns like 'connect_node_2' or 'connect_node_1')
              const byNode = {};
              placeholders.forEach(p => {
                const ns = p.ns;
                let nodeId = ns;
                // support both forms: 'connect_node_2' or 'connect-node-2' (best-effort)
                if (ns.startsWith('connect_')) nodeId = ns.replace('connect_', 'node_');
                // fallback: if string contains 'node_' use that; else leave ns
                byNode[ns] = byNode[ns] || { ns, nodeId: ns.replace('connect_', ''), paths: new Set() };
                byNode[ns].paths.add(p.path);
              });

              // Build payloads map: node namespace -> example payload
              const payloads = {};
              for (const key of Object.keys(byNode)) {
                const info = byNode[key];
                // Extract node id from namespace: expect 'connect_node_<id>' or 'connectnode'<id>
                let nodeId = null;
                const ns = info.ns;
                const nodeMatch = ns.match(/connect[_\-]?(?:node[_\-])?(.*)/i);
                if (nodeMatch && nodeMatch[1]) nodeId = 'node_' + nodeMatch[1].replace(/^node[_\-]?/, '');
                // fallback: try exact ns as id
                if (!nodeId) nodeId = info.nodeId;

                const nd = (nodes || []).find(n => n.id === nodeId || n.id === info.nodeId || (n.id === ns));
                let sample = {};
                if (nd && nd.data && nd.data.variableMappings && Array.isArray(nd.data.variableMappings._exampleOutputs) && nd.data.variableMappings._exampleOutputs.length > 0) {
                  sample = nd.data.variableMappings._exampleOutputs[0];
                } else if (nd && nd.data && nd.data.mappingPreview) {
                  // mappingPreview may include keys with nulls ‚Äî use keys as placeholders
                  sample = {};
                  Object.keys(nd.data.mappingPreview).forEach(k => sample[k] = nd.data.mappingPreview[k] === null ? null : nd.data.mappingPreview[k]);
                } else if (nd && nd.data && nd.data.mapping) {
                  sample = {};
                  Object.keys(nd.data.mapping).forEach(k => sample[k] = null);
                } else {
                  // no node found ‚Äî build minimal sample from paths
                  sample = {};
                  info.paths.forEach(p => { sample[p] = null; });
                }
                payloads[key] = sample;
              }

              // For now, use the first node's payload as the payload argument ‚Äî executor resolves connect placeholders server-side
              // Merge multiple payloads into one top-level object namespaced by node if needed by server; we will pass { connects: { <ns>: sample } }
              const mergedPayload = { connects: {} };
              Object.keys(payloads).forEach(k => { mergedPayload.connects[k] = payloads[k]; });

              const resultsArea = document.getElementById('test-results') || null;
              if (resultsArea) resultsArea.innerHTML = '<div style="color:#657786">‚è≥ Executing query using Connect samples...</div>';

              // Execute via server helper which understands connect placeholders
              const exec = await executeSQLWithPayload(tpl, mergedPayload, null);
              if (!exec || !exec.success) {
                const msg = exec && exec.error ? exec.error : 'Execution failed';
                if (resultsArea) resultsArea.innerHTML = `<div style="color:#c0392b">${escapeHtml(String(msg))}</div>`;
                showToast('Query execution failed', 'error');
                return;
              }

              // Normalize and persist example outputs to the action and selected node if applicable
              const examples = normalizeSqlResult(exec.result || exec.data || []);
              try {
                if (currentAction) {
                  currentAction.variableMappings = currentAction.variableMappings || {};
                  currentAction.variableMappings._exampleOutputs = examples;
                  currentAction.variableMappings.template = exec.executedQuery || tpl;
                }
                if (selectedNode && selectedNode.type === 'action') {
                  selectedNode.data = selectedNode.data || {};
                  selectedNode.data.variableMappings = selectedNode.data.variableMappings || {};
                  selectedNode.data.variableMappings._exampleOutputs = examples;
                  selectedNode.data.variableMappings.template = exec.executedQuery || tpl;
                }
                try { pendingChanges = true; } catch(e) {}
                try { document.getElementById('action-status').textContent = 'Pending changes...'; } catch(e) {}
              } catch (e) { console.warn('persist example outputs failed', e); }

              // Render results in UI
              try {
                const data = Array.isArray(exec.result) ? exec.result : (exec.data && Array.isArray(exec.data) ? exec.data : (exec.result && exec.result.data) || []);
                if (!data || data.length === 0) {
                  if (resultsArea) resultsArea.innerHTML = `<div style="color:#657786">‚úì Query executed. No rows returned.</div>`;
                } else {
                  const cols = Object.keys(data[0] || {});
                  let html = `<div style="padding:10px;background:white;border:1px solid #e1e8ed;border-radius:6px"><strong style="color:#28a745">‚úì Query executed</strong><br><code style="color:#657786">${escapeHtml(exec.executedQuery || tpl)}</code></div>`;
                  html += `<div style="margin-top:10px;max-height:300px;overflow:auto;background:white;border-radius:6px;border:1px solid #e1e8ed"><table style="width:100%;border-collapse:collapse;font-size:0.85rem"><thead><tr>`;
                  html += cols.map(c => `<th style="padding:8px;text-align:left;border-bottom:2px solid #e1e8ed">${escapeHtml(c)}</th>`).join('');
                  html += `</tr></thead><tbody>`;
                  data.slice(0,100).forEach(row => {
                    html += '<tr>' + cols.map(col => `<td style="padding:8px;border-bottom:1px solid #eef2f7">${row[col]!==null && row[col]!==undefined ? escapeHtml(String(row[col])) : "<em style='color:#999'>NULL</em>"}</td>`).join('') + '</tr>';
                  });
                  html += `</tbody></table></div>`;
                  if (resultsArea) resultsArea.innerHTML = html;
                }
              } catch (e) { console.warn('render test results failed', e); }

              showToast('Test run complete', 'success');
            } catch (err) {
              console.error('testWithRealEvents failed', err);
              showToast('Test run failed: ' + (err && err.message ? err.message : String(err)), 'error');
            }
          }

          async function executeSQLWithPayload(query, payload, binding) {
            // Call server-side executor which resolves templates using the canonical bridge
            // Returns a structured object: { success: bool, error?: string, result?: {...}, executedQuery?: string }
            try {
              if (!query || typeof query !== 'string' || !query.trim()) {
                return { success: false, error: 'Missing or empty query', result: null, executedQuery: null };
              }

              const eventName = binding && binding.eventName ? binding.eventName : null;

              try {
                console.log('event execute -> sending to /api/event/execute', {
                  eventName: eventName,
                  hasClientEventBridge: !!globalThis.eventBridge,
                  clientEventBridgeMethods: globalThis.eventBridge ? Object.keys(globalThis.eventBridge) : null
                });
              } catch (dbg) {}

              const resp = await fetch('/api/event/execute', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ query: query, eventName: eventName, payload: payload }),
                timeout: 60000
              });

              const raw = await resp.text().catch(() => '');
              let j = null;
              try { j = raw ? JSON.parse(raw) : null; } catch (e) { j = null; }

              const executedQuery = j && (j.executedQuery || j.query) ? (j.executedQuery || j.query) : null;

              if (!resp.ok) {
                const details = j && j.details ? j.details : raw;
                return { success: false, error: `HTTP ${resp.status}: ${details}`, result: j, executedQuery };
              }

              if (j && j.ok === false) {
                return { success: false, error: j.error || 'Execution failed', result: j, executedQuery };
              }

              const data = Array.isArray(j && j.data ? j.data : null) ? j.data : (j && j.data && j.data.rows) || [];

              return {
                success: true,
                result: { processedQuery: (j && j.query) || query, data: data, rowCount: (j && j.rowCount) || (data || []).length },
                executedQuery
              };
            } catch (e) {
              return { success: false, error: e && e.message ? e.message : String(e), result: null, executedQuery: null };
            }
          }

          // Expose executor to global scope so other IIFEs can call it
          try {
            if (typeof globalThis !== 'undefined') globalThis.executeSQLWithPayload = executeSQLWithPayload;
          } catch (e) {
            /* ignore */
          }

          // Global insertAtCursor function for drag-drop operations
          globalThis.insertAtCursor = function(input, text) {
            try {
              const start = input.selectionStart || 0;
              const end = input.selectionEnd || 0;
              const v = input.value || "";
              input.value = v.slice(0, start) + text + v.slice(end);
              input.selectionStart = input.selectionEnd = start + text.length;
              input.focus();
              if (typeof triggerAutosave === 'function') triggerAutosave();
            } catch (e) {
              input.value += text;
              if (typeof triggerAutosave === 'function') triggerAutosave();
            }
          };

          // Make detectSQLParameters global for drag-drop
          globalThis.detectSQLParameters = detectSQLParameters;

          // Resolve variables in query using bound event schemas and payload values.
          // Supports {{FULL_EVENT_NAME.field.path}} where field.path may include dots (e.g. actor.user or detail.email)
          function resolveQueryWithBindings(query, payload, binding) {
            // Event-binding based query resolution has been deprecated.
            // Connect placeholders ({{connect_<nodeId>.<path>}}) are resolved server-side.
            return query;
          }

          function getValueFromPayload(payload, fieldPath) {
            if (!payload) return undefined;
            const parts = fieldPath.split(".");
            // Try direct nesting first
            let v = payload;
            for (const p of parts) {
              if (v && Object.prototype.hasOwnProperty.call(v, p)) v = v[p];
              else {
                v = undefined;
                break;
              }
            }
            if (v !== undefined) return v;

            // Fallback checks: top-level, detail, data
            // if fieldPath refers to a single property name
            if (parts.length === 1) {
              const key = parts[0];
              if (payload && Object.prototype.hasOwnProperty.call(payload, key))
                return payload[key];
              if (
                payload &&
                payload.detail &&
                Object.prototype.hasOwnProperty.call(payload.detail, key)
              )
                return payload.detail[key];
              if (
                payload &&
                payload.data &&
                Object.prototype.hasOwnProperty.call(payload.data, key)
              )
                return payload.data[key];
            }

            // Try nested inside detail/data
            v = payload && payload.detail ? payload.detail : undefined;
            if (v) {
              let tmp = v;
              for (const p of parts) {
                if (tmp && Object.prototype.hasOwnProperty.call(tmp, p))
                  tmp = tmp[p];
                else {
                  tmp = undefined;
                  break;
                }
              }
              if (tmp !== undefined) return tmp;
            }

            v = payload && payload.data ? payload.data : undefined;
            if (v) {
              let tmp = v;
              for (const p of parts) {
                if (tmp && Object.prototype.hasOwnProperty.call(tmp, p))
                  tmp = tmp[p];
                else {
                  tmp = undefined;
                  break;
                }
              }
              if (tmp !== undefined) return tmp;
            }

            return undefined;
          }

          // Deep-search for a key name anywhere in a nested payload (objects/arrays).
          // Returns the first matching value found or undefined if not present.
          function deepFindKey(obj, key) {
            if (obj === null || obj === undefined) return undefined;
            if (typeof obj !== 'object') return undefined;
            const stack = [obj];
            const seen = new WeakSet();
            while (stack.length) {
              const cur = stack.shift();
              if (!cur || typeof cur !== 'object') continue;
              if (seen.has(cur)) continue;
              seen.add(cur);
              if (Object.prototype.hasOwnProperty.call(cur, key)) return cur[key];
              for (const k of Object.keys(cur)) {
                try {
                  const v = cur[k];
                  if (v && typeof v === 'object') stack.push(v);
                } catch (e) {
                  /* ignore property access errors */
                }
              }
            }
            return undefined;
          }

          // Global safe getter: use getValueFromPayload if available, otherwise fallback to simple dotted resolution and deepFindKey as last resort
          function safeGetGlobal(obj, path) {
            try {
              if (typeof getValueFromPayload === 'function') return getValueFromPayload(obj, path);
            } catch (e) { /* continue */ }
            if (!obj || !path) return undefined;
            const parts = String(path).split('.');
            let cur = obj;
            for (const p of parts) {
              if (cur && Object.prototype.hasOwnProperty.call(cur, p)) cur = cur[p];
              else { cur = undefined; break; }
            }
            if (cur !== undefined) return cur;
            // fallback: try deepFindKey to locate by key name
            try { const last = parts[parts.length - 1]; return deepFindKey(obj, last); } catch (e) { return undefined; }
          }

          function renderRealEventTestResults(testResults, allPassed) {
            const resultsArea = document.getElementById("test-results-area");

            const summary = `
              <div style="background: ${
                allPassed ? "#d4edda" : "#fff3cd"
              }; padding: 12px; border-radius: 6px; border-left: 3px solid ${
              allPassed ? "#c3e6cb" : "#ffc107"
            }; margin-bottom: 12px;">
                <strong style="color: ${allPassed ? "#155724" : "#856404"};">
                  ${allPassed ? "‚úÖ All Tests Passed" : "‚ö† Some Tests Failed"}
                </strong><br>
                <div style="margin-top: 6px; color: ${
                  allPassed ? "#155724" : "#856404"
                }; font-size: 0.85rem;">
                  Tested with ${testResults.length} real event sample(s)<br>
                  ${testResults.filter((r) => r.success).length} passed, ${
              testResults.filter((r) => !r.success).length
            } failed
                </div>
              </div>
            `;

            function renderResultTable(data, limit = 10) {
              if (!data || !Array.isArray(data) || data.length === 0) return '<div style="color:#657786;font-size:0.85rem;">No rows to display</div>';
              const cols = Object.keys(data[0] || {});
              const head = cols.map(c => `<th style="padding:6px;border-bottom:1px solid #e6eef6;background:#f7fbff;text-align:left;font-size:0.8rem">${escapeHtml(c)}</th>`).join('');
              const rows = data.slice(0, limit).map(r => {
                const cells = cols.map(c => `<td style="padding:6px;border-bottom:1px solid #f1f5f9;font-size:0.8rem;vertical-align:top">${escapeHtml(JSON.stringify(r[c] === undefined ? '' : r[c]))}</td>`).join('');
                return `<tr>${cells}</tr>`;
              }).join('');
              const more = data.length > limit ? `<div style="font-size:0.75rem;color:#657786;margin-top:6px">Showing ${limit} of ${data.length} rows</div>` : '';
              return `<div style="overflow-x:auto"><table style="border-collapse:collapse;width:100%"><thead><tr>${head}</tr></thead><tbody>${rows}</tbody></table></div>${more}`;
            }

            const details = testResults.map((test, idx) => {
              const id = `test-${idx}`;
              const success = !!test.success;
              const cardBg = success ? 'white' : '#fff8f0';
              const border = success ? '1px solid #e6f4ea' : '1px solid #ffd8a8';
              const titleColor = success ? '#1b7f3a' : '#8a4b00';
              const rowCount = test.result && (Array.isArray(test.result.data) ? test.result.data.length : (test.result.rowCount || 0));

              const executedSql = (test.result && (test.result.executedQuery || test.result.processedQuery)) || (test.errorQuery || '');

              return `
                <div style="background:${cardBg}; border-radius:8px; padding:12px; margin-bottom:12px; border:${border};">
                  <div style="display:flex;justify-content:space-between;align-items:center;gap:8px;">
                    <div>
                      <strong style="color:${titleColor}; font-size:0.95rem;">${success ? '‚úì' : '‚úï'} Test ${idx + 1}: ${escapeHtml(test.eventName || 'unnamed')} (Sample ${test.sampleIndex || '-'})</strong>
                      <div style="font-size:0.8rem;color:#657786;margin-top:4px">${success ? `${rowCount} row(s) returned` : `Error: ${escapeHtml(test.error || 'Unknown')}`}</div>
                    </div>
                    <div style="display:flex;gap:8px;align-items:center">
                      <button class="btn btn-sm" onclick="(function(){const t=document.getElementById('${id}');t.style.display=t.style.display==='none'?'block':'none'})()" style="padding:4px 8px;font-size:0.8rem">Details</button>
                      <button class="btn btn-sm" onclick="(function(){navigator.clipboard && navigator.clipboard.writeText(${JSON.stringify(executedSql)})})()" style="padding:4px 8px;font-size:0.8rem">Copy SQL</button>
                    </div>
                  </div>
                  <div id="${id}" style="display:none;margin-top:10px;padding-top:10px;border-top:1px solid #eef4fb">
                    <div style="display:flex;gap:12px;flex-direction:column">
                      <div>
                        <strong style="font-size:0.8rem">Event Payload</strong>
                        <pre style="background:#f8f9fa;padding:8px;border-radius:6px;overflow:auto;font-size:0.8rem;max-height:240px">${escapeHtml(JSON.stringify(test.payload || {}, null, 2))}</pre>
                      </div>
                      <div>
                        <strong style="font-size:0.8rem">SQL Preview / Executed SQL</strong>
                        <pre style="background:#f4f7fb;padding:8px;border-radius:6px;overflow:auto;font-size:0.8rem">${escapeHtml(executedSql || (test.result && test.result.processedQuery) || '')}</pre>
                        ${test.error ? `<div style="margin-top:6px;color:#8a4b00;font-size:0.85rem"><strong>Error Details:</strong> ${escapeHtml(test.error)}</div>` : ''}
                      </div>
                      <div>
                        <strong style="font-size:0.8rem">Result (first rows)</strong>
                        <div style="margin-top:6px">${renderResultTable(Array.isArray(test.result && test.result.data) ? test.result.data : (Array.isArray(test.result) ? test.result : []), 10)}</div>
                      </div>
                      ${!success && test.result && test.result.executedQuery ? `<div style="margin-top:8px"><strong style="font-size:0.8rem">Server executedQuery (from error response)</strong><pre style="background:#fff1f0;padding:8px;border-radius:6px;overflow:auto">${escapeHtml(test.result.executedQuery || '')}</pre></div>` : ''}
                    </div>
                  </div>
                </div>
              `;
            }).join('');

            resultsArea.innerHTML = summary + details;
          }

          globalThis.toggleDetails = function (id) {
            const el = document.getElementById(id);
            if (el) {
              el.style.display = el.style.display === "none" ? "block" : "none";
            }
          };

          async function aiSuggestMappings() {
            if (!ensureBindingsOrConnectPresent()) return;

            const description = document.getElementById("action-desc").value;

            if (!description || !description.trim()) {
              showToast("Please enter a description first", "info");
              return;
            }

            try {
              showToast("Asking AI for suggestions (using Connect inputs)...", "info");

              // Build context for AI using Connect node mappings and example outputs
              let context = "Available Connect variables and samples:\n\n";

              const connectNodes = (nodes || []).filter(n => n.type === 'connect');
              connectNodes.forEach(cn => {
                context += `Connect Node: ${cn.name || cn.id} (${cn.id})\n`;
                const mapping = (cn.data && (cn.data.mapping || cn.data.mappingPreview)) || {};
                const exampleOutputs = (cn.data && cn.data.variableMappings && cn.data.variableMappings._exampleOutputs) || [];
                const sample = exampleOutputs.length > 0 ? exampleOutputs[0] : null;
                Object.keys(mapping).forEach(key => {
                  const path = mapping[key];
                  let sampleVal = '<no-sample>';
                  let type = 'unknown';
                  if (sample && sample[path] !== undefined) {
                    sampleVal = JSON.stringify(sample[path]);
                    type = typeof sample[path];
                  }
                  context += `  - {{connect_${cn.id}.${path}}} => ${key} ‚Äî sample: ${sampleVal}, type: ${type}\n`;
                });
                context += '\n';
              });

              // append business use case and prompt instructions
              context += '\nBusiness Use Case: ' + description + '\n\n';
              context += 'Generate a SQL query that ONLY uses the variables listed above. Use the exact template syntax shown (e.g. {{connect_nodeId.path}}). Do NOT invent or assume any other fields or paths. Return only the SQL query, no explanation, no markdown code fences.';

              try {
                const aiTarget =
                  globalThis.RUNTIME_CONFIG &&
                  globalThis.RUNTIME_CONFIG.ai &&
                  globalThis.RUNTIME_CONFIG.ai.mode === 'direct'
                    ? globalThis.RUNTIME_CONFIG.ai.directUrl
                    : '/ai/send';

                const response = await fetch(aiTarget, {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({
                    sessionId: 'action-mapper-' + Date.now(),
                    aiquestion: context,
                  }),
                  timeout: 120000,
                });

                if (!response.ok) {
                  throw new Error(`AI request failed: ${response.status}`);
                }

                const result = await response.json();

                let suggestedQuery = '';
                if (result && typeof result === 'object') {
                  const payload = result.data || result;
                  if (typeof payload === 'string') {
                    suggestedQuery = payload;
                  } else if (typeof payload === 'object') {
                    suggestedQuery = payload.response || JSON.stringify(payload);
                  }
                }

                // Clean up AI response
                suggestedQuery = suggestedQuery
                  .replace(/```sql\n?/gi, '')
                  .replace(/```\n?/g, '')
                  .trim();

                if (suggestedQuery) {
                  document.getElementById('action-query').value = suggestedQuery;
                  detectSQLParameters();
                  showToast('AI suggestion applied! Review and adjust as needed.', 'success');
                } else {
                  showToast('AI did not return a valid suggestion', 'error');
                }
              } catch (error) {
                console.error('AI suggestion error:', error);
                showToast('Error getting AI suggestion: ' + error.message, 'error');
              }

            } catch (err) {
              console.error('aiSuggestMappings failed:', err);
              showToast('AI suggestion failed: ' + (err && err.message ? err.message : String(err)), 'error');
            }

          }

          // Update collectEditor to include variableMappings
          const originalCollectEditor = collectEditor;
          collectEditor = function () {
            const data = originalCollectEditor();
            data.variableMappings = variableMappings;
            return data;
          };

          // Update openForEdit to load variable mappings
          const originalOpenForEdit = openForEdit;
          openForEdit = async function (id) {
            await originalOpenForEdit(id);
            if (currentAction) {
              variableMappings = currentAction.variableMappings || {};
              try { renderDbAttributesList(); } catch(e) {}
              detectSQLParameters();
              try {
                const aid = currentAction.id || currentAction.name;
                if (aid && typeof renderConnectInputPills === 'function') {
                  setTimeout(() => {
                    try { renderConnectInputPills(aid); } catch (e) { console.warn('renderConnectInputPills after openForEdit failed', e); }
                  }, 0);
                }
              } catch (e) { /* ignore */ }
            }
          };

          // Update clearEditor to reset variable mappings
          const originalClearEditor = clearEditor;
          clearEditor = function () {
            originalClearEditor();
            variableMappings = {};
            try { renderDbAttributesList(); } catch(e) {}
            document.getElementById("test-execution-area").style.display =
              "none";
          };

          // ====== END EVENT BINDING SYSTEM ======

          async function fetchActions() {
            const el = document.getElementById("actions-panel-list");
            el.innerHTML = '<div class="muted">Loading...</div>';
            try {
              const r = await fetch("/api/actions");
              const data = await r.json();
              if (!data || !data.ok) {
                el.innerHTML =
                  '<div class="muted">Failed to load actions</div>';
                return;
              }
              // Cache all actions for duplicate checking
              allActionsCache = data.actions || {};
              let items = Object.values(data.actions || {}).sort((a, b) =>
                (a.name || a.id).localeCompare(b.name || b.id)
              );

              // If a workflow is selected, scope actions to those used by the workflow.
              try {
                if (currentWorkflow && Array.isArray(currentWorkflow.steps)) {
                  const used = new Set();
                  (currentWorkflow.steps || []).forEach((s) => {
                    try {
                      if (!s) return;
                      const candidates = [];
                      if (s.action) candidates.push(String(s.action));
                      if (s.id) candidates.push(String(s.id));
                      if (s.data && s.data.action) candidates.push(String(s.data.action));
                      candidates.forEach((c) => {
                        if (c) used.add(c);
                      });
                    } catch (e) {
                      /* ignore per-step */
                    }
                  });
                  items = items.filter(
                    (a) => a && (used.has(String(a.id)) || used.has(String(a.name)))
                  );
                }
              } catch (e) {
                /* ignore scoping errors */
              }
              if (!items.length) {
                el.innerHTML = '<div class="muted">No actions defined.</div>';
                const dbg = document.getElementById("actions-debug");
                if (dbg) dbg.textContent = "Actions: 0";
                return;
              }
              el.innerHTML = items
                .map(
                  (
                    a
                  ) => `<div class="list-item type-action" style="margin-bottom:8px; cursor:pointer;" data-action-id="${
                    a.id
                  }">
                <div style="display:flex; justify-content:space-between; align-items:center;">
                  <div><div class="list-item-title">${a.name || a.id}</div>
                  </div>
                  <div style="display:flex; gap:8px;">
                    <button class="btn btn-secondary" data-edit-id="${
                      a.id
                    }" title="Edit action" aria-label="Edit action"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="vertical-align:middle;"><path d="M12 20h9"/><path d="M16.5 3.5a2.1 2.1 0 0 1 3 3L7 19l-4 1 1-4 12.5-12.5z"/></svg></button>
                    <button class="btn btn-danger" data-del-id="${
                      a.id
                    }" title="Delete action" aria-label="Delete action"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="vertical-align:middle;"><polyline points="3 6 5 6 21 6"/><path d="M19 6l-1 14a2 2 0 0 1-2 2H8a2 2 0 0 1-2-2L5 6"/><path d="M10 11v6"/><path d="M14 11v6"/></svg></button>
                  </div>
                </div>
              </div>`
                )
                .join("");

              // Auto-open first action when Actions tab is active.
              try {
                const actionsPanel = document.getElementById('actions-panel');
                const firstId = items && items[0] && items[0].id;
                if (actionsPanel && actionsPanel.classList.contains('active') && firstId && typeof openForEdit === 'function') {
                  const currentId = (currentAction && currentAction.id) ? String(currentAction.id) : null;
                  if (!currentId || currentId !== String(firstId)) {
                    setTimeout(() => {
                      try { openForEdit(firstId); } catch (e) { console.warn('auto open action failed', e); }
                    }, 0);
                  }
                }
              } catch (e) { /* ignore */ }
            } catch (e) {
              console.error("fetchActions", e);
              el.innerHTML = '<div class="muted">Error loading actions</div>';
            }
          }

          

          function insertAtCursor(input, text) {
            try {
              const start = input.selectionStart || 0;
              const end = input.selectionEnd || 0;
              const v = input.value || "";
              input.value = v.slice(0, start) + text + v.slice(end);
              input.selectionStart = input.selectionEnd = start + text.length;
              input.focus();
              triggerAutosave();
            } catch (e) {
              input.value += text;
              triggerAutosave();
            }
          }

          

          function insertTextAtCursor(el, text) {
            // For textarea/input elements
            if (typeof el.selectionStart === 'number') {
              const start = el.selectionStart;
              const end = el.selectionEnd;
              const val = el.value;
              el.value = val.slice(0, start) + text + val.slice(end);
              // restore cursor after inserted text
              const pos = start + text.length;
              el.selectionStart = el.selectionEnd = pos;
              el.focus();
              // trigger input events if frameworks listen
              el.dispatchEvent(new Event('input', { bubbles: true }));
              return;
            }
            // fallback: append
            el.value = (el.value || '') + text;
            try { el.dispatchEvent(new Event('input', { bubbles: true })); } catch(e) {}
          }

          function collectEditor() {
            const name = (
              document.getElementById("action-name").value || ""
            ).trim();
            return {
              id: (document.getElementById("action-id").value || "").trim(),
              name: name,
              description: document.getElementById("action-desc").value || "",
              query: document.getElementById("action-query").value || "",
            };
          }

          // Global cache of all actions for duplicate checking
          let allActionsCache = {};

          async function checkNameExists(name) {
            if (!name || !name.trim()) return false;
            const trimmed = name.trim();
            // Check cache
            return Object.values(allActionsCache).some(
              (action) =>
                (action.name || "").trim().toLowerCase() ===
                trimmed.toLowerCase()
            );
          }

          function validateAndHighlightName() {
            const nameInput = document.getElementById("action-name");
            if (!nameInput) return true; // nothing to validate in this context
            const name = (nameInput.value || "").trim();

            if (!name) {
              try { nameInput.style.borderColor = ""; } catch(e) {}
              try { nameInput.style.boxShadow = ""; } catch(e) {}
              disableFormFields();
              return false;
            }

            // Check if editing existing action - allow same name
            const isEditing = currentAction && currentAction.name === name;

            if (!isEditing) {
              const exists = Object.values(allActionsCache).some(
                (action) =>
                  (action.name || "").trim().toLowerCase() ===
                  name.toLowerCase()
              );

              if (exists) {
                nameInput.style.borderColor = "#e74c3c";
                nameInput.style.boxShadow = "0 0 0 3px rgba(231, 76, 60, 0.2)";
                disableFormFields();
                showToast("Action name already exists", "error");
                return false;
              }
            }

            // Name is valid and unique
            nameInput.style.borderColor = "#28a745";
            nameInput.style.boxShadow = "0 0 0 3px rgba(40, 167, 69, 0.2)";
            enableFormFields();
            return true;
          }

          function setFieldDisabled(id, disabled) {
            try {
              const el = document.getElementById(id);
              if (!el) return;
              el.disabled = !!disabled;
            } catch (e) {
              // ignore
            }
          }

          function disableFormFields() {
            ['action-desc','action-query','generate-query-btn','action-save','use-generated-query','test-generated-query','test-with-real-events'].forEach(id => setFieldDisabled(id, true));
          }

          function enableFormFields() {
            ['action-desc','action-query','generate-query-btn','action-save','use-generated-query','test-generated-query','test-with-real-events'].forEach(id => setFieldDisabled(id, false));
          }

          // Enable Generate button only when required inputs are present:
          //  - at least one event binding
          //  - at least one DB attribute selected
          //  - non-empty Description
          function updateGenerateEnabled() {
            try {
              const generateBtn = document.getElementById("generate-query-btn");
              if (!generateBtn) return;
              const desc = (document.getElementById("action-desc").value || "").trim();
              const hasDbAttr = variableMappings && Array.isArray(variableMappings.dbAttributes) && variableMappings.dbAttributes.length > 0;
              const hasConnect = (nodes || []).some(n => n.type === 'connect' && n.data && (n.data.mapping || n.data.mappingPreview) && Object.keys(n.data.mapping || n.data.mappingPreview || {}).length > 0) || (currentAction && currentAction.variableMappings && currentAction.variableMappings.inputMapping && Object.keys(currentAction.variableMappings.inputMapping).length > 0);
              generateBtn.disabled = !(desc && hasConnect && hasDbAttr);
            } catch (e) {
              console.warn('updateGenerateEnabled failed', e);
            }
          }

          async function saveAction(now) {
            const status = document.getElementById("action-status");
            const data = collectEditor();

            if (!data.name || !data.name.trim()) {
              showToast("Name is required", "error");
              document.getElementById("action-name").focus();
              return;
            }

            if (!data.id) {
              showToast("ID is required", "error");
              return;
            }

            // Validate name doesn't exist (unless editing same action)
            if (!validateAndHighlightName()) {
              return;
            }

            // Example outputs are persisted under `variableMappings._exampleOutputs`
            // to avoid duplicating them at the top-level `exampleOutputs` field.
            // Ensure variableMappings are attached to the save payload (persist executedQuery and template)
            try {
              if (!data.variableMappings) data.variableMappings = {};
              if (variableMappings) {
                data.variableMappings = Object.assign({}, variableMappings);
                // Keep the original template in metadata to preserve the {{...}} form
                if (!data.variableMappings.template) data.variableMappings.template = data.query || null;
              }
            } catch (e) {
              console.warn('Failed to attach variableMappings to save payload', e);
            }
            try {
              status.textContent = now ? "Saving..." : "Auto-saving...";
              const method =
                currentAction && currentAction.id === data.id ? "PUT" : "POST";
              const url =
                method === "POST"
                  ? "/api/actions"
                  : `/api/actions/${encodeURIComponent(data.id)}`;
              const r = await fetch(url, {
                method,
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(data),
              });
              const d = await r.json();
              if (d && d.ok) {
                currentAction = data;
                try { pendingChanges = false; } catch(e) {}
                showToast("Action saved", "success");
                fetchActions();
                status.textContent = "Saved";
                setTimeout(() => (status.textContent = "Idle"), 1200);
                // After saving the action, execute it to produce example outputs and persist them back to the action resource
                try {
                  const execQuery = (data.query || (data.variableMappings && data.variableMappings.template) || "").toString();
                  if (execQuery && execQuery.trim()) {
                    const exec = await executeSQLWithPayload(execQuery, {}, null);
                    if (exec && exec.success) {
                      const examples = normalizeSqlResult(exec.result);
                      // attach into payload and update action on server
                      try {
                        const updatePayload = Object.assign({}, data);
                        updatePayload.variableMappings = updatePayload.variableMappings || {};
                        updatePayload.variableMappings._exampleOutputs = examples;
                        updatePayload.variableMappings.template = exec.executedQuery || updatePayload.variableMappings.template || data.query;
                        await fetch(`/api/actions/${encodeURIComponent(data.id)}`, {
                          method: 'PUT',
                          headers: { 'Content-Type': 'application/json' },
                          body: JSON.stringify(updatePayload)
                        });
                        // reflect in currentAction
                        try { currentAction.variableMappings = currentAction.variableMappings || {}; currentAction.variableMappings._exampleOutputs = examples; } catch(e){}
                      } catch (e) { console.warn('persisting action examples failed', e); }
                    }
                  } else {
                    // No executable SQL available; skip execution step
                  }
                } catch (e) { console.warn('execute after save failed', e); }
              } else {
                showToast(
                  "Save failed: " + ((d && d.error) || "unknown"),
                  "error"
                );
                status.textContent = "Error";
              }
            } catch (e) {
              console.error("saveAction", e);
              showToast("Save error: " + e.message, "error");
              status.textContent = "Error";
            }
          }

          function triggerAutosave() {
            // Mark as having pending changes but do NOT perform automatic save.
            try { pendingChanges = true; } catch (e) {}
            try { document.getElementById("action-status").textContent = "Pending changes..."; } catch (e) {}
          }

          async function deleteAction(id) {
            if (!id) return;
            if (!confirm("Delete this action?")) return;
            try {
              const r = await fetch(
                `/api/actions/${encodeURIComponent(id)}`,
                { method: "DELETE" }
              );
              const d = await r.json();
              if (d && d.ok) {
                showToast("Deleted", "success");
                fetchActions();
                clearEditor();
              } else showToast("Delete failed", "error");
            } catch (e) {
              showToast("Delete error: " + e.message, "error");
            }
          }

          function clearEditor() {
            currentAction = null;
            // auto-generate a UUIDv4 action id and disable editing
            function uuidv4Fallback() {
              return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(
                /[xy]/g,
                function (c) {
                  const r = (Math.random() * 16) | 0;
                  const v = c === "x" ? r : (r & 0x3) | 0x8;
                  return v.toString(16);
                }
              );
            }
            const genId =
              typeof crypto !== "undefined" && crypto.randomUUID
                ? crypto.randomUUID()
                : uuidv4Fallback();
            const idEl = document.getElementById("action-id");
            idEl.value = genId;
            idEl.setAttribute("disabled", "disabled");
            idEl.title = "Auto-generated id (immutable)";
            const nameInput = document.getElementById("action-name");
            nameInput.value = "";
            nameInput.style.borderColor = "";
            nameInput.style.boxShadow = "";
            document.getElementById("action-desc").value = "";
            document.getElementById("action-query").value = "";
            document.getElementById("action-status").textContent = "Idle";
            document.getElementById("action-editor-title").textContent =
              "Action Editor";
            // Disable all fields until name is entered
            disableFormFields();
            try { pendingChanges = false; } catch(e) {}
          }

          async function openForEdit(id) {
            try {
              // fetch complete actions map and pick the requested action
              const r = await fetch("/api/actions");
              const d = await r.json();
              if (!d || !d.ok) {
                showToast("Failed to load action list", "error");
                return;
              }
              const all = d.actions || {};
              const a = all[id] || null;
              if (!a) {
                showToast("Action not found", "error");
                return;
              }
              currentAction = a;
              try { pendingChanges = false; } catch(e) {}
              const idEl = document.getElementById("action-id");
              idEl.value = a.id || "";
              // id must not be editable once created
              idEl.setAttribute("disabled", "disabled");
              idEl.title = "Action id is immutable";
              const nameInput = document.getElementById("action-name");
              nameInput.value = a.name || "";
              nameInput.style.borderColor = "#28a745";
              nameInput.style.boxShadow = "0 0 0 3px rgba(40, 167, 69, 0.2)";
              document.getElementById("action-desc").value =
                a.description || "";
              // Prefer the original template if present in variableMappings, otherwise fall back to stored query
              const templateQuery = (a.variableMappings && a.variableMappings.template) ? a.variableMappings.template : null;
              document.getElementById("action-query").value = templateQuery || a.query || a.sql || "";
              document.getElementById("action-editor-title").textContent =
                "Editing: " + (a.name || a.id);
              // Enable fields when editing
              enableFormFields();
              // Render connect input pills based on workflow connections
              try {
                if (currentAction && currentAction.id) {
                  try { renderConnectInputPills(currentAction.id); } catch (e) { console.warn('renderConnectInputPills failed', e); }
                }
              } catch (e) { /* ignore */ }
            } catch (e) {
              console.error(e);
              showToast("Load error", "error");
            }
          }

          // wire UI
          document
            .getElementById("btn-refresh-actions")
            .addEventListener("click", () => {
              fetchActions();
            });
          document
            .getElementById("btn-new-action")
            .addEventListener("click", () => {
              clearEditor();
              document.getElementById("action-editor-title").textContent =
                "New Action";
              document.getElementById("action-name").focus();
            });

          // Add name validation on input
          document
            .getElementById("action-name")
            .addEventListener("input", () => {
              validateAndHighlightName();
              triggerAutosave();
            });
          document
            .getElementById("action-save")
            .addEventListener("click", () => saveAction(true));
          document
            .getElementById("action-delete")
            .addEventListener("click", () =>
              deleteAction(document.getElementById("action-id").value.trim())
            );

          ["action-id", "action-name", "action-desc", "action-query"].forEach(
            (id) => {
              const el = document.getElementById(id);
              el.addEventListener("input", () => triggerAutosave());
            }
          );

          // delegate edit/delete buttons in list
          document
            .getElementById("actions-panel-list")
            .addEventListener("click", (ev) => {
              const edit = ev.target.closest("[data-edit-id]");
              const del = ev.target.closest("[data-del-id]");
              const item = ev.target.closest("[data-action-id]");
              if (edit) {
                const id = edit.getAttribute("data-edit-id");
                openForEdit(id);
              } else if (del) {
                const id = del.getAttribute("data-del-id");
                deleteAction(id);
              } else if (item) {
                const id = item.getAttribute("data-action-id");
                openForEdit(id);
              }
            });

          // search box
          document
            .getElementById("actions-search")
            .addEventListener("input", (ev) => {
              const q = (ev.target.value || "").toLowerCase();
              document
                .querySelectorAll("#actions-panel-list .list-item")
                .forEach((li) => {
                  const text = li.textContent.toLowerCase();
                  li.style.display = text.includes(q) ? "block" : "none";
                });
            });

          // init
          globalThis.initActionsTab = async function () {
            await fetchActions();
          };
          // call immediately in case panel already visible
          try {
            if (
              document
                .getElementById("actions-panel")
                .classList.contains("active")
            )
              globalThis.initActionsTab();
          } catch (e) {
            console.warn(e);
          }
        })();
      </script>
    </div>

    <!-- Rules Tab Placeholder removed to avoid duplication; will lazy-load builder-tabs/rules-tab.html -->

    <!-- Executions Tab Placeholder -->
    <div id="executions-panel" class="tab-panel" style="display: none">
      <div class="toolbar">
        <button class="btn btn-secondary" onclick="loadExecutions()">
          üîÑ Refresh
        </button>
        <select
          class="form-select toolbar-right"
          style="width: 150px"
          id="status-filter"
          onchange="loadExecutions()"
        >
          <option value="">All Statuses</option>
          <option value="running">Running</option>
          <option value="waiting">Waiting</option>
          <option value="completed">Completed</option>
          <option value="failed">Failed</option>
        </select>
      </div>
      <div class="main">
        <div class="content-area">
          <h2 style="margin-bottom: 2rem">Workflow Executions</h2>
          <div id="executions-list">Loading...</div>
        </div>
      </div>
    </div>

    <script>
      // Global state
      let currentWorkflow = null;
      let selectedNode = null;
      let taxonomy = null;
      let workflows = [];
      let nodes = [];
      let connections = [];
      let nextNodeId = 1;
      // persistent group collapse/expand state across renders
      globalThis.__taxonomyGroupStates = globalThis.__taxonomyGroupStates || {};

      /* UI Modal + Notification Utilities (modular, reusable) */
      // modal root will be created dynamically
      (function initUIHelpers() {
        const root = document.createElement("div");
        root.id = "ui-modals";
        document.body.appendChild(root);

        const toastRoot = document.createElement("div");
        toastRoot.id = "toast-root";
        document.body.appendChild(toastRoot);

        // inject styles for modal and toast
        const style = document.createElement("style");
        style.innerHTML = `
          #ui-modals .modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.4); display:flex; align-items:center; justify-content:center; z-index:9999; }
          #ui-modals .modal { background: white; border-radius:10px; width: 640px; max-width:95%; box-shadow:0 20px 50px rgba(0,0,0,0.3); overflow:hidden; }
          #ui-modals .modal-header { padding:16px 20px; display:flex; align-items:center; justify-content:space-between; border-bottom:1px solid #eef2f7; }
          #ui-modals .modal-title { font-weight:700; color:#2c3e50; }
          #ui-modals .modal-close { width:34px; height:34px; border-radius:999px; background:#e74c3c; color:white; display:inline-flex; align-items:center; justify-content:center; cursor:pointer; box-shadow:0 4px 12px rgba(231,76,60,0.18); }
          #ui-modals .modal-body { padding:18px 20px; max-height:60vh; overflow:auto; }
          #ui-modals .modal-footer { padding:12px 20px; border-top:1px solid #eef2f7; display:flex; gap:8px; justify-content:flex-end; }
          #ui-modals .form-row { margin-bottom:12px; }
          #ui-modals label { display:block; font-size:0.85rem; color:#657786; margin-bottom:6px; }
          #ui-modals input[type=text], #ui-modals textarea, #ui-modals select { width:100%; padding:10px 12px; border-radius:8px; border:1px solid #e6eef6; font-size:0.95rem; }
          #ui-modals textarea { min-height:120px; font-family:inherit; }

          #toast-root { position: fixed; right: 20px; top: 20px; z-index:10000; display:flex; flex-direction:column; gap:10px; }
          .toast { background:white; border-radius:8px; padding:10px 14px; box-shadow:0 6px 18px rgba(0,0,0,0.12); border-left:6px solid #667eea; color:#2c3e50; min-width:180px; }
          .toast.success { border-left-color: #28a745; }
          .toast.error { border-left-color: #e74c3c; }
          .toast.info { border-left-color: #667eea; }
        `;
        document.head.appendChild(style);
        // Event registry moved to a dedicated page: /event-registry.html
        // Builder will no longer render the floating registry panel. Use the separate page to view and interact with the event registry.
      })();

      // Global group color registry to produce non-repeating, random palettes
      globalThis.__groupColorRegistry = globalThis.__groupColorRegistry || {
        keys: {},
        usedHues: [],
      };

      // Listen for orchestrator events posted by embedded CRUD UI and forward to server
      function _ensureBuilderToastContainer() {
        if (document.getElementById("builder-toast-container"))
          return document.getElementById("builder-toast-container");
        const c = document.createElement("div");
        c.id = "builder-toast-container";
        c.style.position = "fixed";
        c.style.top = "12px";
        c.style.right = "12px";
        c.style.zIndex = "99999";
        document.body.appendChild(c);
        return c;
      }
      function showBuilderToast(msg, type, timeout) {
        try {
          const container = _ensureBuilderToastContainer();
          const el = document.createElement("div");
          el.textContent = msg;
          el.style.padding = "8px 12px";
          el.style.marginTop = "8px";
          el.style.borderRadius = "4px";
          el.style.color = "#fff";
          el.style.fontFamily = "sans-serif";
          el.style.fontSize = "13px";
          el.style.boxShadow = "0 2px 6px rgba(0,0,0,0.2)";
          el.style.background =
            type === "success"
              ? "#2ecc71"
              : type === "error"
              ? "#e74c3c"
              : "#333";
          container.appendChild(el);
          setTimeout(() => {
            try {
              el.style.opacity = "0";
              el.style.transition = "opacity 300ms";
              setTimeout(() => {
                try {
                  container.removeChild(el);
                } catch (e) {
                  console.warn(e);
                }
              }, 350);
            } catch (e) {
              console.warn(e);
            }
          }, timeout || 4000);
        } catch (e) {
          console.warn("showBuilderToast failed", e);
        }
      }

      window.addEventListener("message", async function (ev) {
        try {
          const d = ev.data;
          if (typeof d === "string" && d.startsWith("orchestrator_event^")) {
            // simple refresh of discovered events when embedded CRUD posts an orchestrator_event
            try {
              setTimeout(() => {
                if (typeof loadEvents === "function") loadEvents();
              }, 100);
            } catch (e) {
              console.warn(e);
            }
          }
        } catch (e) {
          console.warn("message handler error", e);
        }
      });
      function getDistinctGroupColors(key) {
        key = key || "grp";
        if (globalThis.__groupColorRegistry.keys[key])
          return globalThis.__groupColorRegistry.keys[key];
        function pickHue() {
          return Math.floor(Math.random() * 360);
        }
        function tooClose(h) {
          return globalThis.__groupColorRegistry.usedHues.some((u) => {
            const d = Math.abs(u - h);
            return Math.min(d, 360 - d) <= 28;
          });
        }
        let hue = pickHue();
        let attempts = 0;
        while (tooClose(hue) && attempts < 36) {
          hue = (hue + Math.floor(Math.random() * 60) + 20) % 360;
          attempts++;
        }
        globalThis.__groupColorRegistry.usedHues.push(hue);
        const left = `hsl(${hue}, 92%, 97%)`;
        const right = `hsl(${(hue + 18) % 360}, 86%, 93%)`;
        const border = `hsl(${hue}, 60%, 82%)`;
        const accent = `hsl(${hue}, 68%, 46%)`;
        const out = { left, right, border, accent, hue };
        globalThis.__groupColorRegistry.keys[key] = out;
        return out;
      }

      function showToast(message, type = "info", timeout = 3000) {
        const root = document.getElementById("toast-root");
        if (!root) return;
        // simple dedupe: avoid showing identical message repeatedly within short window
        try {
          globalThis.__lastToast = globalThis.__lastToast || {
            msg: null,
            ts: 0,
          };
          const now = Date.now();
          if (
            globalThis.__lastToast.msg === message &&
            now - globalThis.__lastToast.ts < Math.max(1500, timeout - 500)
          ) {
            return;
          }
          globalThis.__lastToast.msg = message;
          globalThis.__lastToast.ts = now;
        } catch (e) {
          /* ignore */
        }
        const t = document.createElement("div");
        t.className = "toast " + (type || "info");
        t.textContent = message;
        root.appendChild(t);
        setTimeout(() => {
          t.style.opacity = "0";
          setTimeout(() => t.remove(), 250);
        }, timeout);
      }

      function escapeHtml(s) {
        if (s === null || s === undefined) return "";
        return String(s)
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/\"/g, "&quot;")
          .replace(/'/g, "&#39;");
      }

      function escapeJs(s) {
        if (s === null || s === undefined) return '';
        return String(s).replace(/\\/g, '\\\\').replace(/'/g, "\\'").replace(/\n/g, '\\n').replace(/\r/g, '');
      }

      // Helper: safely get nested value by dotted path from an object
      function getByPath(obj, path) {
        try {
          if (!obj || !path || typeof path !== 'string') return undefined;
          // If exact key exists, return directly
          if (Object.prototype.hasOwnProperty.call(obj, path)) return obj[path];
          const parts = path.split('.');
          let cur = obj;
          for (const p of parts) {
            if (cur === null || cur === undefined) return undefined;
            if (Object.prototype.hasOwnProperty.call(cur, p)) cur = cur[p];
            else return undefined;
          }
          return cur;
        } catch (e) { return undefined; }
      }

      function _createModal({
        title,
        bodyEl,
        onConfirm,
        confirmText = "OK",
        cancelText = "Cancel",
        showCancel = true,
      }) {
        return new Promise((resolve) => {
          const root = document.getElementById("ui-modals");
          const overlay = document.createElement("div");
          overlay.className = "modal-overlay";
          const modal = document.createElement("div");
          modal.className = "modal";

          const header = document.createElement("div");
          header.className = "modal-header";
          const titleEl = document.createElement("div");
          titleEl.className = "modal-title";
          titleEl.textContent = title || "";
          const closeBtn = document.createElement("div");
          closeBtn.className = "modal-close";
          closeBtn.innerHTML = "&times;";
          header.appendChild(titleEl);
          header.appendChild(closeBtn);

          const body = document.createElement("div");
          body.className = "modal-body";
          if (bodyEl) body.appendChild(bodyEl);

          const footer = document.createElement("div");
          footer.className = "modal-footer";
          const btnCancel = document.createElement("button");
          btnCancel.className = "btn btn-secondary";
          btnCancel.textContent = cancelText;
          const btnConfirm = document.createElement("button");
          btnConfirm.className = "btn btn-primary";
          btnConfirm.textContent = confirmText;
          if (showCancel) footer.appendChild(btnCancel);
          footer.appendChild(btnConfirm);

          modal.appendChild(header);
          modal.appendChild(body);
          modal.appendChild(footer);
          overlay.appendChild(modal);
          root.appendChild(overlay);

          function cleanup() {
            overlay.remove();
          }
          closeBtn.addEventListener("click", () => {
            cleanup();
            resolve(null);
          });
          btnCancel.addEventListener("click", () => {
            cleanup();
            resolve(null);
          });
          btnConfirm.addEventListener("click", () => {
            try {
              const v = onConfirm && onConfirm();
              cleanup();
              resolve(v === undefined ? true : v);
            } catch (e) {
              cleanup();
              resolve(null);
            }
          });
        });
      }

      async function showConfirm(message) {
        const el = document.createElement("div");
        const p = document.createElement("div");
        p.textContent = message;
        el.appendChild(p);
        const res = await _createModal({
          title: "Confirm",
          bodyEl: el,
          confirmText: "Yes",
          cancelText: "No",
        });
        return !!res;
      }

      async function showFormModal(title, fields) {
        const form = document.createElement("div");
        const inputs = {};
        fields.forEach((f) => {
          const row = document.createElement("div");
          row.className = "form-row";
          const label = document.createElement("label");
          label.textContent = f.label || f.name;
          row.appendChild(label);
          let input;
          if (f.type === "textarea") {
            input = document.createElement("textarea");
            input.value = f.value || "";
          } else {
            input = document.createElement("input");
            input.type = "text";
            input.value = f.value || "";
          }
          if (f.placeholder) input.placeholder = f.placeholder;
          inputs[f.name] = input;
          row.appendChild(input);

          // optional DB chooser button
          if (f.dbChooser) {
            const btn = document.createElement("button");
            btn.className = "btn btn-secondary";
            btn.style.marginLeft = "8px";
            btn.textContent = "Choose from DB";
            btn.addEventListener("click", async (ev) => {
              ev.preventDefault();
              // require Name to be set before choosing DB
              if (inputs["name"] && !(inputs["name"].value || "").trim()) {
                showToast("Enter name first", "error");
                try {
                  inputs["name"].focus();
                } catch (e) {
                  console.warn(e);
                }
                return;
              }
              const sel = await showDBExplorer("Choose table/columns");
              if (sel) {
                // tables-only selection (new shape): populate as CSV of table names
                if (sel.type === "tables" && Array.isArray(sel.tables)) {
                  input.value = sel.tables.join(",");
                }
                // legacy single table + columns
                else if (sel.table && sel.columns) {
                  input.value = sel.table + "." + sel.columns.join(",");
                }
                // legacy single table
                else if (sel.table) {
                  input.value = sel.table;
                }
                // taxonomy/rules selection: try to use id or name
                else if (sel.type && sel.item) {
                  input.value = sel.item.id || sel.item.name || "";
                }
              }
            });
            row.appendChild(btn);
          }

          form.appendChild(row);
        });
        const res = await _createModal({
          title,
          bodyEl: form,
          onConfirm: () => {
            const out = {};
            for (const k of Object.keys(inputs)) out[k] = inputs[k].value;
            return out;
          },
          confirmText: "Save",
        });
        return res;
      }

      async function showJSONEditor(title, json) {
        const ta = document.createElement("textarea");
        ta.value = JSON.stringify(json || [], null, 2);
        ta.style.fontFamily = "monospace";
        ta.style.minHeight = "240px";
        const res = await _createModal({
          title,
          bodyEl: ta,
          onConfirm: () => {
            try {
              return JSON.parse(ta.value);
            } catch (e) {
              showToast("Invalid JSON: " + e.message, "error");
              return null;
            }
          },
          confirmText: "Save",
        });
        return res;
      }

      // DB Explorer modal - reusable component
      async function showDBExplorer(title) {
        // loads DB schema from the required /api/db/schema endpoint (no fallbacks)
        const root = document.createElement("div");
        root.style.display = "flex";
        root.style.flexDirection = "column";
        root.style.gap = "8px";

        // tabs
        const tabs = document.createElement("div");
        tabs.style.display = "flex";
        tabs.style.gap = "8px";
        tabs.style.marginBottom = "8px";

        const tabTables = document.createElement("button");
        tabTables.className = "tab";
        tabTables.textContent = "Tables";

        const tabTaxonomy = document.createElement("button");
        tabTaxonomy.className = "tab";
        tabTaxonomy.textContent = "Taxonomy";

        const tabRules = document.createElement("button");
        tabRules.className = "tab";
        tabRules.textContent = "Rules";

        tabs.appendChild(tabTables);
        tabs.appendChild(tabTaxonomy);
        tabs.appendChild(tabRules);
        root.appendChild(tabs);

        const body = document.createElement("div");
        body.style.display = "flex";
        body.style.gap = "12px";
        body.style.minHeight = "240px";

        const left = document.createElement("div");
        left.style.width = "260px";
        left.style.borderRight = "1px solid #eef2f7";
        left.style.padding = "8px";
        const middle = document.createElement("div");
        middle.style.flex = "1";
        const right = document.createElement("div");
        right.style.width = "260px";
        right.style.borderLeft = "1px solid #eef2f7";
        right.style.padding = "8px";

        body.appendChild(left);
        body.appendChild(middle);
        body.appendChild(right);
        root.appendChild(body);

        // load DB schema from the single required endpoint (no fallbacks)
        let schema = null;
        try {
          const r = await fetch("/api/db/schema");
          if (r.ok) schema = await r.json();
        } catch (e) {
          schema = null;
        }
        if (!schema) {
          showToast(
            "Unable to load database schema from /api/db/schema",
            "error"
          );
          // expose empty schema so UI can render an informative message
          schema = { tables: {} };
        }

        const tables = schema.tables || {};
        try {
          globalThis.__lastDbTables = tables;
        } catch (e) {
          console.warn(e);
        }
        const tableKeys = Object.keys(tables);
        // tables that require fully-qualified column values (table.column)
        const QUALIFIED_TABLES = ["crimping_process"];
        let selectedTable = null;
        let selectedColumns = [];

        // statuses added when properties exist
        let statuses = [];

        // status input area
        const statusArea = document.createElement("div");
        statusArea.style.display = "none";
        statusArea.style.marginTop = "8px";
        const statusInput = document.createElement("input");
        statusInput.type = "text";
        statusInput.placeholder = "Add status and press Enter or click +";
        statusInput.style.padding = "8px";
        statusInput.style.border = "1px solid #e6eef6";
        statusInput.style.borderRadius = "6px";
        statusInput.style.flex = "1";
        const addStatusBtn = document.createElement("button");
        addStatusBtn.className = "btn btn-primary";
        addStatusBtn.textContent = "+";
        addStatusBtn.style.marginLeft = "8px";
        const statusRow = document.createElement("div");
        statusRow.style.display = "flex";
        statusRow.style.alignItems = "center";
        statusRow.appendChild(statusInput);
        statusRow.appendChild(addStatusBtn);
        const statusChips = document.createElement("div");
        statusChips.style.display = "flex";
        statusChips.style.flexWrap = "wrap";
        statusChips.style.gap = "6px";
        statusChips.style.marginTop = "8px";
        statusArea.appendChild(statusRow);
        statusArea.appendChild(statusChips);
        // append status area to middle column in the DB Explorer modal
        middle.appendChild(statusArea);

        let selectedTables = [];
        let selectedTaxItem = null;
        let taxonomyList = taxonomy || {
          concepts: {},
          events: {},
          actions: {},
        };
        let rulesList = [];
        let selectedRuleSet = null;
        let activeTab = "tables";

        tabTables.addEventListener("click", () => {
          activeTab = "tables";
          render();
        });
        tabTaxonomy.addEventListener("click", () => {
          activeTab = "taxonomy";
          render();
        });
        tabRules.addEventListener("click", async () => {
          activeTab = "rules";
          await loadRules();
          render();
        });

        async function render() {
          left.innerHTML = "";
          middle.innerHTML = "";
          right.innerHTML = "";
          tabTables.classList.toggle("active", activeTab === "tables");
          tabTaxonomy.classList.toggle("active", activeTab === "taxonomy");
          tabRules.classList.toggle("active", activeTab === "rules");
          if (activeTab === "tables") {
            // allow multi-select of tables via checkboxes
            const selectAll = document.createElement("div");
            selectAll.style.display = "flex";
            selectAll.style.justifyContent = "space-between";
            selectAll.style.alignItems = "center";
            selectAll.style.padding = "6px 8px";
            const lbl = document.createElement("div");
            lbl.textContent = "Tables";
            lbl.style.fontWeight = "700";
            const selAllBtn = document.createElement("button");
            selAllBtn.className = "btn btn-secondary";
            selAllBtn.textContent = "Clear";
            selAllBtn.addEventListener("click", () => {
              selectedTables = [];
              selectedTable = null;
              selectedColumns = [];
              render();
            });
            selectAll.appendChild(lbl);
            selectAll.appendChild(selAllBtn);
            left.appendChild(selectAll);

            // list tables with checkboxes
            tableKeys.forEach((t) => {
              const row = document.createElement("div");
              row.style.display = "flex";
              row.style.alignItems = "center";
              row.style.justifyContent = "space-between";
              row.style.padding = "6px 8px";
              row.style.cursor = "pointer";

              const leftPart = document.createElement("div");
              leftPart.style.display = "flex";
              leftPart.style.alignItems = "center";
              leftPart.style.gap = "8px";

              const chk = document.createElement("input");
              chk.type = "checkbox";
              chk.checked = selectedTables.includes(t);
              chk.addEventListener("change", (ev) => {
                ev.stopPropagation();
                if (chk.checked) {
                  if (!selectedTables.includes(t)) selectedTables.push(t);
                } else {
                  selectedTables = selectedTables.filter((x) => x !== t);
                }
                render();
              });

              const name = document.createElement("div");
              name.textContent = t;
              name.style.flex = "1";
              name.addEventListener("click", (ev) => {
                ev.stopPropagation();
                // toggle checkbox
                chk.checked = !chk.checked;
                if (chk.checked) {
                  if (!selectedTables.includes(t)) selectedTables.push(t);
                } else {
                  selectedTables = selectedTables.filter((x) => x !== t);
                }
                render();
              });

              leftPart.appendChild(chk);
              leftPart.appendChild(name);
              row.appendChild(leftPart);

              // add small column-count badge
              const colCount =
                tables[t] && (tables[t].columns || tables[t])
                  ? (tables[t].columns || tables[t]).length
                  : 0;
              const badge = document.createElement("div");
              badge.textContent = colCount ? `${colCount} cols` : "";
              badge.style.color = "#657786";
              badge.style.fontSize = "0.85rem";
              row.appendChild(badge);

              if (selectedTables.includes(t)) {
                row.style.background = "#eef6ff";
                row.style.borderRadius = "6px";
              }

              left.appendChild(row);
            });

            // right: show selected tables as pills
            const selectionBox = document.createElement("div");
            selectionBox.style.display = "flex";
            selectionBox.style.flexWrap = "wrap";
            selectionBox.style.gap = "6px";
            selectionBox.style.marginTop = "6px";
            if (!selectedTables || !selectedTables.length) {
              const none = document.createElement("div");
              none.style.color = "#657786";
              none.textContent = "No tables selected";
              selectionBox.appendChild(none);
            } else {
              selectedTables.forEach((tbl) => {
                const pill = document.createElement("div");
                pill.style.display = "inline-flex";
                pill.style.alignItems = "center";
                pill.style.gap = "6px";
                pill.style.background = "#eef6ff";
                pill.style.padding = "6px 8px";
                pill.style.borderRadius = "999px";
                pill.style.fontSize = "0.9rem";
                const name = document.createElement("div");
                name.textContent = tbl;
                const removeBtn = document.createElement("button");
                removeBtn.className = "btn btn-ghost";
                removeBtn.style.padding = "4px 6px";
                removeBtn.textContent = "‚úï";
                removeBtn.title = "Remove";
                removeBtn.addEventListener("click", (ev) => {
                  ev.stopPropagation();
                  selectedTables = selectedTables.filter((x) => x !== tbl);
                  render();
                });
                pill.appendChild(name);
                pill.appendChild(removeBtn);
                selectionBox.appendChild(pill);
              });
            }
            right.appendChild(selectionBox);

            const clearBtn = document.createElement("button");
            clearBtn.className = "btn btn-secondary";
            clearBtn.style.marginTop = "8px";
            clearBtn.textContent = "Clear Selected";
            clearBtn.addEventListener("click", () => {
              selectedTables = [];
              render();
            });
            right.appendChild(clearBtn);
          } else if (activeTab === "taxonomy") {
            taxonomyList = taxonomy || {
              concepts: {},
              events: {},
              actions: {},
            };
            const header = document.createElement("div");
            header.style.display = "flex";
            header.style.gap = "8px";
            const btnNewConcept = document.createElement("button");
            btnNewConcept.className = "btn btn-primary";
            btnNewConcept.textContent = "New Concept";
            btnNewConcept.addEventListener("click", async () => {
              await showAddConceptDialog();
              taxonomyList = taxonomy;
              render();
            });
            header.appendChild(btnNewConcept);
            left.appendChild(header);
            const concepts = Object.values(taxonomyList.concepts || {});
            concepts.forEach((c) => {
              const el = document.createElement("div");
              el.style.padding = "8px";
              el.style.cursor = "pointer";
              el.textContent = c.name;
              el.addEventListener("click", () => {
                selectedTaxItem = { type: "concept", item: c };
                render();
              });
              if (
                selectedTaxItem &&
                selectedTaxItem.item &&
                selectedTaxItem.item.id === c.id
              )
                el.style.background = "#eef2f7";
              left.appendChild(el);
            });
            if (selectedTaxItem && selectedTaxItem.type === "concept") {
              const it = selectedTaxItem.item;
              const title = document.createElement("div");
              title.style.fontWeight = "700";
              title.textContent = it.name;
              right.appendChild(title);
              const desc = document.createElement("div");
              desc.textContent = it.description || "";
              right.appendChild(desc);
              const foot = document.createElement("div");
              foot.style.marginTop = "8px";
              const btnEdit = document.createElement("button");
              btnEdit.className = "btn btn-secondary";
              btnEdit.textContent = "Edit";
              btnEdit.addEventListener("click", async () => {
                await editConcept(it.id);
                taxonomyList = taxonomy;
                render();
              });
              const btnDelete = document.createElement("button");
              btnDelete.className = "btn btn-secondary";
              btnDelete.style.marginLeft = "8px";
              btnDelete.textContent = "Delete";
              btnDelete.addEventListener("click", async () => {
                const ok = await showConfirm("Delete concept?");
                if (ok) {
                  await deleteConcept(it.id);
                  taxonomyList = taxonomy;
                  selectedTaxItem = null;
                  render();
                }
              });
              foot.appendChild(btnEdit);
              foot.appendChild(btnDelete);
              right.appendChild(foot);
            }
          } else if (activeTab === "rules") {
            // load rule sets
            try {
              const r = await fetch("/api/rules");
              const d = await r.json();
              rulesList = d.ruleSets || [];
            } catch (e) {
              rulesList = [];
            }
            const header = document.createElement("div");
            header.style.display = "flex";
            header.style.gap = "8px";
            const btnNew = document.createElement("button");
            btnNew.className = "btn btn-primary";
            btnNew.textContent = "New Rule Set";
            btnNew.addEventListener("click", async () => {
              await showAddRuleSetDialog();
              render();
            });
            header.appendChild(btnNew);
            left.appendChild(header);
            rulesList.forEach((rset) => {
              const el = document.createElement("div");
              el.style.padding = "8px";
              el.style.cursor = "pointer";
              el.textContent = rset.name;
              el.addEventListener("click", () => {
                selectedRuleSet = rset;
                render();
              });
              if (selectedRuleSet && selectedRuleSet.id === rset.id)
                el.style.background = "#eef2f7";
              left.appendChild(el);
            });
            if (selectedRuleSet) {
              const title = document.createElement("div");
              title.style.fontWeight = "700";
              title.textContent = selectedRuleSet.name;
              right.appendChild(title);
              const desc = document.createElement("div");
              desc.textContent = selectedRuleSet.description || "";
              right.appendChild(desc);
              const rules = document.createElement("pre");
              rules.textContent = JSON.stringify(
                selectedRuleSet.rules || [],
                null,
                2
              );
              rules.style.whiteSpace = "pre-wrap";
              right.appendChild(rules);
              const foot = document.createElement("div");
              foot.style.marginTop = "8px";
              const btnEdit = document.createElement("button");
              btnEdit.className = "btn btn-secondary";
              btnEdit.textContent = "Edit";
              btnEdit.addEventListener("click", async () => {
                await editRuleSet(selectedRuleSet.id);
                render();
              });
              const btnEditRules = document.createElement("button");
              btnEditRules.className = "btn btn-secondary";
              btnEditRules.style.marginLeft = "8px";
              btnEditRules.textContent = "Edit Rules";
              btnEditRules.addEventListener("click", async () => {
                await editRules(selectedRuleSet.id);
                render();
              });
              const btnDelete = document.createElement("button");
              btnDelete.className = "btn btn-secondary";
              btnDelete.style.marginLeft = "8px";
              btnDelete.textContent = "Delete";
              btnDelete.addEventListener("click", async () => {
                const ok = await showConfirm("Delete rule set?");
                if (ok) {
                  await deleteRuleSet(selectedRuleSet.id);
                  selectedRuleSet = null;
                  render();
                }
              });
              foot.appendChild(btnEdit);
              foot.appendChild(btnEditRules);
              foot.appendChild(btnDelete);
              right.appendChild(foot);
            }
          }
        }

        // initial render
        render();

        const res = await _createModal({
          title: title || "DB Explorer",
          bodyEl: root,
          onConfirm: () => {
            if (activeTab === "tables") {
              // return simple selected table names (no columns)
              if (!selectedTables || !selectedTables.length) return null;
              return { type: "tables", tables: selectedTables.slice() };
            }
            if (activeTab === "taxonomy") {
              if (!selectedTaxItem) return null;
              return { type: selectedTaxItem.type, item: selectedTaxItem.item };
            }
            if (activeTab === "rules") {
              if (!selectedRuleSet) return null;
              return { type: "rules", item: selectedRuleSet };
            }
            return null;
          },
          confirmText: "Use Selection",
          cancelText: "Close",
        });
        return res;
      }

      // --- Test Run modal & execution helpers ---
      async function showTestRunModal() {
        if (!currentWorkflow || !currentWorkflow.id) {
          showToast("No workflow selected to test", "error");
          return;
        }
        const fields = [
          {
            name: "inputs",
            label: "Sample Inputs (JSON)",
            type: "textarea",
            value: "{}",
          },
        ];
        const form = document.createElement("div");
        const ta = document.createElement("textarea");
        ta.style.width = "100%";
        ta.style.minHeight = "160px";
        ta.value = JSON.stringify(currentWorkflow.sampleInputs || {}, null, 2);
        form.appendChild(ta);

        const syncRow = document.createElement("div");
        syncRow.style.marginTop = "8px";
        const chk = document.createElement("input");
        chk.type = "checkbox";
        chk.checked = true;
        chk.id = "test-sync";
        const lbl = document.createElement("label");
        lbl.htmlFor = "test-sync";
        lbl.style.marginLeft = "8px";
        lbl.textContent = "Run synchronously (show step-by-step results)";
        syncRow.appendChild(chk);
        syncRow.appendChild(lbl);
        form.appendChild(syncRow);

        const res = await _createModal({
          title: `Test Run: ${currentWorkflow.name || currentWorkflow.id}`,
          bodyEl: form,
          onConfirm: () => {
            try {
              const iv = JSON.parse(ta.value || "{}");
              return { inputs: iv, sync: !!chk.checked };
            } catch (e) {
              showToast("Invalid JSON: " + e.message, "error");
              return null;
            }
          },
          confirmText: "Run",
          cancelText: "Cancel",
        });

        if (!res) return;
        // run the orchestration test
        runTestOrchestrationTest(
          currentWorkflow.id,
          res.inputs || {},
          !!res.sync
        ).catch((e) =>
          showToast("Test run failed: " + (e.message || e), "error")
        );
      }

      async function runTestOrchestrationTest(id, inputs, sync) {
        // show progress modal
        const outDiv = document.createElement("div");
        outDiv.style.display = "flex";
        outDiv.style.flexDirection = "column";
        outDiv.style.gap = "8px";
        const status = document.createElement("div");
        status.textContent = "Starting test...";
        outDiv.appendChild(status);
        const log = document.createElement("pre");
        log.style.whiteSpace = "pre-wrap";
        log.style.maxHeight = "360px";
        log.style.overflow = "auto";
        log.textContent = "";
        outDiv.appendChild(log);

        await _createModal({
          title: "Test Run Output",
          bodyEl: outDiv,
          confirmText: "Close",
          showCancel: false,
        });

        try {
          const payload = { id, inputs };
          if (sync) payload.sync = true;
          status.textContent = "Invoking orchestration...";
          const resp = await fetch("/orchestrate/executeById", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
          });
          if (!resp.ok) {
            const txt = await resp.text().catch(() => null);
            log.textContent += "\nInvocation failed: " + (txt || resp.status);
            status.textContent = "Failed";
            return;
          }
          const j = await resp.json();
          if (sync) {
            // synchronous result contains steps/outputs
            status.textContent = j.success ? "Completed" : "Failed";
            log.textContent += JSON.stringify(j, null, 2);
          } else {
            // async: show executionId and instructions
            const execId = j.executionId || j.executionId;
            status.textContent =
              "Queued (async) ‚Äî executionId: " + (execId || "unknown");
            log.textContent +=
              "Execution queued. Visit the Executions tab or Monitor to follow progress.\nExecutionId: " +
              (execId || "unknown") +
              "\n\nResponse:\n" +
              JSON.stringify(j, null, 2);
          }
        } catch (e) {
          status.textContent = "Error";
          log.textContent += "\nError: " + (e.message || e);
        }
      }

      // Setup drag/drop from DB Explorer into canvas nodes
      function setupDBDragDrop() {
        // Highlight droppable inputs on dragover and support dropping directly into inputs
        document.addEventListener("dragover", (e) => {
          if (!e.dataTransfer) return;
          const raw = e.dataTransfer.getData("application/json");
          if (!raw) return;
          const el = document.elementFromPoint(e.clientX, e.clientY);
          // highlight droppable inputs
          const input =
            el && (el.closest ? el.closest(".droppable-input") : null);
          document
            .querySelectorAll(".droppable-input")
            .forEach((inp) => inp.classList.remove("drag-over"));
          if (input) {
            input.classList.add("drag-over");
            e.preventDefault();
          } else {
            // allow canvas drops too
            if (e.dataTransfer.types.includes("application/json"))
              e.preventDefault();
          }
        });

        document.addEventListener("drop", (e) => {
          if (!e.dataTransfer) return;
          const raw = e.dataTransfer.getData("application/json");
          if (!raw) return;
          let payload;
          try {
            payload = JSON.parse(raw);
          } catch (err) {
            console.debug("drop: invalid payload", err);
            return;
          }
          const el = document.elementFromPoint(e.clientX, e.clientY);
          if (!el) return;
          // prefer dropping onto droppable input
          const input = el.closest && el.closest(".droppable-input");
          if (input) {
            console.debug("[DBDragDrop] dropped on input", input, payload);
            // Check if this is a connect field drop
            if (payload.connectNodeId && payload.path) {
              // Insert connect field placeholder
              const placeholder = `{{connect_${payload.connectNodeId}.${payload.path}}}`;
              globalThis.insertAtCursor(input, placeholder);
              // re-detect parameters if it's the query textarea
              if (input.id === 'action-query') {
                setTimeout(() => { try { globalThis.detectSQLParameters(); if (globalThis.renderSQLPreview) globalThis.renderSQLPreview(); } catch (e){} }, 80);
              } else {
                // also trigger preview update for description textarea
                setTimeout(() => { try { if (globalThis.renderSQLPreview) globalThis.renderSQLPreview(); } catch (e){} }, 80);
              }
              showToast('Inserted connect input placeholder', 'success');
            } else {
              // format DB payload into input value
              if (payload.table && payload.column) {
                input.value = payload.table + "." + payload.column;
              } else if (payload.table) {
                input.value = payload.table;
              }
              input.dispatchEvent(new Event("change", { bubbles: true }));
            }
            input.classList.remove("drag-over");
            e.preventDefault();
            return;
          }
          // fallback: drop on canvas node
          const nodeEl = el.closest && el.closest(".workflow-node");
          if (nodeEl) {
            const nodeId = nodeEl.getAttribute("id")?.replace(/^wfnode-/, "");
            if (nodeId) {
              console.debug("[DBDragDrop] dropped on node", nodeId, payload);
              applyDroppedDBField(nodeId, payload);
            }
          }
          e.preventDefault();
        });
      }

      function applyDroppedDBField(nodeId, payload) {
        const nd = nodes.find((n) => n.id === nodeId);
        if (!nd) return;
        nd.data.db = nd.data.db || {};
        if (payload.table) nd.data.db.table = payload.table;
        if (payload.column) {
          nd.data.db.columns = nd.data.db.columns || [];
          if (!nd.data.db.columns.includes(payload.column))
            nd.data.db.columns.push(payload.column);
        }
        // update node display
        const el = document.getElementById("wfnode-" + nodeId);
        if (el) {
          const content = el.querySelector(".workflow-node-content");
          if (content)
            content.textContent = `DB:${nd.data.db.table || ""} ${
              nd.data.db.columns ? "(" + nd.data.db.columns.join(",") + ")" : ""
            }`;
        }
        showToast("DB field applied to node", "success");
      }

      // ensure DB drag/drop setup runs on init
      document.addEventListener("DOMContentLoaded", () => {
        try {
          setupDBDragDrop();
        } catch (e) {
          console.warn("DB dragdrop init failed", e);
        }
      });

      // Inline DB explorer removed ‚Äî use modal-only `showDBExplorer()`

      // Initialize
      document.addEventListener("DOMContentLoaded", () => {
        loadTaxonomy();
        loadWorkflows();
        setupDragAndDrop();
      });

      // Bind workflow name input to currentWorkflow
      document.addEventListener("DOMContentLoaded", () => {
        try {
          const nameInput = document.getElementById("workflow-name-input");
          if (nameInput) {
            // Prefill with a generated name when empty
            if (!nameInput.value || !nameInput.value.trim()) {
              try { nameInput.value = generateWorkflowName(); } catch(e){}
            }

            nameInput.addEventListener("input", (ev) => {
              try {
                // If no workflow exists yet, create a minimal one so the name binds
                if (!currentWorkflow) {
                  currentWorkflow = {
                    id: 'wf_' + Date.now(),
                    name: ev.target.value || generateWorkflowName(),
                    description: '',
                    steps: [],
                    concept: '',
                    triggerEvent: ''
                  };
                  nodes = nodes || [];
                  connections = connections || [];
                }
                currentWorkflow.name = ev.target.value;
              } catch (e) {
                console.warn(e);
              }
            });
          }
        } catch (e) {
          console.warn(e);
        }
      });

      // Ensure `#action-id` is auto-generated and disabled if present on the page.
      (function () {
        function uuidv4Fallback() {
          return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(
            /[xy]/g,
            function (c) {
              const r = (Math.random() * 16) | 0;
              const v = c === "x" ? r : (r & 0x3) | 0x8;
              return v.toString(16);
            }
          );
        }
        function ensureActionId() {
          try {
            const el = document.getElementById("action-id");
            if (!el) return false;
            if (!el.value) {
              const gen =
                typeof crypto !== "undefined" && crypto.randomUUID
                  ? crypto.randomUUID()
                  : uuidv4Fallback();
              el.value = gen;
            }
            el.setAttribute("disabled", "disabled");
            el.title = "Auto-generated id (immutable)";
            return true;
          } catch (e) {
            return false;
          }
        }
        // Try now and also observe DOM changes (short-lived observer)
        ensureActionId();
        try {
          const mo = new MutationObserver((muts) => {
            for (const m of muts) {
              if (m.addedNodes && m.addedNodes.length) {
                if (ensureActionId()) {
                  mo.disconnect();
                  break;
                }
              }
            }
          });
          mo.observe(document.documentElement || document.body, {
            childList: true,
            subtree: true,
          });
          setTimeout(() => {
            try {
              mo.disconnect();
            } catch (e) {
              console.warn(e);
            }
          }, 10000);
        } catch (e) {
          console.warn(e);
        }
      })();

      // Inline DB explorer initialization removed; modal is used instead

      async function switchTab(tabName, ev) {
        // Update tab buttons
        const tabButtons = document.querySelectorAll('.tabs .tab');
        tabButtons.forEach((t) => t.classList.remove('active'));
        let activeTabBtn = null;
        try {
          if (ev && ev.target) {
            ev.target.classList.add('active');
            activeTabBtn = ev.target;
          } else {
            // fallback: find by tabName
            tabButtons.forEach((t) => {
              if (t.textContent.trim().toLowerCase().replace(/\s+/g, '-') === tabName) {
                t.classList.add('active');
                activeTabBtn = t;
              }
            });
          }
        } catch (e) { console.warn(e); }

        // Animate glass liquid indicator
        try {
          const tabsEl = document.querySelector('.tabs');
          let indicator = tabsEl.querySelector('.liquid-indicator');
          if (!indicator) {
            indicator = document.createElement('div');
            indicator.className = 'liquid-indicator';
            tabsEl.appendChild(indicator);
          }
          if (activeTabBtn) {
            const tabRect = activeTabBtn.getBoundingClientRect();
            const tabsRect = tabsEl.getBoundingClientRect();
            const left = tabRect.left - tabsRect.left;
            const width = tabRect.width;
            indicator.style.left = left + 'px';
            indicator.style.width = width + 'px';
          }
          // Also update the Material-style moving indicator if present
          try {
            let md = tabsEl.querySelector('.md-indicator');
            if (!md) {
              md = document.createElement('div');
              md.className = 'md-indicator';
              tabsEl.appendChild(md);
            }
            if (activeTabBtn) {
              const tRect = activeTabBtn.getBoundingClientRect();
              const tabsRect2 = tabsEl.getBoundingClientRect();
              const left2 = tRect.left - tabsRect2.left;
              md.style.transform = `translateX(${left2}px)`;
              md.style.width = tRect.width + 'px';
              md.style.opacity = '1';
            } else {
              md.style.opacity = '0';
            }
          } catch (e) { console.warn('md-indicator', e); }
        } catch (e) { console.warn('liquid-indicator', e); }
        // Ensure panel exists; lazy-load fragment if missing
        let panel = document.getElementById(tabName + "-panel");
        if (!panel) {
          try {
            const res = await fetch(`builder-tabs/${tabName}-tab.html`);
            if (res.ok) {
              const html = await res.text();
              // insert fragment at end of body
              const wrapper = document.createElement("div");
              wrapper.innerHTML = html;
              // Execute scripts found in the fragment so functions become available
              try {
                const scripts = wrapper.querySelectorAll("script");
                for (const s of Array.from(scripts)) {
                  const newScript = document.createElement("script");
                  // copy attributes
                  for (const attr of Array.from(s.attributes || [])) {
                    newScript.setAttribute(attr.name, attr.value);
                  }
                  if (s.src) {
                    // external script: append and wait for load
                    newScript.src = s.src;
                    newScript.async = false;
                    document.head.appendChild(newScript);
                    await new Promise((resolve, reject) => {
                      newScript.onload = resolve;
                      newScript.onerror = () => resolve();
                    });
                  } else {
                    // inline script: execute by textContent
                    newScript.textContent = s.textContent;
                    document.head.appendChild(newScript);
                  }
                  // remove original script node so it won't be moved as-is
                  s.parentNode && s.parentNode.removeChild(s);
                }
              } catch (e) {
                console.warn('failed executing fragment scripts', e);
              }

              // move children into body
              while (wrapper.firstChild) {
                const child = wrapper.firstChild;
                document.body.appendChild(child);
              }
              // re-query panel
              panel = document.getElementById(tabName + "-panel");
              // execute any inline init function if provided
              const initName =
                "init" +
                tabName.charAt(0).toUpperCase() +
                tabName.slice(1) +
                "Tab";
              if (
                globalThis[initName] &&
                typeof globalThis[initName] === "function"
              ) {
                try {
                  console.log("switchTab: calling init", initName);
                  await globalThis[initName]();
                } catch (e) {
                  console.warn(initName + " failed", e);
                }
              }
            }
          } catch (e) {
            console.warn("Failed to lazy-load tab", tabName, e);
          }
        }

        // Update panels display
        document.querySelectorAll(".tab-panel").forEach((p) => {
          p.classList.remove("active");
          try {
            p.style.display = "none";
          } catch (e) {
            console.warn(e);
          }
        });
        if (panel) {
          panel.classList.add("active");
          try {
            panel.style.display = "flex";
          } catch (e) {
            console.warn(e);
          }
        }

        // Load data for the tab
        switch (tabName) {
          case "taxonomy":
            loadTaxonomy();
            break;
          case "events":
            loadEvents();
            break;
          case "actions":
            console.log("switchTab: loading actions");
            try {
              if (globalThis.initActionsTab && typeof globalThis.initActionsTab === "function") {
                console.log("switchTab: calling global initActionsTab");
                await globalThis.initActionsTab();
              } else if (typeof fetchActions === 'function') {
                await fetchActions();
              }
            } catch (e) {
              console.warn("initActionsTab call failed", e);
            }
            break;
          case "rules":
            loadRules();
            break;
          case "custom-logic":
            // Custom logic tab initialization
            if (
              globalThis.initCustomLogicTab &&
              typeof globalThis.initCustomLogicTab === "function"
            ) {
              try {
                await globalThis.initCustomLogicTab();
              } catch (e) {
                console.warn("initCustomLogicTab failed", e);
              }
            }
            break;
          case "executions":
            loadExecutions();
            break;
        }
      }

      // Taxonomy Functions
      async function loadTaxonomy() {
        try {
          const res = await fetch("/api/taxonomy");
          const data = await res.json();
          if (data.ok) {
            taxonomy = data.taxonomy;
            renderTaxonomy();
            // keep taxonomy focused on concepts only (avoid injecting events/actions)
          }
        } catch (e) {
          console.error("Failed to load taxonomy:", e);
        }
      }

      // Load events for the Events panel (grouped by module)
      // Debounced trigger for search box
      function scheduleLoadEvents() {
        try {
          globalThis.__eventsSearchTimer &&
            clearTimeout(globalThis.__eventsSearchTimer);
        } catch (e) {
          console.warn(e);
        }
        globalThis.__eventsSearchTimer = setTimeout(() => {
          try {
            loadEvents();
          } catch (e) {
            console.warn(e);
          }
        }, 250);
      }

      async function loadEvents() {
        const container = document.getElementById("events-main-list");
        if (!container) return;
        container.innerHTML = '<div class="muted">Loading events...</div>';
        try {
          // try taxonomy events first
          let all = [];
          try {
            const res = await fetch("/api/taxonomy/events");
            const data = await res.json();
            if (data && data.ok && Object.keys(data.events || {}).length) {
              all = Object.values(data.events || {}).map((e) => ({
                id: e.id,
                name: e.name || e.id,
                description: e.description || "",
                target: e.target || "",
              }));
            }
          } catch (e) {
            // ignore and fallback
          }

          // fallback to discovered runtime registry when no taxonomy events
          // apply search filter (if provided)
          const searchEl = document.getElementById("events-search");
          const rawSearch = searchEl ? searchEl.value || "" : "";
          const search = String(rawSearch || "")
            .trim()
            .toLowerCase();

          if (!all.length) {
            try {
              const r = await fetch("/api/event-registry");
              if (r.ok) {
                const dr = await r.json();
                const reg = dr && dr.registry ? dr.registry : {};
                Object.keys(reg).forEach((mod) => {
                  const m = reg[mod] || {};
                  Object.keys(m.events || {}).forEach((evName) => {
                    all.push({
                      id: evName,
                      name: evName,
                      description: "(discovered)",
                      target: mod,
                    });
                  });
                });
              }
            } catch (e) {
              console.warn("fallback event-registry failed", e);
            }
          }

          if (!all.length) {
            container.innerHTML =
              '<div class="muted">No business events defined.</div>';
            return;
          }

          // filter and group by module token (before ':') or by target
          const filtered = search
            ? all.filter((it) => {
                const s = (it.name || it.id || "").toLowerCase();
                return (
                  s.includes(search) ||
                  (it.target || "").toLowerCase().includes(search)
                );
              })
            : all;

          const groups = {};
          (filtered || []).forEach((it) => {
            const name = (it && (it.id || it.name)) || "";
            let mod = "misc";
            if (typeof name === "string" && name.includes(":")) {
              mod = String(name).split(":")[0] || "misc";
            } else {
              mod =
                (it.target || "").trim() ||
                (name.split(/\s+/)[0] || "misc").trim() ||
                "misc";
            }
            groups[mod] = groups[mod] || [];
            groups[mod].push(it);
          });

          container.innerHTML = Object.keys(groups)
            .sort()
            .map((gk) => {
              const items = (groups[gk] || [])
                .map(
                  (ev) =>
                    `\n            <div class="list-item type-event" style="border-left:4px solid var(--brand-accent); margin-bottom:8px;">\n              <div style="display:flex; justify-content:space-between; align-items:center;">\n                <div>\n                  <div class="list-item-title">${ev.name}${ev.id && ev.id !== ev.name ? ` <span class="muted">${ev.id}</span>` : ""}</div>\n                </div>\n                <div style="display:flex; gap:8px;">\n                  <button class="btn btn-secondary" disabled>Read-only</button>\n                </div>\n              </div>\n            </div>\n          `
                )
                .join("");
              const gid = `group-events-${encodeURIComponent(gk)}`;
              let isCollapsed;
              if (search && String(search).trim().length) {
                // when searching, expand groups that contain results
                isCollapsed = false;
              } else {
                isCollapsed =
                  globalThis.__eventsGroupStates &&
                  globalThis.__eventsGroupStates[gid] !== undefined
                    ? globalThis.__eventsGroupStates[gid]
                    : true;
              }
              const chev = isCollapsed ? "‚ñ∏" : "‚ñæ";
              return `\n                <div id="${gid}" class="group-container event-group ${
                isCollapsed ? "collapsed" : ""
              }">\n                  <div class="group-header" onclick="toggleGroup('${gid}')">\n                    <span class="chev">${chev}</span>\n                    <span style="font-weight:700">${gk}</span>\n                    <span style="margin-left:8px; color: #657786; font-size:0.85rem">(${
                groups[gk].length
              })</span>\n                  </div>\n                  <div class="group-items">${items}</div>\n                </div>\n              `;
            })
            .join("");
          try {
            const dbg = document.getElementById("actions-debug");
            if (dbg) dbg.textContent = "Events: " + (filtered.length || 0);
          } catch (e) {
            console.warn(e);
          }

          // subscribe to SSE for live discovered events
          try {
            const es = new EventSource("/events/stream");
            es.onmessage = (ev) => {
              try {
                const d = JSON.parse(ev.data || "{}");
                if (d && d.type === "registry-update") {
                  loadEvents();
                }
              } catch (e) {
                console.warn(e);
              }
            };
            es.onerror = () => {
              es.close && es.close();
            };
          } catch (e) {
            console.warn("SSE subscribe failed", e);
          }
        } catch (e) {
          console.error("loadEvents failed", e);
          container.innerHTML = '<div class="muted">Error loading events</div>';
        }
      }

      // Load actions for Actions panel from dedicated actions metadata endpoint
      async function loadActions() {
        // Canonical actions list renderer is `fetchActions()` for this page.
        console.log("loadActions: delegating to fetchActions");
        try {
          if (typeof fetchActions === 'function') {
            await fetchActions();
          }
        } catch (e) {
          console.error('loadActions failed', e);
        }
      }

      // Enrich taxonomy using discovered events registry instead of deprecated module-mapping
      async function enrichTaxonomyWithMappings() {
        if (!taxonomy) return;
        try {
          const r = await fetch("/api/event-registry");
          if (!r.ok) return;
          const d = await r.json();
          const reg = (d && d.registry) || {};
          taxonomy.events = taxonomy.events || {};
          // add discovered events into taxonomy.events
          Object.keys(reg || {}).forEach((mod) => {
            const m = reg[mod] || {};
            Object.keys(m.events || {}).forEach((evName) => {
              if (!taxonomy.events[evName]) {
                taxonomy.events[evName] = {
                  id: evName,
                  name: evName,
                  description: "",
                  target: mod,
                };
              }
            });
          });
          renderTaxonomy();
        } catch (e) {
          // non-fatal
        }
      }

      globalThis.__eventsGroupStates = globalThis.__eventsGroupStates || {};
      globalThis.__taxonomyGroupStates = globalThis.__taxonomyGroupStates || {};

      function renderTaxonomy() {
        if (!taxonomy) return;

        // helper: group items by first word of the name
        function groupByFirstWord(list) {
          const g = {};
          (list || []).forEach((it) => {
            const name = (it && it.name) || "";
            const first = (name.split(/\s+/)[0] || "Other").trim() || "Other";
            g[first] = g[first] || [];
            g[first].push(it);
          });
          return g;
        }

        function buildGroupHtml(groups, type) {
          const cls =
            type === "concept"
              ? "concept-group"
              : type === "event"
              ? "event-group"
              : type === "action"
              ? "action-group"
              : "rules-group";

          const typeLabel =
            type === "concept"
              ? "Concepts"
              : type === "event"
              ? "Events"
              : type === "action"
              ? "Actions"
              : "Rules";

          // use global distinct random color generator
          return Object.keys(groups)
            .sort()
            .map((gk) => {
              const colors = getDistinctGroupColors(gk || "grp");
              const items = groups[gk]
                .map((it) => {
                  const id = it.id || "";
                  const title = it.name || "(unnamed)";
                  const desc = it.description || "";
                  const badge =
                    it.concept || it.target || ""
                      ? `<span class="badge">${
                          it.concept || it.target || ""
                        }</span>`
                      : "";
                  if (type === "concept") {
                    const props = (it.properties || [])
                      .map((p) => `<span class="badge">${p}</span>`)
                      .join(" ");
                    return `
                      <div class="list-item type-concept" style="border-left:4px solid ${colors.accent};">
                        <div style="display:flex; justify-content:space-between; align-items:center;">
                          <div>
                            <div class="list-item-title">${title}</div>
                            <div class="list-item-desc">${desc}</div>
                            ${props}
                          </div>
                          <div style="display:flex; gap:8px;">
                            <button class="btn btn-secondary" onclick="editConcept('${id}')">Edit</button>
                            <button class="btn btn-secondary" onclick="showManageStates('${id}')">States</button>
                            <button class="btn btn-secondary" onclick="showManageLinks('${id}')">Links</button>
                            <button class="btn btn-danger" onclick="deleteConcept('${id}')">Delete</button>
                          </div>
                        </div>
                      </div>`;
                  }
                  if (type === "event") {
                    return `
                      <div class="list-item type-event" style="border-left:4px solid ${colors.accent};">
                        <div style="display:flex; justify-content:space-between; align-items:center;">
                          <div>
                            <div class="list-item-title">${title}</div>
                          </div>
                          <div style="display:flex; gap:8px;">
                            <button class="btn btn-secondary" onclick="editEvent('${id}')">Edit</button>
                            <button class="btn btn-danger" onclick="deleteEvent('${id}')">Delete</button>
                          </div>
                        </div>
                      </div>`;
                  }
                  // action
                  return `
                    <div class="list-item type-action" style="border-left:4px solid ${colors.accent};">
                      <div style="display:flex; justify-content:space-between; align-items:center;">
                        <div>
                          <div class="list-item-title">${title}</div>
                          <div class="list-item-desc">${desc} ${badge}</div>
                        </div>
                        <div style="display:flex; gap:8px;">
                          <button class="btn btn-secondary" onclick="editAction('${id}')">Edit</button>
                          <button class="btn btn-danger" onclick="deleteAction('${id}')">Delete</button>
                        </div>
                      </div>
                    </div>`;
                })
                .join("");

              const gid = `group-${type}-${encodeURIComponent(gk)}`;
              const isCollapsed =
                globalThis.__taxonomyGroupStates &&
                globalThis.__taxonomyGroupStates[gid] !== undefined
                  ? globalThis.__taxonomyGroupStates[gid]
                  : true;
              const chev = isCollapsed ? "‚ñ∏" : "‚ñæ";
              return `
                <div id="${gid}" class="group-container ${cls} ${
                isCollapsed ? "collapsed" : ""
              }">
                  <div class="group-header" style="background: linear-gradient(90deg, ${
                    colors.left
                  }, ${colors.right}); border-bottom:1px solid ${
                colors.border
              };" onclick="toggleGroup('${gid}')">
                    <span class="chev">${chev}</span>
                    <span style="font-weight:700">${typeLabel}: ${gk}</span>
                    <span style="margin-left:8px; color: #657786; font-size:0.85rem">(${
                      groups[gk].length
                    })</span>
                  </div>
                  <div class="group-items">${items}</div>
                </div>
              `;
            })
            .join("");
        }

        // Render concepts grouped by first word
        const concepts = Object.values(taxonomy.concepts || {});
        const conceptGroups = groupByFirstWord(concepts);
        document.getElementById("concepts-list").innerHTML = buildGroupHtml(
          conceptGroups,
          "concept"
        );

        // Ensure taxonomy shows concepts by default
        try {
          const prev = globalThis.__lastTaxonomyTab || "concepts";
          switchTaxonomyTab(prev);
        } catch (e) {
          console.warn(e);
        }
      }

      // Toggle collapsed state for a taxonomy group
      function toggleGroup(id) {
        try {
          const el = document.getElementById(id);
          if (!el) return;
          el.classList.toggle("collapsed");
          const chev = el.querySelector(".chev");
          if (chev)
            chev.textContent = el.classList.contains("collapsed") ? "‚ñ∏" : "‚ñæ";
          // persist state so subsequent renderTaxonomy calls preserve expansion
          try {
            // use separate state bucket for taxonomy vs events groups
            if (String(id).startsWith("group-events-")) {
              globalThis.__eventsGroupStates =
                globalThis.__eventsGroupStates || {};
              globalThis.__eventsGroupStates[id] =
                el.classList.contains("collapsed");
            } else {
              globalThis.__taxonomyGroupStates =
                globalThis.__taxonomyGroupStates || {};
              globalThis.__taxonomyGroupStates[id] =
                el.classList.contains("collapsed");
            }
          } catch (e) {
            console.warn(e);
          }
        } catch (e) {
          console.warn("toggleGroup failed", e && e.message ? e.message : e);
        }
      }

      // Taxonomy tab switcher (internal to Taxonomy panel)
      function switchTaxonomyTab(name) {
        try {
          // taxonomy now only supports concepts
          globalThis.__lastTaxonomyTab = "concepts";
          document.getElementById("tax-concepts").style.display = "";
          const btn = document.getElementById("taxTabConcepts");
          if (btn) btn.classList.add("tab-selected");
        } catch (e) {
          console.warn("switchTaxonomyTab err", e);
        }
      }

      // Workflow Functions
      async function loadWorkflows() {
        try {
          const res = await fetch("/api/workflows");
          const data = await res.json();
          if (data.ok) {
            workflows = data.workflows;
            const selector = document.getElementById("workflow-selector");
            selector.innerHTML =
              '<option value="">Select Workflow...</option>' +
              workflows
                .map((w) => `<option value="${w.id}">${w.name}</option>`)
                .join("");
            // restore previously selected workflow from localStorage
            try {
              const saved = localStorage.getItem('activeWorkflowId');
              if (saved) {
                const exists = workflows.find(w => w.id === saved);
                if (exists) {
                  selector.value = saved;
                  // small timeout to ensure DOM has updated the selector
                  setTimeout(() => {
                    try { loadWorkflowById(saved); } catch (e) { console.warn('restore workflow failed', e); }
                  }, 20);
                }
              }
            } catch (e) { console.warn('restore active workflow from storage failed', e); }
          }
        } catch (e) {
          console.error("Failed to load workflows:", e);
        }
      }

      function newWorkflow() {
        currentWorkflow = {
          id: "wf_" + Date.now(),
          name: generateWorkflowName(),
          description: "",
          steps: [],
          concept: "",
          triggerEvent: "",
        };
        nodes = [];
        connections = [];
        nextNodeId = 1;
        renderCanvas();
        try {
          const el = document.getElementById('workflow-name-input');
          if (el) el.value = currentWorkflow.name || '';
        } catch (e) { console.warn(e); }
      }

      // Generate an easy, semantic workflow name when creating new workflows
      function generateWorkflowName() {
        try {
          const short = Math.random().toString(36).slice(2,6).toUpperCase();

          const list = nodes || [];
          const cap = (s) => String(s || '').replace(/[_\-]/g, ' ').replace(/\b\w/g, (m) => m.toUpperCase()).trim();

          const connectorNode = list.find(n => n && (/connect/i.test(n.type) || (n.data && (n.data.connector || n.data.connectorName))));
          const connectorName = connectorNode && (connectorNode.data && (connectorNode.data.connectorName || connectorNode.data.connector)) || connectorNode && (connectorNode.name || connectorNode.label) || null;

          const actionNode = list.find(n => n && (/action|db|insert|upsert|write/i.test(n.type) || (n.data && n.data.db)));
          const tableName = actionNode && ((actionNode.data && (actionNode.data.db && (actionNode.data.db.table || actionNode.data.db.tableName))) || actionNode.data && (actionNode.data.table || actionNode.data.target) || actionNode.name) || null;

          let candidate = '';
          if (connectorName && tableName) {
            candidate = `Sync ${cap(connectorName)} ‚Üí ${cap(tableName)} - ${short}`;
          } else if (connectorName) {
            candidate = `Sync ${cap(connectorName)} - ${short}`;
          } else if (tableName) {
            candidate = `Write ${cap(tableName)} - ${short}`;
          } else if (list.length > 0) {
            const counts = {};
            list.forEach(n => { if (n && n.type) counts[n.type] = (counts[n.type]||0)+1; });
            const top = Object.entries(counts).sort((a,b)=>b[1]-a[1])[0];
            if (top) candidate = `${cap(top[0])} Flow - ${short}`;
          }

          if (!candidate) candidate = `Workflow-${short}`;

          // Normalize spacing: collapse multiple spaces, trim ends, and remove spaces around separators
          candidate = String(candidate || '')
            .replace(/\s+/g, ' ')
            .replace(/\s*‚Üí\s*/g, '‚Üí')
            .replace(/\s*-\s*/g, '-')
            .trim();

          return candidate;
        } catch (e) {
          return 'Workflow-' + Date.now();
        }
      }

      async function loadWorkflowById(workflowId) {
        if (!workflowId) return;
        try { localStorage.setItem('activeWorkflowId', String(workflowId)); } catch (e) { /* ignore storage errors */ }
        const workflow = workflows.find((w) => w.id === workflowId);
        if (workflow) {
          currentWorkflow = workflow;
          // Convert steps to nodes for visual editor
          nodes = (workflow.steps || []).map((step, idx) => ({
            id: step.id,
            type: step.type,
            name: step.name,
            data: step,
            x: typeof step.x === "number" ? step.x : 100 + idx * 250,
            y: typeof step.y === "number" ? step.y : 100,
          }));
          // load saved connections if present. Do not clobber in-memory
          // connections if we're re-loading the same workflow and there
          // are already connections created in the editor (protects
          // transient auto-connect created by the client).
          if (
            currentWorkflow &&
            currentWorkflow.id === workflow.id &&
            connections &&
            connections.length > 0
          ) {
            // keep existing in-memory connections
          } else {
            connections = Array.isArray(workflow.connections)
              ? workflow.connections.slice()
              : [];
          }
          renderCanvas();
          try {
            const el = document.getElementById('workflow-name-input');
            if (el) el.value = currentWorkflow.name || '';
          } catch (e) { console.warn(e); }

          // After loading, nudge nodes to reduce overlap (non-destructive).
          try {
            nodes.forEach((n) => setTimeout(() => nudgeNode(n.id), 0));
          } catch (e) {
            console.warn(
              "post-load nudge failed",
              e && e.message ? e.message : e
            );
          }
          // Refresh dependent panels so they reflect the newly selected workflow
          try {
            try { setActionsEditState(); } catch (e) { /* ignore */ }

            // Refresh Actions panel (scoped to currentWorkflow inside loadActions)
            if (typeof loadActions === 'function') {
              try { loadActions(); } catch (e) { /* ignore */ }
            }
            if (globalThis.initActionsTab && typeof globalThis.initActionsTab === 'function') {
              try { globalThis.initActionsTab(); } catch (e) { /* ignore */ }
            }

            // Inform Custom Logic tab about the active workflow (if selector exists)
            try {
              const logicSelector = document.getElementById('logic-workflow-selector');
              if (logicSelector && currentWorkflow && currentWorkflow.id) {
                logicSelector.value = currentWorkflow.id;
                if (typeof loadWorkflowLogics === 'function') {
                  try { loadWorkflowLogics(currentWorkflow.id); } catch (e) { /* ignore */ }
                }
              } else if (globalThis.initCustomLogicTab && typeof globalThis.initCustomLogicTab === 'function') {
                try {
                  await globalThis.initCustomLogicTab();
                  // after init, try to set selector and load logics for the active workflow
                  const sel = document.getElementById('logic-workflow-selector');
                  if (sel && currentWorkflow && currentWorkflow.id) {
                    sel.value = currentWorkflow.id;
                    if (typeof loadWorkflowLogics === 'function') {
                      try { loadWorkflowLogics(currentWorkflow.id); } catch (e) { /* ignore */ }
                    }
                  }
                } catch (e) { /* ignore */ }
              }
            } catch (e) { /* ignore */ }
          } catch (e) {
            console.warn('refresh dependent panels failed', e);
          }
        }
      }

      async function saveCurrentWorkflow() {
        if (!currentWorkflow) {
          // Create a minimal workflow using the workflow name input or generated name
          try {
            const el = document.getElementById('workflow-name-input');
            const nameVal = el && el.value && String(el.value).trim() ? el.value.trim() : generateWorkflowName();
            currentWorkflow = {
              id: 'wf_' + Date.now(),
              name: nameVal,
              description: '',
              steps: [],
              concept: '',
              triggerEvent: ''
            };
            // ensure nodes/connections arrays exist so save logic runs
            nodes = nodes || [];
            connections = connections || [];
          } catch (e) {
            showToast("No workflow to save", "error");
            return;
          }
        }

        // Convert nodes back to steps
        // attach outgoing lists and next pointer (next kept for compatibility)
        for (const n of nodes) {
          const outs = connections
            .filter((c) => c.from === n.id)
            .map((c) => c.to);
          n.data.outgoing = outs; // preserve full branching for editor/runtime round-trip
          n.data.next = outs.length ? outs[0] : null; // backward-compatible single next
        }
        // normalize any JSON mappings entered as strings in node.data
        nodes.forEach((node) => {
          if (node.data && typeof node.data.inputMapping === 'string') {
            try { node.data.inputMapping = JSON.parse(node.data.inputMapping); } catch (e) { /* keep string if parse fails */ }
          }
          if (node.data && typeof node.data.outputMapping === 'string') {
            try { node.data.outputMapping = JSON.parse(node.data.outputMapping); } catch (e) { /* keep string if parse fails */ }
          }
        });
        currentWorkflow.steps = nodes.map((node) => node.data);

        // Enrich connect node previews before persisting to server so samples are available
        try {
          await Promise.all((nodes || []).filter(n => n.type === 'connect').map(async (nd) => {
            try {
              // if mappingPreview exists and contains nulls, attempt enrichment
              const mp = nd.data && nd.data.mappingPreview ? nd.data.mappingPreview : null;
              const hasNulls = mp && Object.keys(mp).some(k => mp[k] === null || mp[k] === undefined);
              if (!mp || !hasNulls) return;

              // try variableMappings examples first
              if (nd.data && nd.data.variableMappings && Array.isArray(nd.data.variableMappings._exampleOutputs) && nd.data.variableMappings._exampleOutputs.length) {
                const ex = nd.data.variableMappings._exampleOutputs[0] || {};
                Object.keys(mp).forEach(k => {
                  if ((mp[k] === null || mp[k] === undefined) && Object.prototype.hasOwnProperty.call(ex, k)) mp[k] = ex[k];
                });
              }

              // Next, attempt upstream resolution: find connections pointing into this connect node
              const ups = connections.filter(c => String(c.to) === String(nd.id));
              for (const up of ups) {
                try {
                  const fromNode = nodes.find(n => String(n.id) === String(up.from));
                  if (!fromNode) continue;
                  let sample = null;
                  if (fromNode.type === 'action') {
                    try {
                      const r = await fetch('/api/actions');
                      if (r.ok) {
                        const all = await r.json();
                        const actions = all && all.actions ? all.actions : {};
                        const act = Object.values(actions).find(a => (a.id && String(a.id) === String(fromNode.data.action)) || (a.name && a.name === fromNode.data.action));
                        if (act) {
                          const vm = act.variableMappings || {};
                          const examples = vm._exampleOutputs || vm.exampleOutputs || vm.examples || null;
                          if (examples && Array.isArray(examples) && examples.length) sample = examples[0];
                        }
                      }
                    } catch (e) { /* ignore */ }
                    if (!sample && fromNode.data && fromNode.data.variableMappings && Array.isArray(fromNode.data.variableMappings._exampleOutputs) && fromNode.data.variableMappings._exampleOutputs.length) sample = fromNode.data.variableMappings._exampleOutputs[0];
                  } else if (fromNode.type === 'event') {
                    try {
                      const module = fromNode.data.module || (fromNode.data.event && String(fromNode.data.event).split(':')[0]) || '';
                      const resp = await fetch(`/api/event-records?module=${encodeURIComponent(module)}&event=${encodeURIComponent(fromNode.data.event)}`);
                      if (resp.ok) {
                        const j = await resp.json();
                        const rec = j && j.records && j.records[0] ? j.records[0] : null;
                        if (rec) {
                          let payload = rec.payload || rec.data || rec;
                          if (typeof payload === 'string') {
                            try { payload = JSON.parse(payload); } catch (e) {}
                          }
                          sample = payload;
                        }
                      }
                    } catch (e) { /* ignore */ }
                  } else if (fromNode.type === 'connect') {
                    if (fromNode.data && fromNode.data.mappingPreview) sample = fromNode.data.mappingPreview;
                    else if (fromNode.data && fromNode.data.examplePayload) sample = fromNode.data.examplePayload;
                  }

                  if (sample && typeof sample === 'object') {
                    Object.keys(mp).forEach(k => {
                      if ((mp[k] === null || mp[k] === undefined)) {
                        try {
                          let val = undefined;
                          try {
                            const path = (mp && typeof mp[k] === 'string') ? mp[k] : k;
                            val = safeGetGlobal(sample, path);
                          } catch (e) { /* ignore */ }

                          // If direct path resolution failed, deep-search the payload for the key name
                          if (val === undefined) {
                            try { val = deepFindKey(sample, k); } catch (e) { /* ignore */ }
                          }

                          if (val !== undefined) mp[k] = val === undefined ? null : val;
                        } catch (e) { /* ignore */ }
                      }
                    });
                  }
                } catch (e) { /* continue */ }
              }

              // persist back into variableMappings._exampleOutputs for downstream consumers
              try {
                nd.data.variableMappings = nd.data.variableMappings || {};
                nd.data.variableMappings._exampleOutputs = nd.data.variableMappings._exampleOutputs || [];
                nd.data.variableMappings._exampleOutputs[0] = Object.assign({}, nd.data.variableMappings._exampleOutputs[0] || {}, mp || {});
              } catch (e) { /* ignore */ }
            } catch (e) { /* ignore per-node errors */ }
          }));
        } catch (e) { console.warn('enriching connect previews failed', e); }
        // persist connections for richer editor roundtrip
        currentWorkflow.connections = connections;

        try {
          const method = workflows.find((w) => w.id === currentWorkflow.id)
            ? "PUT"
            : "POST";
          const url =
            method === "PUT"
              ? `/api/workflows/${currentWorkflow.id}`
              : "/api/workflows";
          const res = await fetch(url, {
            method,
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(currentWorkflow),
          });
          const data = await res.json();
          if (data.ok) {
            showToast("Workflow saved successfully", "success");
            await loadWorkflows();
          } else {
            showToast("Failed to save workflow: " + data.error, "error");
          }
        } catch (e) {
          showToast("Error saving workflow: " + e.message, "error");
        }
      }

      // Drag and Drop
      function setupDragAndDrop() {
        const canvas = document.getElementById("workflow-nodes");

        // Handle drag start from sidebar
        document.querySelectorAll(".node-type").forEach((nodeType) => {
          nodeType.addEventListener("dragstart", (e) => {
            e.dataTransfer.setData(
              "nodeType",
              e.currentTarget.dataset.nodeType
            );
          });
        });

        // Handle drop on canvas
        canvas.addEventListener("dragover", (e) => {
          e.preventDefault();
        });

        canvas.addEventListener("drop", (e) => {
          e.preventDefault();
          // support event payloads dropped from Event Registry
          const eventPayload = e.dataTransfer.getData("eventPayload");
          if (eventPayload) {
            try {
              const p = JSON.parse(eventPayload);
              addNode("event", e.offsetX, e.offsetY, p);
              return;
            } catch (err) {
              /* fallthrough */
            }
          }
          const nodeType = e.dataTransfer.getData("nodeType");
          if (nodeType) {
            addNode(nodeType, e.offsetX, e.offsetY);
          }
        });
      }

      function addNode(type, x, y, payload) {
        const nodeId = "node_" + nextNodeId++;
        const node = {
          id: nodeId,
          type,
          name:
            payload && payload.event
              ? payload.event
              : type.charAt(0).toUpperCase() + type.slice(1) + " " + nextNodeId,
          data: Object.assign(
            {
              id: nodeId,
              type,
              name:
                payload && payload.event
                  ? payload.event
                  : type.charAt(0).toUpperCase() +
                    type.slice(1) +
                    " " +
                    nextNodeId,
              next: null,
            },
            (payload && { event: payload.event, module: payload.module }) || {}
          ),
          x,
          y,
        };
        nodes.push(node);
        console.debug(
          "addNode:",
          node.id,
          "type=",
          type,
          "pos=",
          node.x,
          node.y,
          "nodesCount=",
          nodes.length
        );
        // connections are user-driven; do not auto-create links here.
        renderCanvas();
        // gently nudge new node if it overlaps others (minimal and non-invasive)
        setTimeout(() => nudgeNode(node.id), 0);
        // If payload contains connector or example mapping information, apply it
        try {
          if (payload && type === 'connect') {
            const nd = nodes.find(n => n.id === nodeId);
            if (payload.connectorName) nd.data.connectorName = payload.connectorName;
            if (payload.mappingPreview) nd.data.mappingPreview = payload.mappingPreview;
            else if (payload.examplePayload) nd.data.mappingPreview = payload.examplePayload;
            else if (payload.mapping) nd.data.mapping = payload.mapping;
            // reflect immediately in UI
            renderCanvas();
          }
        } catch (e) { console.warn('apply connector payload failed', e); }
      }

      function renderCanvas() {
        const container = document.getElementById("workflow-nodes");
        container.innerHTML = "";
        console.debug(
          "renderCanvas: nodes=",
          nodes.length,
          "connections=",
          connections.length
        );

        nodes.forEach((node) => {
          const el = document.createElement("div");
          el.className = "workflow-node";
          el.id = "wfnode-" + node.id;
          el.style.left = node.x + "px";
          el.style.top = node.y + "px";
          el.innerHTML = `
                    <div class="workflow-node-header">
                        <div class="workflow-node-title">${node.name}</div>
                        <div class="workflow-node-type">${node.type}</div>
                    </div>
                    <div class="workflow-node-content">
                        ${
                          node.type === 'connect'
                            ? (node.data && node.data.mapping
                                ? 'Mapping: ' + Object.keys(node.data.mapping).join(', ')
                                : 'Connect (no mapping)')
                            : (node.data.event || node.data.action || node.data.ruleSet || 'Configure node...')
                        }
                    </div>
                    <div class="connection-point input" data-node-id="${
                      node.id
                    }" data-type="input"></div>
                    <div class="connection-point output" data-node-id="${
                      node.id
                    }" data-type="output"></div>
                `;
          el.addEventListener("click", () => selectNode(node));
          // wire connection point handlers
          const out = el.querySelector(".connection-point.output");
          const inp = el.querySelector(".connection-point.input");
          if (out) {
            out.dataset.nodeId = node.id;
            out.addEventListener("mousedown", (e) => {
              e.preventDefault();
              e.stopPropagation();
              console.debug(
                "connection mousedown on output",
                node.id,
                "target=",
                e.target.className
              );
              startConnection(node.id);
            });
          }
          if (inp) {
            inp.dataset.nodeId = node.id;
          }
          makeDraggable(el, node);
          container.appendChild(el);
        });

        renderConnections();
      }

      // Auto-connect feature removed. Connections are explicitly created by the user
      // via drag connections or by saved workflow bindings. The previous
      // attemptAutoConnect implementation was intentionally removed to avoid
      // unexpected automatic linking.

      // Ensure minimum spacing between workflow nodes to avoid overlap
      function ensureMinSpacing(el, node) {
        const MIN_GAP = 16; // px gap between boxes
        const canvas = document.getElementById("workflow-canvas");
        if (!canvas || !el) return;
        const canvasRect = canvas.getBoundingClientRect();

        // update el rect truth before checking
        let elRect = el.getBoundingClientRect();

        // iterate and push away from any node that is too close
        const others = Array.from(document.querySelectorAll(".workflow-node"));
        let adjusted = false;
        for (const other of others) {
          if (other === el) continue;
          const r = other.getBoundingClientRect();

          // check if rectangles are within MIN_GAP of each other
          if (
            elRect.left < r.right + MIN_GAP &&
            elRect.right > r.left - MIN_GAP &&
            elRect.top < r.bottom + MIN_GAP &&
            elRect.bottom > r.top - MIN_GAP
          ) {
            // compute centers
            const cx = elRect.left + elRect.width / 2;
            const cy = elRect.top + elRect.height / 2;
            const ox = r.left + r.width / 2;
            const oy = r.top + r.height / 2;
            let dx = cx - ox || 1; // avoid zero vector
            let dy = cy - oy || 0;
            const len = Math.hypot(dx, dy) || 1;
            dx /= len;
            dy /= len;

            // required center distance: use average of sizes + gap
            const req =
              Math.max(elRect.width, elRect.height, r.width, r.height) +
              MIN_GAP;
            const newCx = ox + dx * req;
            const newCy = oy + dy * req;

            // convert new center to node.x/node.y (relative to canvas)
            const newX = newCx - canvasRect.left - elRect.width / 2;
            const newY = newCy - canvasRect.top - elRect.height / 2;

            node.x = Math.round(newX);
            node.y = Math.round(newY);
            el.style.left = node.x + "px";
            el.style.top = node.y + "px";

            // update elRect for subsequent checks
            elRect = el.getBoundingClientRect();
            adjusted = true;
          }
        }
        return adjusted;
      }

      // Nudge a newly added node to a free space (called after renderCanvas)
      function nudgeNode(nodeId) {
        const el = document.getElementById("wfnode-" + nodeId);
        if (!el) return;
        const node = nodes.find((n) => n.id === nodeId);
        if (!node) return;
        // try a few passes to resolve collisions
        for (let i = 0; i < 6; i++) {
          const moved = ensureMinSpacing(el, node);
          if (!moved) break;
        }
        // persist final coords
        node.data.x = node.x;
        node.data.y = node.y;
        renderConnections();
      }

      function makeDraggable(el, node) {
        let isDragging = false;
        let startX, startY;

        el.addEventListener("mousedown", (e) => {
          if (e.target.classList.contains("connection-point")) return;
          isDragging = true;
          startX = e.clientX - node.x;
          startY = e.clientY - node.y;
          el.style.cursor = "grabbing";
        });

        document.addEventListener("mousemove", (e) => {
          if (!isDragging) return;
          node.x = e.clientX - startX;
          node.y = e.clientY - startY;
          // enforce minimum spacing while dragging (non-invasive)
          try {
            ensureMinSpacing(el, node);
          } catch (err) {
            // defensive: do not break drag on errors
            console.warn("ensureMinSpacing failed", err);
          }
          // persist visual coords on node data for save/load
          node.data.x = node.x;
          node.data.y = node.y;
          el.style.left = node.x + "px";
          el.style.top = node.y + "px";
          renderConnections();
        });

        document.addEventListener("mouseup", () => {
          if (isDragging) {
            // persist final coords
            node.data.x = node.x;
            node.data.y = node.y;
          }
          isDragging = false;
          el.style.cursor = "move";
        });
      }

      function selectNode(node) {
        selectedNode = node;
        document
          .querySelectorAll(".workflow-node")
          .forEach((n) => n.classList.remove("selected"));
        document.getElementById("wfnode-" + node.id)?.classList.add("selected");
        showNodeProperties(node);
      }

      function showNodeProperties(node) {
        const panel = document.getElementById("properties-panel");
        panel.innerHTML = `
                <h3>Node Properties</h3>
                <div class="form-group">
                    <label class="form-label">Node Name</label>
                    <input type="text" class="form-input" value="${
                      node.name
                    }" onchange="updateNodeProperty('name', this.value)">
                </div>
                <div class="form-group">
                    <label class="form-label">Type</label>
                    <input type="text" class="form-input" value="${
                      node.type
                    }" disabled>
                </div>
                ${
                  node.type === "event"
                    ? `
                    <div class="form-group">
                        <label class="form-label">Event</label>
                        <div style="display:flex;flex-direction:column;gap:8px;align-items:flex-start;">
                          <div id="node-event-pill-${node.id}" title="${node.data.event || 'No event selected'}" style="width:100%;padding:12px 16px;border-radius:999px;background:linear-gradient(90deg,#f7fafc,#f0f3f5);color:#0f1724;font-weight:600;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;box-shadow:0 1px 0 rgba(16,24,40,0.03);">${node.data.event || "No event selected"}</div>
                          <button class="btn btn-primary" onclick="chooseEventForNode('${node.id}')" style="padding:6px 12px;border-radius:999px;font-size:0.9rem;">Choose Event</button>
                        </div>
                        <div style="margin-top:6px;color:#657786;font-size:0.85rem">Tip: open the chooser and pick an event to bind.</div>
                    </div>
                `
                    : ""
                }
                ${
                  node.type === "action"
                    ? `
                    <div class="form-group">
                        <label class="form-label">Action</label>
                        <select id="node-action-${node.id}" class="form-select" onchange="updateNodeData('action', this.value)">
                                  <option value="">Loading actions...</option>
                        </select>
                                
                    </div>
                    
                    ${
                      node.data && node.data.variableMappings && node.data.variableMappings.inputMapping
                        ? `<div class="form-group"><label class="form-label">Input Mapping (from connector)</label><div style="background:#f8f9fa;padding:8px;border-radius:6px;border:1px solid #e1e8ed;font-size:0.85rem;color:#223">${Object.keys(node.data.variableMappings.inputMapping).map(k => `${k}: ${node.data.variableMappings.inputMapping[k]}`).join('<br>')}</div></div>`
                        : ''
                    }
                `
                    : ""
                }
                ${
                  node.type === "decision"
                    ? `
                    <div class="form-group">
                        <label class="form-label">Rule Set</label>
                        <select class="form-select" onchange="updateNodeData('ruleSet', this.value)">
                            <option value="">Select rule set...</option>
                        </select>
                    </div>
                `
                    : ""
                }
                ${
                  node.type === 'connect'
                    ? `
                    <div class="form-group">
                        <label class="form-label">Input Mapping</label>
                        <div style="display:flex;gap:8px;align-items:center;">
                          <div id="node-mapping-summary-${node.id}" style="flex:1;color:#657786">${
                            node.data && node.data.mapping
                              ? Object.keys(node.data.mapping).join(', ')
                              : 'No mapping defined'
                          }</div>
                          <button class="btn btn-secondary" onclick="openConnectMapper('${node.id}')">Map Input</button>
                        </div>
                        
                        <div id="node-mapping-details-${node.id}" style="margin-top:8px;font-size:0.9rem;color:#445">${
                          node.data && node.data.mapping
                            ? Object.entries(node.data.mapping)
                                .map(([k, p]) => `${k}: ${p}`)
                                .join('<br>')
                            : ''
                        }</div>
                        <div style="margin-top:8px;color:#657786;font-size:0.8rem">Multiple outputs allowed ‚Äî connect this node to any number of downstream nodes.</div>
                    </div>
                `
                    : ''
                }
                ${
                  node.type === "human-task"
                    ? `
                    <div class="form-group">
                        <label class="form-label">Task Type</label>
                        <select class="form-select" onchange="updateNodeData('taskType', this.value)">
                            <option value="approval" ${
                              node.data.taskType === "approval" ? "selected" : ""
                            }>Approval</option>
                            <option value="review" ${
                              node.data.taskType === "review" ? "selected" : ""
                            }>Review</option>
                            <option value="data-entry" ${
                              node.data.taskType === "data-entry" ? "selected" : ""
                            }>Data Entry</option>
                        </select>
                    </div>
                `
                    : ""
                }
                ${node.type !== 'action' && node.type !== 'connect' && node.type !== 'event' ? `
                <div class="form-group">
                    <label class="form-label">DB Target</label>
                    <div style="display:flex;gap:8px;align-items:center;">
                      <input type="text" id="node-db-target-${
                        node.id
                      }" class="form-input" value="${
          node.data.db
            ? node.data.db.table +
              (node.data.db.columns ? "." + node.data.db.columns.join(",") : "")
            : ""
        }" onchange="updateNodeDB('${node.id}', this.value)">
                      <button class="btn btn-secondary" onclick="chooseDBForNode('${
                        node.id
                      }')">Choose from DB</button>
                    </div>
                </div>
                ` : ''}
                <div style="display:flex;gap:8px;margin-top:12px;">
                  <button class="btn btn-primary" style="flex:1;padding:8px 12px;border-radius:8px;font-weight:600;" onclick="saveCurrentWorkflow()">Save Workflow</button>
                  <button class="btn btn-danger" style="flex:1;padding:8px 12px;border-radius:8px;font-weight:600;" onclick="deleteSelectedNode()">Delete Node</button>
                </div>
            `;

        

        // Populate actions dropdown for action nodes (source: /api/actions only)
        if (node.type === 'action') {
          (async () => {
            try {
              const sel = document.getElementById(`node-action-${node.id}`);
              if (!sel) return;
              const r = await fetch('/api/actions');
              const d = await r.json();
              const actions = Object.values(d.actions || {}).sort((a, b) => (a.name || a.id).localeCompare(b.name || b.id));
              sel.innerHTML = '<option value="">Select action...</option>';
              actions.forEach((a) => {
                const opt = document.createElement('option');
                // Use the action name as the option value so node.data.action stores the friendly name
                opt.value = a.name || a.id;
                opt.textContent = a.name || a.id;
                // Support node.data.action being either an action id or a human-friendly name
                if (node.data && node.data.action && (node.data.action === a.id || node.data.action === a.name)) opt.selected = true;
                sel.appendChild(opt);
              });
            } catch (e) {
              console.warn('populate actions failed', e);
            }
          })();
        }

        // For connect nodes, attempt to auto-populate mappingPreview from a known connector if none exists
        if (node.type === 'connect') {
          (async () => {
            try {
              const nd = nodes.find(n => n.id === node.id);
              const hasMapping = nd && (nd.data && (nd.data.mapping || nd.data.mappingPreview));
              const connectorName = nd && nd.data && (nd.data.connectorName || nd.data.connector);
              if (!hasMapping && connectorName) {
                // Try a few conventional endpoints to fetch a sample/schema
                const attempts = [
                  `/api/connectors/${encodeURIComponent(connectorName)}/sample`,
                  `/api/connectors/${encodeURIComponent(connectorName)}/schema`,
                  `/api/connector/${encodeURIComponent(connectorName)}/sample`,
                  `/api/connector/${encodeURIComponent(connectorName)}`,
                ];
                for (const url of attempts) {
                  try {
                    const r = await fetch(url, { cache: 'no-store' });
                    if (!r.ok) continue;
                    const j = await r.json().catch(() => null);
                    if (!j) continue;
                    // Accept a direct object or { sample: ... } wrappers
                    const sample = j.sample || j.examplePayload || j.mappingPreview || j || null;
                    if (sample && typeof sample === 'object') {
                      nd.data.mappingPreview = sample;
                      renderCanvas();
                      if (selectedNode && selectedNode.id === nd.id) showNodeProperties(nd);
                      showToast('Loaded connector sample for mapping', 'success');
                      break;
                    }
                  } catch (e) { /* try next */ }
                }
              }
            } catch (e) { console.warn('auto-load connector sample failed', e); }
          })();
        }

        
      }

      async function chooseDBForNode(nodeId) {
        const sel = await showDBExplorer("Choose table/columns for node");
        if (!sel) return;
        const nd = nodes.find((n) => n.id === nodeId);
        if (!nd) return;
        nd.data.db = nd.data.db || {};
        if (sel.type === "table" || sel.type === undefined) {
          nd.data.db.table = sel.table;
          nd.data.db.columns = sel.columns || [];
        } else if (sel.type === "tables" && Array.isArray(sel.tables)) {
          // multi-table selection (sel.tables may be array of strings or objects)
          nd.data.db.tables = sel.tables
            .map((t) => {
              if (!t) return null;
              if (typeof t === "string") return { table: t, columns: [] };
              return {
                table: t.table || "",
                columns: Array.isArray(t.columns) ? t.columns : [],
              };
            })
            .filter((x) => x && x.table);
        } else if (sel.type === "concept") {
          nd.data.taxonomy = sel.item;
        } else if (sel.type === "rules") {
          nd.data.ruleSet = sel.item.id;
        }
        // refresh UI
        renderCanvas();
        if (selectedNode && selectedNode.id === nodeId) showNodeProperties(nd);
        showToast("DB selection applied to node", "success");
      }

      // Choose event for a node (opens event selector and assigns event name/module)
      async function chooseEventForNode(nodeId) {
        try {
          // Load available events from event registry
          const eventsRes = await fetch("/api/event-registry", { cache: "no-store" });
          if (!eventsRes.ok) {
            showToast("Could not load events from registry", "error");
            return;
          }
          const eventsData = await eventsRes.json();
          const registry = eventsData && eventsData.registry ? eventsData.registry : {};

          const eventsMap = new Map();
          const rawKeys = Object.keys(registry || {});
          for (const k of rawKeys) {
            if (!k) continue;
            if (typeof k === "string" && (k.startsWith("evt:") || k.startsWith("dlq:"))) continue;
            const val = registry[k];
            if (val && typeof val === "object" && val.events) {
              Object.keys(val.events).forEach((eventName) => {
                const id = eventName;
                const cnt = Number(val.events[eventName]) || 1;
                if (!eventsMap.has(id)) eventsMap.set(id, { id, name: id, module: k, count: cnt });
                else {
                  const existing = eventsMap.get(id);
                  existing.count = (existing.count || 0) + cnt;
                }
              });
            } else {
              const eventName = k;
              const moduleName = typeof eventName === "string" && eventName.includes(":") ? String(eventName).split(":")[0] : "misc";
              let cnt = 0;
              if (val && typeof val === "object" && (val.total || val.count)) cnt = val.total || val.count;
              else if (typeof val === "number") cnt = val;
              else cnt = 1;
              if (!eventsMap.has(eventName)) eventsMap.set(eventName, { id: eventName, name: eventName, module: moduleName, count: cnt });
              else {
                const existing = eventsMap.get(eventName);
                existing.count = (existing.count || 0) + cnt;
              }
            }
          }

          const eventsList = Array.from(eventsMap.values()).sort((a, b) => (b.count || 0) - (a.count || 0));
          if (eventsList.length === 0) return showToast("No events available", "info");

          const modal = document.createElement("div");
          modal.style.cssText = "max-height:420px;overflow-y:auto;display:flex;flex-direction:column;gap:8px;";

          const listWrap = document.createElement('div');
          listWrap.style.display = 'flex';
          listWrap.style.flexDirection = 'column';
          listWrap.style.gap = '8px';

          eventsList.forEach((event) => {
            const eventItem = document.createElement("div");
            eventItem.style.cssText = "padding:10px 14px;border:1px solid #e1e8ed;border-radius:999px;cursor:pointer;transition:all 0.12s;background:white;display:flex;justify-content:space-between;align-items:center;";
            eventItem.innerHTML = `
              <div style="display:flex;gap:12px;align-items:center;">
                <div style="font-weight:600;color:#2c3e50;">${event.name}</div>
                <div style="font-size:0.75rem;color:#8899a6;">Module: ${event.module}</div>
              </div>
              <div style="font-size:0.75rem;color:#657786;background:#f0f3f5;padding:4px 8px;border-radius:12px;">${event.count} fired</div>
            `;
            eventItem.addEventListener("mouseenter", () => { eventItem.style.background = "#f8f9fa"; eventItem.style.borderColor = "#667eea"; });
            eventItem.addEventListener("mouseleave", () => { eventItem.style.background = "white"; eventItem.style.borderColor = "#e1e8ed"; });
            eventItem.addEventListener("click", () => {
              const nd = nodes.find((n) => n.id === nodeId);
              if (!nd) return;
              nd.data.event = event.name;
              nd.data.module = event.module;
              renderCanvas();
              if (selectedNode && selectedNode.id === nd.id) showNodeProperties(nd);
              document.querySelector(".modal-overlay")?.remove();
            });
            listWrap.appendChild(eventItem);
          });

          modal.appendChild(listWrap);

          await _createModal({ title: 'Select Event', bodyEl: modal, showCancel: true, confirmText: 'Cancel' });
        } catch (err) {
          console.error("chooseEventForNode error:", err);
          showToast("Failed to open event selector", "error");
        }
      }

      // Open mapper modal for connect node: allow selecting fields from sample JSON
      async function openConnectMapper(nodeId) {
        try {
          const nd = nodes.find((n) => n.id === nodeId);
          if (!nd) return showToast('Node not found', 'error');

          // helper to create modal body
          const root = document.createElement('div');
          root.style.display = 'flex';
          root.style.flexDirection = 'column';
          root.style.gap = '8px';

          const controls = document.createElement('div');
          controls.style.display = 'flex';
          controls.style.gap = '8px';

          const loadUpBtn = document.createElement('button');
          loadUpBtn.className = 'btn btn-secondary';
          loadUpBtn.textContent = 'Load From Upstream';
          controls.appendChild(loadUpBtn);

          const pasteBtn = document.createElement('button');
          pasteBtn.className = 'btn btn-secondary';
          pasteBtn.textContent = 'Paste JSON';
          controls.appendChild(pasteBtn);

          const prettyBtn = document.createElement('button');
          prettyBtn.className = 'btn btn-secondary';
          prettyBtn.textContent = 'Pretty Print';
          controls.appendChild(prettyBtn);

          root.appendChild(controls);

          const textarea = document.createElement('textarea');
          textarea.style.minHeight = '140px';
          textarea.style.fontFamily = "'Courier New', monospace";
          textarea.placeholder = 'Paste sample JSON here or use Load From Upstream';
          root.appendChild(textarea);

          const treeWrap = document.createElement('div');
          treeWrap.style.maxHeight = '420px';
          treeWrap.style.overflow = 'auto';
          treeWrap.style.border = '1px solid #e1e8ed';
          treeWrap.style.padding = '8px';
          treeWrap.style.borderRadius = '6px';
          root.appendChild(treeWrap);

          const previewWrap = document.createElement('div');
          previewWrap.style.marginTop = '8px';
          root.appendChild(previewWrap);

          // attempt to load sample from upstream node if present
              loadUpBtn.addEventListener('click', async () => {
                try {
                  // find upstream connection(s) and try to infer a best sample
                  const upstream = connections.find((c) => String(c.to) === String(nodeId));
                  if (!upstream) return showToast('No upstream connection found', 'info');
                  const fromNode = nodes.find((n) => String(n.id) === String(upstream.from));
                  if (!fromNode) return showToast('Upstream node not found', 'error');

                  // Prefer direct upstream sample sources depending on node type
                  // 1) event nodes -> fetch recent event record
                  // 2) action nodes -> try load saved example outputs from /api/actions or node.data.variableMappings
                  // 3) connect nodes -> use its mappingPreview or examplePayload
                  // 4) fallback to node.data.examplePayload

                  // 1) event
                  if (fromNode.type === 'event' && fromNode.data && fromNode.data.event) {
                    try {
                      const module = fromNode.data.module || (fromNode.data.event && String(fromNode.data.event).split(':')[0]) || '';
                      const resp = await fetch(`/api/event-records?module=${encodeURIComponent(module)}&event=${encodeURIComponent(fromNode.data.event)}`);
                      if (resp.ok) {
                        const j = await resp.json();
                        const rec = j && j.records && j.records[0] ? j.records[0] : null;
                        if (rec) {
                          let payload = rec.payload || rec.data || rec;
                          if (typeof payload === 'string') {
                            try { payload = JSON.parse(payload); } catch (e) {}
                          }
                          textarea.value = JSON.stringify(payload, null, 2);
                          buildTreeFromTextarea();
                          showToast('Loaded sample from upstream event', 'success');
                          return;
                        }
                      }
                    } catch (e) {
                      console.warn('load upstream event failed', e);
                    }
                  }

                  // 2) action node: try to fetch action details and example outputs
                  if (fromNode.type === 'action') {
                    try {
                      // attempt to fetch actions map and find by id or name
                      const r = await fetch('/api/actions');
                      if (r.ok) {
                        const all = await r.json();
                        const actions = all && all.actions ? all.actions : {};
                        // find by id or name
                        const act = Object.values(actions).find(a => (a.id && String(a.id) === String(fromNode.data.action)) || (a.name && a.name === fromNode.data.action));
                        if (act) {
                          // variableMappings._exampleOutputs or variableMappings.exampleOutputs
                          const vm = act.variableMappings || {};
                          const examples = vm._exampleOutputs || vm.exampleOutputs || vm.examples || null;
                          if (examples && Array.isArray(examples) && examples.length) {
                            const sample = examples[0];
                            textarea.value = JSON.stringify(sample, null, 2);
                            buildTreeFromTextarea();
                            showToast('Loaded sample from upstream action example outputs', 'success');
                            return;
                          }
                          // fallback: if action has a template or last executed query stored, we cannot reconstruct payload - skip
                        }
                      }
                    } catch (e) {
                      console.warn('load upstream action failed', e);
                    }
                  }

                  // 3) connect node: use its stored mappingPreview or examplePayload
                  if (fromNode.type === 'connect' && fromNode.data) {
                    if (fromNode.data.mappingPreview) {
                      textarea.value = JSON.stringify(fromNode.data.mappingPreview, null, 2);
                      buildTreeFromTextarea();
                      showToast('Loaded sample from upstream connect mapping preview', 'success');
                      return;
                    }
                    if (fromNode.data.examplePayload) {
                      textarea.value = JSON.stringify(fromNode.data.examplePayload, null, 2);
                      buildTreeFromTextarea();
                      showToast('Loaded sample from upstream connect payload', 'success');
                      return;
                    }
                  }

                  // 4) generic example payload stored on the node
                  if (fromNode.data && fromNode.data.examplePayload) {
                    textarea.value = JSON.stringify(fromNode.data.examplePayload, null, 2);
                    buildTreeFromTextarea();
                    showToast('Loaded sample from upstream node payload', 'success');
                    return;
                  }

                  showToast('No sample available from upstream node. Paste JSON instead.', 'info');
                } catch (e) {
                  console.error(e);
                  showToast('Failed to load upstream sample', 'error');
                }
              });

          pasteBtn.addEventListener('click', async () => {
            try {
              const text = await navigator.clipboard.readText();
              if (text) {
                textarea.value = text;
                buildTreeFromTextarea();
                showToast('Pasted JSON from clipboard', 'success');
              } else {
                showToast('Clipboard empty', 'info');
              }
            } catch (e) {
              showToast('Clipboard access failed', 'error');
            }
          });

          prettyBtn.addEventListener('click', () => {
            try {
              const v = textarea.value.trim();
              if (!v) return;
              const obj = JSON.parse(v);
              textarea.value = JSON.stringify(obj, null, 2);
              buildTreeFromTextarea();
            } catch (e) {
              showToast('Invalid JSON to pretty-print', 'error');
            }
          });

          function createCheckbox(path, label, value) {
            const row = document.createElement('div');
            row.style.display = 'flex';
            row.style.alignItems = 'center';
            row.style.gap = '8px';
            const cb = document.createElement('input');
            cb.type = 'checkbox';
            cb.dataset.path = path;
            const span = document.createElement('span');
            span.textContent = label;
            row.appendChild(cb);
            row.appendChild(span);
            return row;
          }

          function buildTreeFromTextarea() {
            treeWrap.innerHTML = '';
            previewWrap.innerHTML = '';
            const v = textarea.value.trim();
            if (!v) return;
            let obj = null;
            try { obj = JSON.parse(v); } catch (e) { treeWrap.innerHTML = '<div style="color:#c0392b">Invalid JSON</div>'; return; }

            function walk(o, prefix) {
              if (o === null || typeof o !== 'object') {
                const node = createCheckbox(prefix, `${prefix} (value)`);
                treeWrap.appendChild(node);
                return;
              }
              if (Array.isArray(o)) {
                // show array as a node and show first element's properties as selectable children
                const arrLabel = `${prefix}[]`;
                const node = createCheckbox(prefix, arrLabel);
                treeWrap.appendChild(node);
                if (o.length > 0 && typeof o[0] === 'object') {
                  const childWrap = document.createElement('div');
                  childWrap.style.marginLeft = '16px';
                  Object.keys(o[0]).forEach((k) => {
                    walk(o[0][k], `${prefix}.0.${k}`);
                  });
                  treeWrap.appendChild(childWrap);
                }
                return;
              }
              // object
              const keys = Object.keys(o);
              keys.forEach((k) => {
                const child = o[k];
                if (child !== null && typeof child === 'object') {
                  const label = `${prefix ? prefix + '.' : ''}${k}`;
                  const hdr = createCheckbox(label, label);
                  treeWrap.appendChild(hdr);
                  const childWrap = document.createElement('div');
                  childWrap.style.marginLeft = '12px';
                  walk(child, label);
                  treeWrap.appendChild(childWrap);
                } else {
                  const path = `${prefix ? prefix + '.' : ''}${k}`;
                  const node = createCheckbox(path, path);
                  treeWrap.appendChild(node);
                }
              });
            }

            walk(obj, '');
          }

          function collectSelectedMappings() {
            const checks = Array.from(treeWrap.querySelectorAll('input[type=checkbox]'));
            const selected = checks.filter((c) => c.checked).map((c) => c.dataset.path);
            // normalize paths: remove leading dot, convert .0. into [0] if desired (keep dot format for getValueFromPayload)
            return selected.map((p) => p.replace(/^\./, ''));
          }

          function buildPreview(mappingPaths) {
            const v = textarea.value.trim();
            if (!v) return '{}';
            let obj = null;
            try { obj = JSON.parse(v); } catch (e) { return '{}'; }
            const preview = {};

            // Helper: recursively resolve a path that may contain '.0.' wildcards.
            // If the path contains '.0.' the function will return an array of values
            // (or nested arrays/objects) preserving hierarchy for nested arrays.
            function resolveValueRecursively(sourceObj, path) {
              if (!sourceObj) return undefined;
              if (!path || path === '') return sourceObj;
              // find next wildcard
              const wi = path.indexOf('.0.');
              if (wi === -1) {
                return safeGetGlobal(sourceObj, path);
              }
              const prefix = path.substring(0, wi);
              const suffix = path.substring(wi + 3); // after '.0.'
              const arr = safeGetGlobal(sourceObj, prefix);
              if (!Array.isArray(arr)) return undefined;
              // map each element and resolve the remainder of the path for that element
              const out = arr.map((el) => {
                const v = resolveValueRecursively(el, suffix);
                return v === undefined ? null : v;
              });
              return out;
            }

            // Partition paths into array-based (contain .0.) and scalars
            const arrayGroups = {};
            const scalarPaths = [];
            mappingPaths.forEach((p) => {
              if (p.indexOf('.0.') !== -1) {
                const base = p.split('.0.')[0];
                arrayGroups[base] = arrayGroups[base] || [];
                arrayGroups[base].push(p);
              } else {
                scalarPaths.push(p);
              }
            });

            // Scalars
            scalarPaths.forEach((p) => {
              try {
                const key = p.split('.').slice(-1)[0];
                const val = resolveValueRecursively(obj, p);
                if (typeof val !== 'undefined') preview[key] = val === undefined ? null : val;
              } catch (e) { /* skip unresolved */ }
            });

            // Arrays (group by top-level array base)
            Object.keys(arrayGroups).forEach((base) => {
              try {
                const arrRoot = safeGetGlobal(obj, base);
                if (!Array.isArray(arrRoot)) {
                  preview[base] = null;
                  return;
                }
                const fields = arrayGroups[base];
                const items = arrRoot.map((_, idx) => {
                  const item = {};
                  fields.forEach((p) => {
                    const key = p.split('.').slice(-1)[0];
                    // build element-specific path by replacing the first .0. with the concrete index
                    const elementPath = p.replace(/\.0\./, `.${idx}.`);
                    const val = resolveValueRecursively(obj, elementPath);
                    if (typeof val !== 'undefined') item[key] = val === undefined ? null : val;
                  });
                  return item;
                });
                preview[base] = items;
              } catch (e) {
                preview[base] = null;
              }
            });

            return preview;
          }

          // open modal
          const modalRes = await _createModal({ title: 'Connect Mapper', bodyEl: root, showCancel: true, confirmText: 'Save Mapping', onConfirm: async () => {
            const selected = collectSelectedMappings();
            if (!selected || !selected.length) return false;
            const mapping = {};
            selected.forEach((p) => {
              const key = p.split('.').slice(-1)[0];
              mapping[key] = p;
            });
            nd.data.mapping = mapping;
            // store a quick preview built from the provided sample textarea
            const pv = buildPreview(selected) || {};

            // persist parser-friendly paths (wildcard form) so they can be reused across app
            try {
              nd.data.mappingPaths = nd.data.mappingPaths || {};
              Object.keys(mapping).forEach(k => {
                const p = mapping[k] || '';
                // normalized parser path: replace first-level array token .0. with .*.
                const parser = String(p).replace(/\.0\./g, '.*.');
                nd.data.mappingPaths[k] = parser;
              });
            } catch (e) { /* ignore */ }

            // Safe getter: prefer global getValueFromPayload if available, otherwise fallback to simple dotted-path resolver
            function safeGet(obj, path) {
              try {
                if (typeof getValueFromPayload === 'function') return getValueFromPayload(obj, path);
              } catch (e) { /* continue to fallback */ }
              if (!obj || !path) return undefined;
              const parts = String(path).split('.');
              let cur = obj;
              for (const p of parts) {
                if (cur && Object.prototype.hasOwnProperty.call(cur, p)) cur = cur[p];
                else { cur = undefined; break; }
              }
              return cur;
            }

            // Debug: log initial preview and selected paths
            try { console.debug('connect-mapper: initial preview (pv)', JSON.parse(JSON.stringify(pv)), 'selectedPaths', selected); } catch (e) { /* ignore */ }

            // Attempt to enrich preview values from upstream sources when possible
            try {
              // find all upstream connections that feed this connect node
              const ups = connections.filter(c => String(c.to) === String(nodeId));
              for (const up of ups) {
                try {
                  const fromNode = nodes.find(n => String(n.id) === String(up.from));
                  if (!fromNode) continue;

                  // obtain a reasonable sample object from upstream
                  let sample = null;
                  if (fromNode.type === 'action') {
                    try {
                      const r = await fetch('/api/actions');
                      if (r.ok) {
                        const all = await r.json();
                        const actions = all && all.actions ? all.actions : {};
                        const act = Object.values(actions).find(a => (a.id && String(a.id) === String(fromNode.data.action)) || (a.name && a.name === fromNode.data.action));
                        if (act) {
                          const vm = act.variableMappings || {};
                          const examples = vm._exampleOutputs || vm.exampleOutputs || vm.examples || null;
                          if (examples && Array.isArray(examples) && examples.length) sample = examples[0];
                        }
                      }
                    } catch (e) { /* ignore */ }
                    // fallback to fromNode.data.variableMappings
                    if (!sample && fromNode.data && fromNode.data.variableMappings && Array.isArray(fromNode.data.variableMappings._exampleOutputs) && fromNode.data.variableMappings._exampleOutputs.length) sample = fromNode.data.variableMappings._exampleOutputs[0];
                  } else if (fromNode.type === 'event') {
                    try {
                      const module = fromNode.data.module || (fromNode.data.event && String(fromNode.data.event).split(':')[0]) || '';
                      const resp = await fetch(`/api/event-records?module=${encodeURIComponent(module)}&event=${encodeURIComponent(fromNode.data.event)}`);
                      if (resp.ok) {
                        const j = await resp.json();
                        const rec = j && j.records && j.records[0] ? j.records[0] : null;
                        if (rec) {
                          let payload = rec.payload || rec.data || rec;
                          if (typeof payload === 'string') {
                            try { payload = JSON.parse(payload); } catch (e) {}
                          }
                          sample = payload;
                        }
                      }
                    } catch (e) { /* ignore */ }
                  } else if (fromNode.type === 'connect') {
                    if (fromNode.data && fromNode.data.mappingPreview) sample = fromNode.data.mappingPreview;
                    else if (fromNode.data && fromNode.data.examplePayload) sample = fromNode.data.examplePayload;
                  }

                  // merge resolved values into preview where pv has null/undefined
                  if (sample && typeof sample === 'object') {
                    try { console.debug('connect-mapper: upstream sample from', fromNode.id || fromNode.name || fromNode.type, JSON.parse(JSON.stringify(sample))); } catch (e) { /* ignore */ }
                    selected.forEach(p => {
                      const key = p.split('.').slice(-1)[0];
                      if (pv[key] === null || pv[key] === undefined) {
                        try {
                          const val = safeGet(sample, p);
                          try { console.debug('connect-mapper: resolve attempt', { path: p, key, resolved: val }); } catch (e) {}
                          if (val !== undefined) pv[key] = val === undefined ? null : val;
                        } catch (e) { console.debug('connect-mapper: resolve error', p, e); }
                      }
                    });
                    // if we've populated any values, stop searching other upstreams
                    const anyPopulated = Object.keys(pv).some(k => pv[k] !== null && pv[k] !== undefined);
                    if (anyPopulated) break;
                  }
                } catch (e) { /* continue */ }
              }
            } catch (e) { console.warn('enrich mapping preview failed', e); }

            try { console.debug('connect-mapper: final preview before persist', JSON.parse(JSON.stringify(pv))); } catch (e) { /* ignore */ }

            nd.data.mappingPreview = pv;
            // Also persist as exampleOutputs for downstream consumers (executor/pills prefer this field)
            try {
              nd.data.variableMappings = nd.data.variableMappings || {};
              nd.data.variableMappings._exampleOutputs = nd.data.variableMappings._exampleOutputs || [];
              // put preview as first example output (preserve existing examples)
              nd.data.variableMappings._exampleOutputs[0] = Object.assign({}, nd.data.variableMappings._exampleOutputs[0] || {}, pv);
              // also attach parser metadata so downstream consumers can reuse path patterns
              nd.data.variableMappings._exampleOutputs[0].__parsers = nd.data.mappingPaths || {};
              try {
                console.debug('connect-mapper: persisted _exampleOutputs for node', nd.id, JSON.parse(JSON.stringify(nd.data.variableMappings._exampleOutputs[0])));
              } catch (e) { /* ignore logging errors */ }
            } catch (e) { /* ignore */ }

            renderCanvas();
            if (selectedNode && selectedNode.id === nd.id) showNodeProperties(nd);
            return true;
          }});

          // live updates: when textarea changes, rebuild tree
          textarea.addEventListener('input', () => buildTreeFromTextarea());

          // update preview when checkboxes change
          treeWrap.addEventListener('change', () => {
            const sel = collectSelectedMappings();
            const pv = buildPreview(sel);
            previewWrap.innerHTML = '<div style="font-weight:600;margin-bottom:6px">Preview</div><pre style="background:white;padding:8px;border:1px solid #e1e8ed;border-radius:6px">' + escapeHtml(JSON.stringify(pv, null, 2)) + '</pre>';
          });

          // initial build if node contains mappingPreview or example
          if (nd.data && nd.data.mappingPreview) {
            textarea.value = JSON.stringify(nd.data.mappingPreview, null, 2);
            buildTreeFromTextarea();
          }

        } catch (e) {
          console.error('openConnectMapper error', e);
          showToast('Failed to open mapper', 'error');
        }
      }

      // Generate a simple SQL template from a mapping object
      // mapping: { key: path } where key will be used as SQL column name (or alias)
      function generateSQLTemplate(mapping, fromNode, toNode) {
        if (!mapping) return '';
        // attempt to determine table name from taxonomy action target or node.db
        let table = null;
        try {
          const actionKey = toNode && toNode.data && toNode.data.action ? toNode.data.action : null;
          if (actionKey && taxonomy && taxonomy.actions) {
            const act = taxonomy.actions[actionKey] || Object.values(taxonomy.actions).find(a => a && a.name === actionKey);
            if (act) {
              if (act.target) table = ('' + act.target).split('.')[0];
              else if (act.module) table = act.module;
            }
          }
        } catch (e) { /* ignore */ }
        if (!table && toNode && toNode.data && toNode.data.db && toNode.data.db.table) table = toNode.data.db.table;

        const cols = Object.keys(mapping || {});
        // Build placeholders using a canonical connect binding name
        const bindingName = fromNode && fromNode.id ? `connect_${fromNode.id}` : 'connect';

        // detect array groups to produce per-item templates if needed
        const hasArray = cols.some(k => (mapping[k] || '').indexOf('.0.') !== -1);

        if (table) {
          // simple insert for scalar mappings
          if (!hasArray) {
            const placeholders = cols.map(k => `{{${bindingName}.${mapping[k]}}}`);
            return `INSERT INTO ${table} (${cols.join(', ')}) VALUES (${placeholders.join(', ')});`;
          }

          // when arrays exist, produce a clear template for iterating over array items
          // find the array base (first mapping that contains .0.)
          const arrayBases = new Set();
          cols.forEach(k => { const p = mapping[k] || ''; const m = p.match(/^(.*?)\.0\./); if (m) arrayBases.add(m[1]); });
          const base = Array.from(arrayBases)[0];
          // columns that are array-based will use placeholders with .0. preserved
          const scalarCols = cols.filter(k => (mapping[k] || '').indexOf('.0.') === -1);
          const arrayCols = cols.filter(k => (mapping[k] || '').indexOf('.0.') !== -1);

          let tpl = `-- Insert per item in array ${base}\n`;
          tpl += `-- For each item in {{${bindingName}.${base}}} produce an INSERT like:\n`;
          const allCols = cols.join(', ');
          const allPlaceholders = cols.map(k => `{{${bindingName}.${mapping[k]}}}`).join(', ');
          tpl += `INSERT INTO ${table} (${allCols}) VALUES (${allPlaceholders});`;
          return tpl;
        }

        // fallback: produce JSON mapping placeholder template
        return `-- Mapping template (no table detected)\n-- ${JSON.stringify(mapping, null, 2)}\n` + Object.keys(mapping).map(k => `${k} => {{${bindingName}.${mapping[k]}}}`).join('\n');
      }

      // Normalize various SQL executor responses into a consistent POJO array
      function normalizeSqlResult(result) {
        try {
          if (!result) return [];
          // if result.data is an array of rows (SELECT)
          if (Array.isArray(result.data)) {
            // ensure rows are plain objects
            return result.data.map(r => {
              try { return JSON.parse(JSON.stringify(r)); } catch (e) { return r; }
            });
          }

          // If result.rows exists (common driver shape)
          if (Array.isArray(result.rows)) {
            return result.rows.map(r => {
              try { return JSON.parse(JSON.stringify(r)); } catch (e) { return r; }
            });
          }

          // DML: insert/update/delete with metadata
          const op = {};
          if (result.insertId || result.lastInsertId) {
            op.type = 'insert';
            op.lastInsertId = result.insertId || result.lastInsertId || null;
          } else if (result.affectedRows || result.rowCount) {
            op.type = 'mutation';
            op.affectedRows = result.affectedRows || result.rowCount || 0;
          } else if (result.message && typeof result.message === 'string') {
            op.type = 'message';
            op.message = result.message;
          }

          // include raw result for fidelity
          op.raw = result;
          return [op];
        } catch (e) {
          return [{ raw: result }];
        }
      }

      function updateNodeDB(nodeId, raw) {
        const nd = nodes.find((n) => n.id === nodeId);
        if (!nd) return;
        nd.data.db = nd.data.db || {};
        // support multiple table entries separated by semicolon: table.col1,col2;other.col
        if (raw.includes(";")) {
          nd.data.db.tables = raw
            .split(";")
            .map((entry) => {
              const parts = entry.split(".");
              const t = parts[0] ? parts[0].trim() : "";
              const cols = parts[1]
                ? parts[1]
                    .split(",")
                    .map((s) => s.trim())
                    .filter(Boolean)
                : [];
              return { table: t, columns: cols };
            })
            .filter((x) => x.table);
          // clear single-table fields
          delete nd.data.db.table;
          delete nd.data.db.columns;
        } else {
          const parts = raw.split(".");
          nd.data.db.table = parts[0] || "";
          if (parts[1])
            nd.data.db.columns = parts[1]
              .split(",")
              .map((s) => s.trim())
              .filter(Boolean);
          else nd.data.db.columns = [];
          delete nd.data.db.tables;
        }
        renderCanvas();
      }

      // Create a new DB Action tied to a specific node (creation flows happen via workflow editor)
      async function createActionForNode(nodeId) {
        try {
          const form = await showFormModal('Create DB Action for Node', [
            { name: 'name', label: 'Action ID', placeholder: 'unique_action_id' },
            { name: 'description', label: 'Description', type: 'textarea' }
          ]);
          if (!form) return;
          const id = (form.name || '').replace(/\s+/g, '_');
          const body = { id, name: form.name, description: form.description };
          const res = await fetch('/api/taxonomy/actions', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body) });
          const data = await res.json();
          if (!data || !data.ok) return showToast('Failed to create action: ' + (data && data.error), 'error');
          showToast('Action created', 'success');
          // assign to node
          const nd = nodes.find(n => n.id === nodeId);
            if (nd) {
            // Store action name on the node (friendly label) rather than the raw id
            nd.data.action = (data.action && (data.action.name || data.action.id)) || id;
            renderCanvas();
            if (selectedNode && selectedNode.id === nd.id) showNodeProperties(nd);
          }
          await loadTaxonomy();
        } catch (e) {
          showToast('Error creating action: ' + (e.message || e), 'error');
        }
      }

      // Create a new custom logic entry and attach to node
      async function createLogicForNode(nodeId) {
        try {
          const form = await showFormModal('Create Custom Logic for Node', [
            { name: 'id', label: 'Logic ID', placeholder: 'unique_logic_id' },
            { name: 'name', label: 'Name' },
            { name: 'description', label: 'Description', type: 'textarea' },
            { name: 'functionCode', label: 'Function Code', type: 'textarea', placeholder: 'return {};'}
          ]);
          if (!form) return;
          const body = { id: form.id, name: form.name, description: form.description, functionCode: form.functionCode || 'return null;', inputs: [] };
          const res = await fetch('/api/custom-logic', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body) });
          const data = await res.json();
          if (!data || !data.ok) return showToast('Failed to create logic: ' + (data && data.error), 'error');
          showToast('Custom logic created', 'success');
          const nd = nodes.find(n => n.id === nodeId);
          if (nd) {
            nd.data.logicId = data.logic && data.logic.id ? data.logic.id : form.id;
            renderCanvas();
            if (selectedNode && selectedNode.id === nd.id) showNodeProperties(nd);
          }
        } catch (e) {
          showToast('Error creating logic: ' + (e.message || e), 'error');
        }
      }

      

      function updateNodeProperty(prop, value) {
        if (selectedNode) {
          selectedNode[prop] = value;
          selectedNode.data[prop] = value;
          renderCanvas();
        }
      }

      function updateNodeData(prop, value) {
        if (selectedNode) {
          // support dot-notation for nested properties (e.g. 'db.operation')
          if (prop && prop.indexOf && prop.includes(".")) {
            const parts = prop.split(".");
            let cur = selectedNode.data;
            for (let i = 0; i < parts.length - 1; i++) {
              const p = parts[i];
              if (!cur[p]) cur[p] = {};
              cur = cur[p];
            }
            cur[parts[parts.length - 1]] = value;
          } else {
            selectedNode.data[prop] = value;
          }
          renderCanvas();
        }
      }

      function deleteSelectedNode() {
        if (selectedNode) {
          nodes = nodes.filter((n) => n.id !== selectedNode.id);
          selectedNode = null;
          renderCanvas();
          document.getElementById("properties-panel").innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">üìã</div>
                        <div class="empty-state-text">No node selected</div>
                        <div class="empty-state-hint">Click a node to edit its properties</div>
                    </div>
                `;
        }
      }

      let connectionState = { connecting: false, fromId: null, tempLine: null };

      function renderConnections() {
        const svg = document.getElementById("svg-connections");
        const canvas = document.getElementById("workflow-canvas");
        // robust sizing with fallbacks
        const baseW =
          canvas.clientWidth || canvas.offsetWidth || canvas.scrollWidth || 800;
        const baseH =
          canvas.clientHeight ||
          canvas.offsetHeight ||
          canvas.scrollHeight ||
          600;

        // Expand SVG to cover the extents of all nodes so connections remain
        // visible even when nodes sit outside the immediate viewport.
        const canvasRect = canvas.getBoundingClientRect();
        let maxRight = 0;
        let maxBottom = 0;
        document.querySelectorAll(".workflow-node").forEach((el) => {
          const r = el.getBoundingClientRect();
          const right = r.right - canvasRect.left; // local x extent
          const bottom = r.bottom - canvasRect.top; // local y extent
          if (right > maxRight) maxRight = right;
          if (bottom > maxBottom) maxBottom = bottom;
        });

        const w = Math.max(baseW, Math.ceil(maxRight + 80));
        const h = Math.max(baseH, Math.ceil(maxBottom + 80));
        svg.setAttribute("width", w);
        svg.setAttribute("height", h);
        svg.style.width = w + "px";
        svg.style.height = h + "px";

        // prepare defs for arrow marker
        svg.innerHTML = `
          <defs>
            <marker id="arrow" viewBox="0 0 10 10" refX="8" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse">
              <path d="M 0 0 L 10 5 L 0 10 z" fill="#667eea" />
            </marker>
          </defs>`;

        // draw after layout completes
        requestAnimationFrame(() => {
          try {
            console.debug(
              "renderConnections: drawing",
              connections.length,
              "connections"
            );
            const svgRect = svg.getBoundingClientRect();
            connections.forEach((c) => {
              const fromEl = document.querySelector(
                `#wfnode-${c.from} .connection-point.output`
              );
              const toEl = document.querySelector(
                `#wfnode-${c.to} .connection-point.input`
              );
              if (!fromEl || !toEl) return;
              const fromRect = fromEl.getBoundingClientRect();
              const toRect = toEl.getBoundingClientRect();
              const x1 = fromRect.left + fromRect.width / 2 - svgRect.left;
              const y1 = fromRect.top + fromRect.height / 2 - svgRect.top;
              const x2 = toRect.left + toRect.width / 2 - svgRect.left;
              const y2 = toRect.top + toRect.height / 2 - svgRect.top;

              const path = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "path"
              );
              const dx = Math.max(40, Math.abs(x2 - x1) * 0.4);
              const d = `M ${x1} ${y1} C ${x1 + dx} ${y1} ${
                x2 - dx
              } ${y2} ${x2} ${y2}`;
              path.setAttribute("d", d);
              path.setAttribute("stroke", "#667eea");
              path.setAttribute("stroke-width", "4");
              path.setAttribute("stroke-linecap", "round");
              path.setAttribute("fill", "none");
              path.setAttribute("data-conn-id", c.id);
              path.setAttribute("data-from", c.from);
              path.setAttribute("data-to", c.to);
              path.setAttribute("marker-end", "url(#arrow)");
              path.style.cursor = "pointer";
              path.style.pointerEvents = "auto";
              path.addEventListener("click", (ev) => {
                showConfirm("Delete connection?").then((ok) => {
                  if (ok) {
                    connections = connections.filter((cc) => cc.id !== c.id);
                    renderConnections();
                  }
                });
                ev.stopPropagation();
              });
              svg.appendChild(path);
            });

            // re-attach tempLine if connecting
            if (connectionState.connecting) {
              if (!connectionState.tempLine) {
                const t = document.createElementNS(
                  "http://www.w3.org/2000/svg",
                  "path"
                );
                t.setAttribute("stroke", "#999");
                t.setAttribute("stroke-width", "2");
                t.setAttribute("fill", "none");
                t.setAttribute("stroke-dasharray", "6 4");
                connectionState.tempLine = t;
              }
              // append tempLine last so it's on top of persistent paths
              svg.appendChild(connectionState.tempLine);
              console.debug("renderConnections: tempLine attached");
            }
          } catch (e) {
            console.warn(
              "renderConnections failed",
              e && e.message ? e.message : e
            );
          }
        });
      }

      function startConnection(fromNodeId) {
        console.debug("startConnection from", fromNodeId);
        connectionState.connecting = true;
        connectionState.fromId = fromNodeId;
        // create temp line
        const svg = document.getElementById("svg-connections");
        const tempPath = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "path"
        );
        tempPath.setAttribute("stroke", "#999");
        tempPath.setAttribute("stroke-width", "2");
        tempPath.setAttribute("fill", "none");
        tempPath.setAttribute("stroke-dasharray", "6 4");
        connectionState.tempLine = tempPath;
        svg.appendChild(tempPath);

        // Note: rendering is handled by the shared `renderConnections()` helper
        // defined at module level. No local duplicate renderer is required here.

        // mouse handlers for the temporary connection line
        function onMove(e) {
          if (!connectionState.connecting || !connectionState.tempLine) return;
          const fromEl = document.querySelector(
            `#wfnode-${connectionState.fromId} .connection-point.output`
          );
          const svg = document.getElementById("svg-connections");
          if (!fromEl || !svg) return;
          const svgRect = svg.getBoundingClientRect();
          const fromRect = fromEl.getBoundingClientRect();
          const x1 = fromRect.left + fromRect.width / 2 - svgRect.left;
          const y1 = fromRect.top + fromRect.height / 2 - svgRect.top;
          const x2 = e.clientX - svgRect.left;
          const y2 = e.clientY - svgRect.top;
          const dx = Math.max(40, Math.abs(x2 - x1) * 0.4);
          const d = `M ${x1} ${y1} C ${x1 + dx} ${y1} ${
            x2 - dx
          } ${y2} ${x2} ${y2}`;
          connectionState.tempLine.setAttribute("d", d);
        }

        // helper to clear any snap highlights
        function clearSnapHighlights() {
          document
            .querySelectorAll(".connection-point.snap")
            .forEach((el) => el.classList.remove("snap"));
        }

        function onUp(e) {
          if (!connectionState.connecting) return;
          // clear any live snap highlight immediately
          clearSnapHighlights();
          // Robust completion: always do a proximity search for the nearest
          // input connection-point and pick it if it's within threshold. This
          // avoids relying solely on elementFromPoint which can be flaky with
          // small targets, nested elements, or during scrolling.
          const mx = e.clientX;
          const my = e.clientY;
          const inputs = Array.from(
            document.querySelectorAll(".connection-point.input")
          );
          let closest = null;
          let minDist = Infinity;
          for (const inp of inputs) {
            const r = inp.getBoundingClientRect();
            const cx = r.left + r.width / 2;
            const cy = r.top + r.height / 2;
            const dx = cx - mx;
            const dy = cy - my;
            const dist = Math.hypot(dx, dy);
            if (dist < minDist) {
              minDist = dist;
              closest = inp;
            }
          }

          const RADIUS_PX = 40; // chosen to be forgiving but conservative
          if (closest && minDist <= RADIUS_PX) {
            const toNodeId =
              closest.dataset.nodeId || closest.getAttribute("data-node-id");
            console.debug(
              "onUp: snapped to input nodeId=",
              toNodeId,
              "dist=",
              Math.round(minDist)
            );
            if (
              toNodeId &&
              connectionState.fromId &&
              String(toNodeId) !== String(connectionState.fromId)
            ) {
              const newConn = {
                from: String(connectionState.fromId),
                to: String(toNodeId),
                id: "c_" + Date.now() + "_" + Math.floor(Math.random() * 10000),
              };
              // dedupe: don't add if identical connection exists
              const exists = connections.some(
                (c) =>
                  String(c.from) === newConn.from && String(c.to) === newConn.to
              );
              if (!exists) {
                connections.push(newConn);
                console.debug("created connection", newConn);
                try {
                  // If connecting from a `connect` node into an `action` node, auto-propagate mapping
                  const fromNode = nodes.find(n => String(n.id) === String(newConn.from));
                  const toNode = nodes.find(n => String(n.id) === String(newConn.to));
                  if (fromNode && toNode && fromNode.type === 'connect' && toNode.type === 'action') {
                    // Ensure we have a mapping on the connect node
                    const mapping = fromNode.data && fromNode.data.mapping ? fromNode.data.mapping : null;
                    const preview = fromNode.data && fromNode.data.mappingPreview ? fromNode.data.mappingPreview : null;
                    if (mapping) {
                      toNode.data = toNode.data || {};
                      // preserve any existing variableMappings
                      toNode.data.variableMappings = toNode.data.variableMappings || {};
                      // store inputMapping and example outputs for the action node to consume
                      toNode.data.variableMappings.inputMapping = mapping;
                      if (preview) toNode.data.variableMappings._exampleOutputs = [ preview ];
                      // mark source so executor/editor can trace inputs
                      toNode.data.inputSource = { type: 'connect', nodeId: fromNode.id };
                        // Generate a SQL template and inject into the action node's variableMappings and node data
                        try {
                          const tpl = generateSQLTemplate(mapping, fromNode, toNode);
                          toNode.data.variableMappings.template = tpl;
                          // keep a copy on node.data.query for convenience in the editor
                          toNode.data.query = tpl;
                        } catch (e) {
                          console.warn('template generation failed', e);
                        }
                        // update UI if action node is selected
                        if (selectedNode && selectedNode.id === toNode.id) showNodeProperties(toNode);
                        showToast('Mapping propagated to action node and template injected', 'success');
                    }
                  }
                } catch (e) {
                  console.warn('Auto-propagate mapping failed', e);
                }
              } else {
                console.debug("skipping duplicate connection", newConn);
                // visual feedback: pulse the existing connection path
                try {
                  const svg = document.getElementById("svg-connections");
                  const existing = svg.querySelector(
                    `path[data-from="${newConn.from}"][data-to="${newConn.to}"]`
                  );
                  if (existing) {
                    existing.classList.add("conn-pulse");
                    setTimeout(
                      () => existing.classList.remove("conn-pulse"),
                      700
                    );
                  }
                } catch (e) {
                  /* ignore */
                }
              }
            }
          } else {
            console.debug(
              "onUp: no nearby input found (minDist=",
              Math.round(minDist),
              ") - aborting connection"
            );
          }
          // cleanup
          if (connectionState.tempLine && connectionState.tempLine.parentNode) {
            connectionState.tempLine.parentNode.removeChild(
              connectionState.tempLine
            );
          }
          connectionState.tempLine = null;
          connectionState.connecting = false;
          connectionState.fromId = null;
          renderConnections();
          // remove the exact handlers we registered
          if (connectionState.moveHandler) {
            document.removeEventListener(
              "mousemove",
              connectionState.moveHandler
            );
          }
          document.removeEventListener(
            "mouseup",
            connectionState.upHandler || onUp
          );
          connectionState.moveHandler = null;
          connectionState.upHandler = null;
        }

        // Enhanced mousemove: update temp line and highlight nearest input
        function onMoveWithSnap(e) {
          onMove(e);
          // find closest input and toggle snap class
          const inputs = Array.from(
            document.querySelectorAll(".connection-point.input")
          );
          if (!inputs.length) return;
          let closest = null;
          let minDist = Infinity;
          const mx = e.clientX;
          const my = e.clientY;
          for (const inp of inputs) {
            const r = inp.getBoundingClientRect();
            const cx = r.left + r.width / 2;
            const cy = r.top + r.height / 2;
            const dx = cx - mx;
            const dy = cy - my;
            const dist = Math.hypot(dx, dy);
            if (dist < minDist) {
              minDist = dist;
              closest = inp;
            }
          }
          const HIGHLIGHT_PX = 56;
          // clear previous highlights first for predictability
          document
            .querySelectorAll(".connection-point.snap")
            .forEach((el) => el.classList.remove("snap"));
          if (closest && minDist <= HIGHLIGHT_PX) {
            closest.classList.add("snap");
          }
        }

        // register handlers and keep references so we can reliably remove them
        connectionState.moveHandler = onMoveWithSnap;
        connectionState.upHandler = onUp;
        document.addEventListener("mousemove", connectionState.moveHandler);
        document.addEventListener("mouseup", connectionState.upHandler);
      }

      // Rules Functions
      async function loadRules() {
        try {
          const res = await fetch("/api/rules");
          const data = await res.json();
          if (data.ok) {
            const sets = data.ruleSets || [];

            function groupByFirstWord(list) {
              const g = {};
              (list || []).forEach((it) => {
                const name = (it && it.name) || "";
                const first =
                  (name.split(/\s+/)[0] || "Other").trim() || "Other";
                g[first] = g[first] || [];
                g[first].push(it);
              });
              return g;
            }

            function buildRulesHtml(groups) {
              // use global distinct random color generator
              return Object.keys(groups)
                .sort()
                .map((gk) => {
                  const colors = getDistinctGroupColors(gk || "grp");
                  const items = groups[gk]
                    .map((rs) => {
                      const count = (rs.rules || []).length;
                      return `
                        <div class="list-item type-rule" style="border-left:4px solid ${
                          colors.accent
                        };">
                          <div style="display:flex; justify-content:space-between; align-items:center;">
                            <div>
                              <div class="list-item-title">${rs.name}</div>
                              <div class="list-item-desc">${
                                rs.description || ""
                              } <span class="badge">${
                        rs.concept || ""
                      }</span></div>
                              <div style="margin-top:0.5rem; font-size:0.85rem; color:#657786;">${count} rule${
                        count === 1 ? "" : "s"
                      }</div>
                            </div>
                            <div style="display:flex; gap:8px;">
                              <button class="btn btn-secondary" onclick="editRuleSet('${
                                rs.id
                              }')">Edit</button>
                              <button class="btn btn-secondary" onclick="editRules('${
                                rs.id
                              }')">Rules</button>
                              <button class="btn btn-danger" onclick="deleteRuleSet('${
                                rs.id
                              }')">Delete</button>
                            </div>
                          </div>
                        </div>
                      `;
                    })
                    .join("");

                  return `
                    <div class="group-container rules-group">
                      <div class="group-header" style="background: linear-gradient(90deg, ${colors.left}, ${colors.right}); border-bottom:1px solid ${colors.border};">${gk}</div>
                      <div class="group-items">${items}</div>
                    </div>
                  `;
                })
                .join("");
            }

            const grouped = groupByFirstWord(sets);
            const rulesListEl = document.getElementById("rules-list");
            if (!sets || sets.length === 0) {
              rulesListEl.innerHTML = `
                <div style="padding:24px; color:#445;">
                  <h3 style="margin-top:0">No rule sets found</h3>
                  <div style="margin-top:8px">There are no business rule sets configured yet. Click <strong>‚ûï Add Rule Set</strong> to create one, or import rules from your orchestration configuration.</div>
                </div>
              `;
            } else {
              rulesListEl.innerHTML = buildRulesHtml(grouped);
            }
          }
        } catch (e) {
          console.error("Failed to load rules:", e);
        }
      }

      // Executions Functions
      async function loadExecutions() {
        try {
          const status = document.getElementById("status-filter")?.value || "";
          const query = status ? `?status=${status}` : "";
          const res = await fetch("/api/executions" + query);
          const data = await res.json();
          if (data.ok) {
            const execList = document.getElementById("executions-list");
            execList.innerHTML = data.executions
              .map(
                (exec) => `
                        <div class="list-item">
                            <div class="list-item-title">${
                              exec.workflowName
                            } <span class="badge" style="background: ${
                  exec.status === "completed"
                    ? "#d4edda"
                    : exec.status === "failed"
                    ? "#f8d7da"
                    : "#fff3cd"
                }; color: ${
                  exec.status === "completed"
                    ? "#155724"
                    : exec.status === "failed"
                    ? "#721c24"
                    : "#856404"
                };">${exec.status}</span></div>
                            <div class="list-item-desc">
                                Started: ${new Date(
                                  exec.startedAt
                                ).toLocaleString()}<br>
                                Current Step: ${exec.currentStep || "N/A"}
                            </div>
                        </div>
                    `
              )
              .join("");
          }
        } catch (e) {
          console.error("Failed to load executions:", e);
        }
      }

      // Dialog functions (modal-driven CRUD for taxonomy & rules)
      async function showAddConceptDialog() {
        // build custom modal so properties field can be a table/column multi-select dropdown
        const root = document.createElement("div");
        root.style.display = "flex";
        root.style.flexDirection = "column";
        root.style.gap = "12px";

        const nameRow = document.createElement("div");
        const nameLbl = document.createElement("label");
        nameLbl.textContent = "Concept Name";
        const nameInput = document.createElement("input");
        nameInput.type = "text";
        nameInput.placeholder = "Name";
        nameRow.appendChild(nameLbl);
        nameRow.appendChild(nameInput);

        const descRow = document.createElement("div");
        const descLbl = document.createElement("label");
        descLbl.textContent = "Description";
        const descTa = document.createElement("textarea");
        descTa.placeholder = "Description";
        descRow.appendChild(descLbl);
        descRow.appendChild(descTa);

        // Properties dropdown
        const propRow = document.createElement("div");
        propRow.style.display = "flex";
        propRow.style.flexDirection = "column";
        const propLbl = document.createElement("label");
        propLbl.textContent = "Properties (choose table columns)";
        propRow.appendChild(propLbl);

        const selector = document.createElement("div");
        selector.style.border = "1px solid #e6eef6";
        selector.style.borderRadius = "8px";
        selector.style.padding = "8px";
        selector.style.minHeight = "40px";
        selector.style.cursor = "pointer";
        selector.tabIndex = 0;

        const chipsRow = document.createElement("div");
        chipsRow.style.display = "flex";
        chipsRow.style.flexWrap = "wrap";
        chipsRow.style.gap = "6px";
        chipsRow.style.minHeight = "24px";
        selector.appendChild(chipsRow);

        const dropdownPanel = document.createElement("div");
        dropdownPanel.style.position = "relative";
        dropdownPanel.style.marginTop = "8px";

        const panel = document.createElement("div");
        panel.style.position = "relative";
        panel.style.width = "100%";
        panel.style.marginTop = "6px";
        panel.style.zIndex = "9999";
        panel.style.background = "white";
        panel.style.border = "1px solid #e6eef6";
        panel.style.borderRadius = "8px";
        panel.style.maxHeight = "260px";
        panel.style.overflow = "auto";
        panel.style.padding = "8px";
        panel.style.display = "none";

        let selectedColumns = [];

        async function loadSchemaAndRender() {
          panel.innerHTML = "";
          let schema = null;
          try {
            const r = await fetch("/api/db/schema");
            if (r.ok) schema = await r.json();
          } catch (e) {
            schema = null;
          }
          if (!schema) schema = { tables: {} };
          const tables = schema.tables || {};
          Object.keys(tables).forEach((t) => {
            const tWrap = document.createElement("div");
            tWrap.style.padding = "6px 8px";
            const tName = document.createElement("div");
            tName.style.fontWeight = "700";
            tName.textContent = t;
            tWrap.appendChild(tName);
            const cols = (tables[t] && tables[t].columns) || [];
            const colsWrap = document.createElement("div");
            colsWrap.style.display = "flex";
            colsWrap.style.flexDirection = "column";
            colsWrap.style.gap = "4px";
            colsWrap.style.marginTop = "6px";
            cols.forEach((c) => {
              const colName = (c && c.name) || c;
              const id = `prop_${t}_${colName}`.replace(/[^a-zA-Z0-9_]/g, "_");
              const row = document.createElement("label");
              row.style.display = "flex";
              row.style.alignItems = "center";
              row.style.gap = "8px";
              const chk = document.createElement("input");
              chk.type = "checkbox";
              chk.id = id;
              chk.value = `${t}.${colName}`;
              if (selectedColumns.includes(chk.value)) chk.checked = true;
              chk.addEventListener("change", (ev) => {
                if (chk.checked) {
                  if (!selectedColumns.includes(chk.value))
                    selectedColumns.push(chk.value);
                } else {
                  selectedColumns = selectedColumns.filter(
                    (x) => x !== chk.value
                  );
                }
                renderChips();
              });
              const span = document.createElement("div");
              span.textContent = colName;
              span.style.color = "#2c3e50";
              row.appendChild(chk);
              row.appendChild(span);
              colsWrap.appendChild(row);
            });
            tWrap.appendChild(colsWrap);
            panel.appendChild(tWrap);
            const hr = document.createElement("hr");
            hr.style.border = "none";
            hr.style.borderTop = "1px solid #f1f5f9";
            hr.style.margin = "8px 0";
            panel.appendChild(hr);
          });
        }

      // Convenience wrapper used across the UI
      function showModal(opts) {
        try {
          // call _createModal but do not require callers to await
          _createModal(opts).catch((e) => console.error('Modal error:', e));
        } catch (e) {
          console.error('showModal failed:', e);
        }
      }

        function renderChips() {
          chipsRow.innerHTML = "";
          selectedColumns.forEach((c) => {
            const pill = document.createElement("div");
            pill.style.display = "inline-flex";
            pill.style.alignItems = "center";
            pill.style.gap = "6px";
            pill.style.background = "#eef6ff";
            pill.style.padding = "6px 8px";
            pill.style.borderRadius = "999px";
            pill.style.fontSize = "0.9rem";
            const name = document.createElement("div");
            name.textContent = c;
            const removeBtn = document.createElement("button");
            removeBtn.className = "btn btn-ghost";
            removeBtn.style.padding = "4px 6px";
            removeBtn.textContent = "‚úï";
            removeBtn.addEventListener("click", (ev) => {
              ev.stopPropagation();
              selectedColumns = selectedColumns.filter((x) => x !== c);
              // uncheck corresponding checkbox in panel if present
              const el = panel.querySelector(`input[value="${c}"]`);
              if (el) el.checked = false;
              renderChips();
            });
            pill.appendChild(name);
            pill.appendChild(removeBtn);
            chipsRow.appendChild(pill);
          });
          if (!selectedColumns.length) {
            const hint = document.createElement("div");
            hint.style.color = "#657786";
            hint.textContent = "No columns selected";
            chipsRow.appendChild(hint);
          }
        }

        selector.addEventListener("click", async (ev) => {
          ev.stopPropagation();
          if (panel.style.display === "none") {
            panel.style.display = "block";
            await loadSchemaAndRender();
          } else panel.style.display = "none";
          renderStatusArea();
        });

        function renderStatusArea() {
          // show status input only when at least one property/column selected
          if (selectedColumns && selectedColumns.length) {
            statusArea.style.display = "block";
          } else {
            statusArea.style.display = "none";
          }
          // render chips
          statusChips.innerHTML = "";
          (statuses || []).forEach((s) => {
            const pill = document.createElement("div");
            pill.style.display = "inline-flex";
            pill.style.alignItems = "center";
            pill.style.gap = "6px";
            pill.style.background = "#e6ffed";
            pill.style.padding = "6px 8px";
            pill.style.borderRadius = "999px";
            pill.style.fontSize = "0.9rem";
            const name = document.createElement("div");
            name.textContent = s;
            const removeBtn = document.createElement("button");
            removeBtn.className = "btn btn-ghost";
            removeBtn.style.padding = "4px 6px";
            removeBtn.textContent = "‚úï";
            removeBtn.addEventListener("click", (ev) => {
              ev.stopPropagation();
              statuses = statuses.filter((x) => x !== s);
              renderStatusArea();
            });
            pill.appendChild(name);
            pill.appendChild(removeBtn);
            statusChips.appendChild(pill);
          });
          if (
            !(statuses && statuses.length) &&
            selectedColumns &&
            selectedColumns.length
          ) {
            const hint = document.createElement("div");
            hint.style.color = "#657786";
            hint.textContent = "No statuses added";
            statusChips.appendChild(hint);
          }
        }

        // add status handlers
        addStatusBtn.addEventListener("click", (ev) => {
          ev.preventDefault();
          const v = (statusInput.value || "").trim();
          if (!v) return;
          if (!statuses.includes(v)) statuses.push(v);
          statusInput.value = "";
          renderStatusArea();
        });
        statusInput.addEventListener("keydown", (ev) => {
          if (ev.key === "Enter") {
            ev.preventDefault();
            addStatusBtn.click();
          }
        });

        document.addEventListener("click", (ev) => {
          if (!selector.contains(ev.target) && !panel.contains(ev.target)) {
            panel.style.display = "none";
          }
        });

        dropdownPanel.appendChild(panel);
        propRow.appendChild(selector);
        propRow.appendChild(dropdownPanel);

        root.appendChild(nameRow);
        root.appendChild(descRow);
        root.appendChild(propRow);

        renderChips();

        const res = await _createModal({
          title: "Add Concept",
          bodyEl: root,
          confirmText: "Save",
          onConfirm: () => {
            const nm = nameInput.value && nameInput.value.trim();
            if (!nm) {
              showToast("Name required", "error");
              return null;
            }
            return {
              name: nm,
              description: descTa.value || "",
              properties: (selectedColumns || []).join(","),
              statuses: (statuses || []).slice(),
            };
          },
        });

        if (!res) return;
        const concept = {
          id: res.name.replace(/\s+/g, ""),
          name: res.name,
          description: res.description,
          properties: res.properties
            ? res.properties
                .split(",")
                .map((s) => s.trim())
                .filter(Boolean)
            : [],
          statuses: res.statuses
            ? Array.isArray(res.statuses)
              ? res.statuses
              : (res.statuses + "")
                  .split(",")
                  .map((s) => s.trim())
                  .filter(Boolean)
            : [],

          relatedEvents: [],
          relatedActions: [],
        };
        await addConcept(concept);
      }

      async function addConcept(concept) {
        try {
          const res = await fetch("/api/taxonomy/concepts", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(concept),
          });
          const data = await res.json();
          if (data.ok) {
            showToast("Concept added", "success");
            await loadTaxonomy();
          } else {
            showToast("Failed to add concept: " + data.error, "error");
          }
        } catch (e) {
          showToast("Error adding concept: " + e.message, "error");
        }
      }

      async function editConcept(id) {
        try {
          const c = taxonomy.concepts && taxonomy.concepts[id];
          if (!c) return showToast("Concept not found", "error");

          // build custom modal similar to Add but prepopulate selected columns
          const root = document.createElement("div");
          root.style.display = "flex";
          root.style.flexDirection = "column";
          root.style.gap = "12px";

          const nameRow = document.createElement("div");
          const nameLbl = document.createElement("label");
          nameLbl.textContent = "Name";
          const nameInput = document.createElement("input");
          nameInput.type = "text";
          nameInput.value = c.name || "";
          nameRow.appendChild(nameLbl);
          nameRow.appendChild(nameInput);

          const descRow = document.createElement("div");
          const descLbl = document.createElement("label");
          descLbl.textContent = "Description";
          const descTa = document.createElement("textarea");
          descTa.value = c.description || "";
          descRow.appendChild(descLbl);
          descRow.appendChild(descTa);

          const propRow = document.createElement("div");
          propRow.style.display = "flex";
          propRow.style.flexDirection = "column";
          const propLbl = document.createElement("label");
          propLbl.textContent = "Properties (choose table columns)";
          propRow.appendChild(propLbl);

          const selector = document.createElement("div");
          selector.style.border = "1px solid #e6eef6";
          selector.style.borderRadius = "8px";
          selector.style.padding = "8px";
          selector.style.minHeight = "40px";
          selector.style.cursor = "pointer";

          const chipsRow = document.createElement("div");
          chipsRow.style.display = "flex";
          chipsRow.style.flexWrap = "wrap";
          chipsRow.style.gap = "6px";
          chipsRow.style.minHeight = "24px";
          selector.appendChild(chipsRow);

          const dropdownPanel = document.createElement("div");
          dropdownPanel.style.position = "relative";
          dropdownPanel.style.marginTop = "8px";

          const panel = document.createElement("div");
          panel.style.position = "relative";
          panel.style.width = "100%";
          panel.style.marginTop = "6px";
          panel.style.zIndex = "9999";
          panel.style.background = "white";
          panel.style.border = "1px solid #e6eef6";
          panel.style.borderRadius = "8px";
          panel.style.maxHeight = "260px";
          panel.style.overflow = "auto";
          panel.style.padding = "8px";
          panel.style.display = "none";

          let selectedColumns = Array.isArray(c.properties)
            ? c.properties.slice()
            : [];

          // statuses for edit modal
          let statuses = Array.isArray(c.statuses) ? c.statuses.slice() : [];

          const statusArea = document.createElement("div");
          statusArea.style.display = "none";
          statusArea.style.marginTop = "8px";
          const statusInput = document.createElement("input");
          statusInput.type = "text";
          statusInput.placeholder = "Add status and press Enter or click +";
          statusInput.style.padding = "8px";
          statusInput.style.border = "1px solid #e6eef6";
          statusInput.style.borderRadius = "6px";
          statusInput.style.flex = "1";
          const addStatusBtn = document.createElement("button");
          addStatusBtn.className = "btn btn-primary";
          addStatusBtn.textContent = "+";
          addStatusBtn.style.marginLeft = "8px";
          const statusRow = document.createElement("div");
          statusRow.style.display = "flex";
          statusRow.style.alignItems = "center";
          statusRow.appendChild(statusInput);
          statusRow.appendChild(addStatusBtn);
          const statusChips = document.createElement("div");
          statusChips.style.display = "flex";
          statusChips.style.flexWrap = "wrap";
          statusChips.style.gap = "6px";
          statusChips.style.marginTop = "8px";
          statusArea.appendChild(statusRow);
          statusArea.appendChild(statusChips);
          propRow.appendChild(statusArea);

          function renderChips() {
            chipsRow.innerHTML = "";
            selectedColumns.forEach((c2) => {
              const pill = document.createElement("div");
              pill.style.display = "inline-flex";
              pill.style.alignItems = "center";
              pill.style.gap = "6px";
              pill.style.background = "#eef6ff";
              pill.style.padding = "6px 8px";
              pill.style.borderRadius = "999px";
              pill.style.fontSize = "0.9rem";
              const name = document.createElement("div");
              name.textContent = c2;
              const removeBtn = document.createElement("button");
              removeBtn.className = "btn btn-ghost";
              removeBtn.style.padding = "4px 6px";
              removeBtn.textContent = "‚úï";
              removeBtn.addEventListener("click", (ev) => {
                ev.stopPropagation();
                selectedColumns = selectedColumns.filter((x) => x !== c2);
                const el = panel.querySelector(`input[value="${c2}"]`);
                if (el) el.checked = false;
                renderChips();
              });
              pill.appendChild(name);
              pill.appendChild(removeBtn);
              chipsRow.appendChild(pill);
            });
            if (!selectedColumns.length) {
              const hint = document.createElement("div");
              hint.style.color = "#657786";
              hint.textContent = "No columns selected";
              chipsRow.appendChild(hint);
            }
            renderStatusArea();
          }

          function renderStatusArea() {
            if (selectedColumns && selectedColumns.length) {
              statusArea.style.display = "block";
            } else {
              statusArea.style.display = "none";
            }
            statusChips.innerHTML = "";
            (statuses || []).forEach((s) => {
              const pill = document.createElement("div");
              pill.style.display = "inline-flex";
              pill.style.alignItems = "center";
              pill.style.gap = "6px";
              pill.style.background = "#e6ffed";
              pill.style.padding = "6px 8px";
              pill.style.borderRadius = "999px";
              pill.style.fontSize = "0.9rem";
              const name = document.createElement("div");
              name.textContent = s;
              const removeBtn = document.createElement("button");
              removeBtn.className = "btn btn-ghost";
              removeBtn.style.padding = "4px 6px";
              removeBtn.textContent = "‚úï";
              removeBtn.addEventListener("click", (ev) => {
                ev.stopPropagation();
                statuses = statuses.filter((x) => x !== s);
                renderStatusArea();
              });
              pill.appendChild(name);
              pill.appendChild(removeBtn);
              statusChips.appendChild(pill);
            });
            if (
              !(statuses && statuses.length) &&
              selectedColumns &&
              selectedColumns.length
            ) {
              const hint = document.createElement("div");
              hint.style.color = "#657786";
              hint.textContent = "No statuses added";
              statusChips.appendChild(hint);
            }
          }

          // add status handlers
          addStatusBtn.addEventListener("click", (ev) => {
            ev.preventDefault();
            const v = (statusInput.value || "").trim();
            if (!v) return;
            if (!statuses.includes(v)) statuses.push(v);
            statusInput.value = "";
            renderStatusArea();
          });
          statusInput.addEventListener("keydown", (ev) => {
            if (ev.key === "Enter") {
              ev.preventDefault();
              addStatusBtn.click();
            }
          });

          async function loadSchemaAndRender() {
            panel.innerHTML = "";
            let schema = null;
            try {
              const r = await fetch("/api/db/schema");
              if (r.ok) schema = await r.json();
            } catch (e) {
              schema = null;
            }
            if (!schema) schema = { tables: {} };
            const tables = schema.tables || {};
            Object.keys(tables).forEach((t) => {
              const tWrap = document.createElement("div");
              tWrap.style.padding = "6px 8px";
              const tName = document.createElement("div");
              tName.style.fontWeight = "700";
              tName.textContent = t;
              tWrap.appendChild(tName);
              const cols = (tables[t] && tables[t].columns) || [];
              const colsWrap = document.createElement("div");
              colsWrap.style.display = "flex";
              colsWrap.style.flexDirection = "column";
              colsWrap.style.gap = "4px";
              colsWrap.style.marginTop = "6px";
              cols.forEach((c3) => {
                const colName = (c3 && c3.name) || c3;
                const id = `prop_${t}_${colName}`.replace(
                  /[^a-zA-Z0-9_]/g,
                  "_"
                );
                const row = document.createElement("label");
                row.style.display = "flex";
                row.style.alignItems = "center";
                row.style.gap = "8px";
                const chk = document.createElement("input");
                chk.type = "checkbox";
                chk.id = id;
                chk.value = `${t}.${colName}`;
                if (selectedColumns.includes(chk.value)) chk.checked = true;
                chk.addEventListener("change", (ev) => {
                  if (chk.checked) {
                    if (!selectedColumns.includes(chk.value))
                      selectedColumns.push(chk.value);
                  } else {
                    selectedColumns = selectedColumns.filter(
                      (x) => x !== chk.value
                    );
                  }
                  renderChips();
                });
                const span = document.createElement("div");
                span.textContent = colName;
                span.style.color = "#2c3e50";
                row.appendChild(chk);
                row.appendChild(span);
                colsWrap.appendChild(row);
              });
              tWrap.appendChild(colsWrap);
              panel.appendChild(tWrap);
              const hr = document.createElement("hr");
              hr.style.border = "none";
              hr.style.borderTop = "1px solid #f1f5f9";
              hr.style.margin = "8px 0";
              panel.appendChild(hr);
            });
          }

          selector.addEventListener("click", async (ev) => {
            ev.stopPropagation();
            if (panel.style.display === "none") {
              panel.style.display = "block";
              await loadSchemaAndRender();
            } else panel.style.display = "none";
          });

          document.addEventListener("click", (ev) => {
            if (!selector.contains(ev.target) && !panel.contains(ev.target)) {
              panel.style.display = "none";
            }
          });

          dropdownPanel.appendChild(panel);
          propRow.appendChild(selector);
          propRow.appendChild(dropdownPanel);

          root.appendChild(nameRow);
          root.appendChild(descRow);
          root.appendChild(propRow);

          renderChips();

          const res = await _createModal({
            title: "Edit Concept",
            bodyEl: root,
            confirmText: "Save",
            onConfirm: () => {
              const nm = nameInput.value && nameInput.value.trim();
              if (!nm) {
                showToast("Name required", "error");
                return null;
              }
              return {
                name: nm,
                description: descTa.value || "",
                properties: (selectedColumns || []).join(","),
                statuses: (statuses || []).slice(),
              };
            },
          });

          if (!res) return;
          const body = {
            id,
            name: res.name,
            description: res.description,
            properties: res.properties
              ? res.properties
                  .split(",")
                  .map((s) => s.trim())
                  .filter(Boolean)
              : [],
            statuses: res.statuses
              ? Array.isArray(res.statuses)
                ? res.statuses
                : (res.statuses + "")
                    .split(",")
                    .map((s) => s.trim())
                    .filter(Boolean)
              : [],
          };
          const resp = await fetch(
            `/api/taxonomy/concepts/${encodeURIComponent(id)}`,
            {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(body),
            }
          );
          const data = await resp.json();
          if (data.ok) {
            showToast("Concept updated", "success");
            await loadTaxonomy();
          } else showToast("Failed to update concept: " + data.error, "error");
        } catch (e) {
          showToast("Error updating concept: " + e.message, "error");
        }
      }

      // Manage states for a concept (modal editor)
      async function showManageStates(conceptId) {
        // ensure taxonomy loaded
        if (!taxonomy) await loadTaxonomy();
        const concept =
          taxonomy && taxonomy.concepts ? taxonomy.concepts[conceptId] : null;
        if (!concept)
          return showToast("Concept not found: " + conceptId, "error");

        const root = document.createElement("div");
        root.style.display = "flex";
        root.style.flexDirection = "column";
        root.style.gap = "8px";

        const list = document.createElement("div");
        list.style.display = "flex";
        list.style.flexDirection = "column";
        list.style.gap = "8px";

        let states = Array.isArray(concept.states)
          ? JSON.parse(JSON.stringify(concept.states))
          : [];

        // load available rule-sets for enter/exit selectors and cache globally for modal
        try {
          const rr = await fetch("/api/rules");
          const rd = await rr.json();
          globalThis.__availableRuleSets = (rd && rd.ruleSets) || [];
        } catch (e) {
          globalThis.__availableRuleSets = [];
        }

        function renderStates() {
          list.innerHTML = "";
          states.forEach((s, idx) => {
            const row = document.createElement("div");
            row.style.display = "flex";
            row.style.gap = "8px";
            row.style.alignItems = "center";
            const idInput = document.createElement("input");
            idInput.value = s.id || "";
            idInput.placeholder = "id";
            idInput.className = "form-input";
            idInput.style.minWidth = "120px";
            const nameInput = document.createElement("input");
            nameInput.value = s.name || "";
            nameInput.placeholder = "name";
            nameInput.className = "form-input";
            nameInput.style.minWidth = "160px";
            const allowedInput = document.createElement("input");
            allowedInput.value = (s.allowedTransitions || []).join(",");
            allowedInput.placeholder = "allowed: a,b";
            allowedInput.className = "form-input";
            allowedInput.style.minWidth = "180px";
            // enter/exit rule-set selectors
            const enterSel = document.createElement("select");
            enterSel.className = "form-select";
            enterSel.style.minWidth = "180px";
            const exitSel = document.createElement("select");
            exitSel.className = "form-select";
            exitSel.style.minWidth = "180px";
            const emptyOpt = document.createElement("option");
            emptyOpt.value = "";
            emptyOpt.textContent = "(no rule set)";
            enterSel.appendChild(emptyOpt.cloneNode(true));
            exitSel.appendChild(emptyOpt.cloneNode(true));
            // populate available rule sets if present in modal scope
            try {
              if (
                globalThis.__availableRuleSets &&
                Array.isArray(globalThis.__availableRuleSets)
              ) {
                globalThis.__availableRuleSets.forEach((rs) => {
                  const o1 = document.createElement("option");
                  o1.value = rs.id;
                  o1.textContent = rs.name || rs.id;
                  if (s.enterRuleSet && s.enterRuleSet === rs.id)
                    o1.selected = true;
                  enterSel.appendChild(o1);
                  const o2 = document.createElement("option");
                  o2.value = rs.id;
                  o2.textContent = rs.name || rs.id;
                  if (s.exitRuleSet && s.exitRuleSet === rs.id)
                    o2.selected = true;
                  exitSel.appendChild(o2);
                });
              }
            } catch (e) {
              console.warn(e);
            }

            const del = document.createElement("button");
            del.className = "btn btn-danger";
            // Populate rule-set dropdown for decision nodes
            if (node.type === "decision") {
              (async () => {
                try {
                  const sel = document.querySelector(
                    "#properties-panel select[onchange=\"updateNodeData('ruleSet', this.value)\"]"
                  );
                  if (!sel) return;
                  const r = await fetch("/api/rules");
                  const d = await r.json();
                  const sets = d.ruleSets || [];
                  sets.forEach((rs) => {
                    const opt = document.createElement("option");
                    opt.value = rs.id;
                    opt.textContent = rs.name || rs.id;
                    if (
                      node.data &&
                      node.data.ruleSet &&
                      node.data.ruleSet === rs.id
                    )
                      opt.selected = true;
                    sel.appendChild(opt);
                  });
                } catch (e) {
                  // silent
                }
              })();
            }
            del.textContent = "Delete";
            del.addEventListener("click", () => {
              states.splice(idx, 1);
              renderStates();
            });

            row.appendChild(idInput);
            row.appendChild(nameInput);
            row.appendChild(allowedInput);
            // attach selectors with small labels
            const enterWrap = document.createElement("div");
            enterWrap.style.display = "flex";
            enterWrap.style.flexDirection = "column";
            enterWrap.style.gap = "4px";
            const enterLbl = document.createElement("div");
            enterLbl.style.fontSize = "11px";
            enterLbl.style.color = "#657786";
            enterLbl.textContent = "Enter Rule";
            enterWrap.appendChild(enterLbl);
            enterWrap.appendChild(enterSel);
            const exitWrap = document.createElement("div");
            exitWrap.style.display = "flex";
            exitWrap.style.flexDirection = "column";
            exitWrap.style.gap = "4px";
            const exitLbl = document.createElement("div");
            exitLbl.style.fontSize = "11px";
            exitLbl.style.color = "#657786";
            exitLbl.textContent = "Exit Rule";
            exitWrap.appendChild(exitLbl);
            exitWrap.appendChild(exitSel);
            row.appendChild(enterWrap);
            row.appendChild(exitWrap);
            row.appendChild(del);
            list.appendChild(row);
          });
        }

        const addBtn = document.createElement("button");
        addBtn.className = "btn btn-primary";
        addBtn.textContent = "Add State";
        addBtn.addEventListener("click", () => {
          states.push({
            id: "state_" + Date.now(),
            name: "New State",
            allowedTransitions: [],
          });
          renderStates();
        });

        root.appendChild(list);
        root.appendChild(addBtn);

        const res = await _createModal({
          title: "Manage States for " + concept.name,
          bodyEl: root,
          confirmText: "Save",
          onConfirm: async () => {
            // collect state values (including enter/exit rule-set selections)
            const newStates = [];
            const rows = list.querySelectorAll("div");
            for (const r of rows) {
              const inputs = r.querySelectorAll("input");
              if (!inputs || inputs.length < 3) continue;
              const sid = inputs[0].value && inputs[0].value.trim();
              const sname = inputs[1].value && inputs[1].value.trim();
              const allowed = inputs[2].value
                ? inputs[2].value
                    .split(",")
                    .map((x) => x.trim())
                    .filter(Boolean)
                : [];
              // find selects for enter/exit rule sets (if present)
              const selects = r.querySelectorAll("select");
              const enter = selects && selects[0] ? selects[0].value : "";
              const exit = selects && selects[1] ? selects[1].value : "";
              if (!sid) continue;
              const st = {
                id: sid,
                name: sname || sid,
                allowedTransitions: allowed,
              };
              if (enter) st.enterRuleSet = enter;
              if (exit) st.exitRuleSet = exit;
              newStates.push(st);
            }
            try {
              // persist via taxonomy concept update
              const payload = { states: newStates };
              const resp = await fetch(
                "/api/taxonomy/concepts/" + encodeURIComponent(conceptId),
                {
                  method: "PUT",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify(payload),
                }
              );
              const d = await resp.json();
              if (d && d.ok) {
                showToast("States saved", "success");
                // refresh local taxonomy
                await loadTaxonomy();
                return true;
              } else {
                showToast(
                  "Save failed: " + (d && d.error ? d.error : "unknown"),
                  "error"
                );
                return null;
              }
            } catch (e) {
              showToast("Save failed: " + e.message, "error");
              return null;
            }
          },
        });

        // initial render
        renderStates();
      }

      // Manage links (attach/detach actions & events to a concept)
      async function showManageLinks(conceptId) {
        if (!taxonomy) await loadTaxonomy();
        const concept =
          taxonomy && taxonomy.concepts ? taxonomy.concepts[conceptId] : null;
        if (!concept)
          return showToast("Concept not found: " + conceptId, "error");

        // clone current relations
        const relatedActions = new Set(
          Array.isArray(concept.relatedActions)
            ? concept.relatedActions.slice()
            : []
        );
        const relatedEvents = new Set(
          Array.isArray(concept.relatedEvents)
            ? concept.relatedEvents.slice()
            : []
        );

        const root = document.createElement("div");
        root.style.display = "flex";
        root.style.gap = "12px";

        const actionsCol = document.createElement("div");
        actionsCol.style.flex = "1";
        const eventsCol = document.createElement("div");
        eventsCol.style.flex = "1";

        const aTitle = document.createElement("h4");
        aTitle.textContent = "Actions";
        actionsCol.appendChild(aTitle);
        const eTitle = document.createElement("h4");
        eTitle.textContent = "Events";
        eventsCol.appendChild(eTitle);

        const aList = document.createElement("div");
        aList.style.display = "flex";
        aList.style.flexDirection = "column";
        aList.style.gap = "6px";
        const eList = document.createElement("div");
        eList.style.display = "flex";
        eList.style.flexDirection = "column";
        eList.style.gap = "6px";

        // populate lists
        const actions = Object.keys(taxonomy.actions || {}).map((k) => ({
          id: k,
          name: taxonomy.actions[k].name || k,
        }));
        const events = Object.keys(taxonomy.events || {}).map((k) => ({
          id: k,
          name: taxonomy.events[k].name || k,
        }));

        actions.forEach((a) => {
          const row = document.createElement("label");
          row.style.display = "flex";
          row.style.alignItems = "center";
          row.style.gap = "8px";
          const cb = document.createElement("input");
          cb.type = "checkbox";
          cb.checked = relatedActions.has(a.id);
          cb.addEventListener("change", () => {
            if (cb.checked) relatedActions.add(a.id);
            else relatedActions.delete(a.id);
          });
          const span = document.createElement("span");
          span.textContent = a.name + " (" + a.id + ")";
          row.appendChild(cb);
          row.appendChild(span);
          aList.appendChild(row);
        });

        events.forEach((ev) => {
          const row = document.createElement("label");
          row.style.display = "flex";
          row.style.alignItems = "center";
          row.style.gap = "8px";
          const cb = document.createElement("input");
          cb.type = "checkbox";
          cb.checked = relatedEvents.has(ev.id);
          cb.addEventListener("change", () => {
            if (cb.checked) relatedEvents.add(ev.id);
            else relatedEvents.delete(ev.id);
          });
          const span = document.createElement("span");
          span.textContent = ev.name + " (" + ev.id + ")";
          row.appendChild(cb);
          row.appendChild(span);
          eList.appendChild(row);
        });

        actionsCol.appendChild(aList);
        eventsCol.appendChild(eList);
        root.appendChild(actionsCol);
        root.appendChild(eventsCol);

        const res = await _createModal({
          title: "Manage Links for " + concept.name,
          bodyEl: root,
          confirmText: "Save",
          onConfirm: async () => {
            const payload = {
              relatedActions: Array.from(relatedActions),
              relatedEvents: Array.from(relatedEvents),
            };
            try {
              const resp = await fetch(
                "/api/taxonomy/concepts/" + encodeURIComponent(conceptId),
                {
                  method: "PUT",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify(payload),
                }
              );
              const d = await resp.json();
              if (d && d.ok) {
                showToast("Links saved", "success");
                await loadTaxonomy();
                return true;
              } else {
                showToast(
                  "Save failed: " + (d && d.error ? d.error : "unknown"),
                  "error"
                );
                return null;
              }
            } catch (e) {
              showToast("Save failed: " + e.message, "error");
              return null;
            }
          },
        });
      }

      async function deleteConcept(id) {
        try {
          const ok = await showConfirm(
            "Delete this concept? This will remove it from related events/actions."
          );
          if (!ok) return;
          const res = await fetch(
            `/api/taxonomy/concepts/${encodeURIComponent(id)}`,
            { method: "DELETE" }
          );
          const data = await res.json();
          if (data.ok) {
            showToast("Concept deleted", "success");
            await loadTaxonomy();
          } else showToast("Failed to delete concept: " + data.error, "error");
        } catch (e) {
          showToast("Error deleting concept: " + e.message, "error");
        }
      }

      async function showAddEventDialog() {
        const form = await showFormModal("Add Event", [
          { name: "name", label: "Event name" },
          { name: "description", label: "Description", type: "textarea" },
          { name: "concept", label: "Concept (optional)", dbChooser: true },
        ]);
        if (!form) return;
        await addEvent({
          id: form.name.replace(/\s+/g, ""),
          name: form.name,
          description: form.description,
          concept: form.concept,
        });
      }

      async function addEvent(ev) {
        try {
          const res = await fetch("/api/taxonomy/events", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(ev),
          });
          const data = await res.json();
          if (data.ok) {
            showToast("Event added", "success");
            await loadTaxonomy();
          } else showToast("Failed to add event: " + data.error, "error");
        } catch (e) {
          showToast("Error adding event: " + e.message, "error");
        }
      }

      async function editEvent(id) {
        try {
          const ev = taxonomy.events && taxonomy.events[id];
          if (!ev) return showToast("Event not found", "error");
          const form = await showFormModal("Edit Event", [
            { name: "name", label: "Event name", value: ev.name },
            {
              name: "description",
              label: "Description",
              value: ev.description || "",
              type: "textarea",
            },
            {
              name: "concept",
              label: "Concept (optional)",
              value: ev.concept || "",
            },
          ]);
          if (!form) return;
          const body = {
            id,
            name: form.name,
            description: form.description,
            concept: form.concept,
          };
          const res = await fetch(
            `/api/taxonomy/events/${encodeURIComponent(id)}`,
            {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(body),
            }
          );
          const data = await res.json();
          if (data.ok) {
            showToast("Event updated", "success");
            await loadTaxonomy();
          } else showToast("Failed to update event: " + data.error, "error");
        } catch (e) {
          showToast("Error updating event: " + e.message, "error");
        }
      }

      async function deleteEvent(id) {
        try {
          const ok = await showConfirm("Delete this event?");
          if (!ok) return;
          const res = await fetch(
            `/api/taxonomy/events/${encodeURIComponent(id)}`,
            { method: "DELETE" }
          );
          const data = await res.json();
          if (data.ok) {
            showToast("Event deleted", "success");
            await loadTaxonomy();
          } else showToast("Failed to delete event: " + data.error, "error");
        } catch (e) {
          showToast("Error deleting event: " + e.message, "error");
        }
      }

      async function showAddActionDialog() {
        const form = await showFormModal("Add DB Action", [
          { name: "name", label: "DB Action Name", placeholder: "e.g., insert_customer, update_order" },
          {
            name: "target",
            label: "Database Target (table.column)",
            placeholder: "e.g., customers.email, orders.status",
            dbChooser: true,
          },
          { name: "description", label: "Description", placeholder: "What does this database action do?", type: "textarea" },
          { name: "concept", label: "Concept (optional)", dbChooser: true },
        ]);
        if (!form) return;
        await addAction({
          id: form.name.replace(/\s+/g, ""),
          name: form.name,
          description: form.description,
          concept: form.concept,
          target: form.target,
        });
      }

      async function addAction(act) {
        try {
          const res = await fetch("/api/taxonomy/actions", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(act),
          });
          const data = await res.json();
          if (data.ok) {
            showToast("Action added", "success");
            await loadTaxonomy();
          } else showToast("Failed to add action: " + data.error, "error");
        } catch (e) {
          showToast("Error adding action: " + e.message, "error");
        }
      }

      async function editAction(id) {
        try {
          const act = taxonomy.actions && taxonomy.actions[id];
          if (!act) return showToast("Action not found", "error");
          const form = await showFormModal("Edit DB Action", [
            { name: "name", label: "DB Action Name", value: act.name },
            {
              name: "target",
              label: "Database Target (table.column)",
              value: act.target || "",
              placeholder: "e.g., customers.email, orders.status",
              dbChooser: true,
            },
            {
              name: "description",
              label: "Description",
              value: act.description || "",
              placeholder: "What does this database action do?",
              type: "textarea",
            },
            {
              name: "concept",
              label: "Concept (optional)",
              value: act.concept || "",
              dbChooser: true,
            },
          ]);
          if (!form) return;
          const body = {
            id,
            name: form.name,
            description: form.description,
            concept: form.concept,
            target: form.target,
          };
          const res = await fetch(
            `/api/taxonomy/actions/${encodeURIComponent(id)}`,
            {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(body),
            }
          );
          const data = await res.json();
          if (data.ok) {
            showToast("Action updated", "success");
            await loadTaxonomy();
          } else showToast("Failed to update action: " + data.error, "error");
        } catch (e) {
          showToast("Error updating action: " + e.message, "error");
        }
      }

      // Save a workflow node as an action entry and persist the workflow
      async function saveNodeAsAction(nodeId) {
        try {
          const nd = nodes.find(n => n.id === nodeId);
          if (!nd) return showToast('Node not found', 'error');

          // Build action payload from node data
          const payload = {
            id: nd.data && nd.data.id ? nd.data.id : nd.id,
            name: nd.name || (nd.data && nd.data.name) || ('action_' + Date.now()),
            description: nd.data && nd.data.description ? nd.data.description : `Action saved from node ${nd.id}`,
            query: nd.data && nd.data.query ? nd.data.query : (nd.data && nd.data.variableMappings && nd.data.variableMappings.template ? nd.data.variableMappings.template : ''),
            variableMappings: nd.data && nd.data.variableMappings ? nd.data.variableMappings : {}
          };

          // POST to /api/actions
          const res = await fetch('/api/actions', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
          });
          const d = await res.json();
          if (!d || !d.ok) {
            showToast('Failed to create action: ' + ((d && d.error) || 'unknown'), 'error');
            return;
          }

          // Assign to node and persist workflow
          nd.data = nd.data || {};
          nd.data.id = nd.data.id || payload.id;
          nd.data.action = payload.id;
          // Also attach variableMappings for editor use
          if (payload.variableMappings) nd.data.variableMappings = payload.variableMappings;

          // Ensure there is a workflow to save. If none exists, create a minimal workflow
          if (!currentWorkflow) {
            currentWorkflow = {
              id: 'wf_' + Date.now(),
              name: generateWorkflowName(),
              description: 'Auto-generated workflow to persist node->action binding',
              steps: [],
              concept: '',
              triggerEvent: ''
            };
            // If nodes array doesn't include this node, add it. Otherwise keep existing nodes.
            if (!Array.isArray(nodes)) nodes = [];
            if (!nodes.find(n => n.id === nd.id)) nodes.push(nd);
          }

          // Save workflow so node->action binding persists
          await saveCurrentWorkflow();
          renderCanvas();
          if (selectedNode && selectedNode.id === nd.id) showNodeProperties(nd);

          showToast('Node saved as action and workflow persisted', 'success');
        } catch (e) {
          console.error('saveNodeAsAction failed', e);
          showToast('Failed to save node as action: ' + (e.message || e), 'error');
        }
      }

      // `runNodeDbAction` removed ‚Äî action execution should be performed via the Action editor/test flows using Connect inputs.

      async function deleteAction(id) {
        try {
          const ok = await showConfirm("Delete this action?");
          if (!ok) return;
          const res = await fetch(
            `/api/taxonomy/actions/${encodeURIComponent(id)}`,
            { method: "DELETE" }
          );
          const data = await res.json();
          if (data.ok) {
            showToast("Action deleted", "success");
            await loadTaxonomy();
          } else showToast("Failed to delete action: " + data.error, "error");
        } catch (e) {
          showToast("Error deleting action: " + e.message, "error");
        }
      }

      async function showAddRuleSetDialog() {
        // Use visual rule builder for initial rules
        const form = await showFormModal("Add Rule Set", [
          { name: "name", label: "Rule set name" },
          { name: "description", label: "Description", type: "textarea" },
          { name: "concept", label: "Concept (optional)" },
        ]);
        if (!form) return;
        const built = await showRuleBuilder("Define Rules (visual)", []);
        if (built === null) return; // cancelled
        await addRuleSet({
          id: form.name.replace(/\s+/g, ""),
          name: form.name,
          description: form.description,
          concept: form.concept,
          rules: built || [],
        });
      }

      async function addRuleSet(rs) {
        try {
          const res = await fetch("/api/rules", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(rs),
          });
          const data = await res.json();
          if (data.ok) {
            showToast("Rule set added", "success");
            await loadRules();
          } else showToast("Failed to add rule set: " + data.error, "error");
        } catch (e) {
          showToast("Error adding rule set: " + e.message, "error");
        }
      }

      async function editRuleSet(id) {
        try {
          const resList = await fetch("/api/rules");
          const listData = await resList.json();
          if (!listData.ok)
            return showToast("Failed to fetch rule sets", "error");
          const current = (listData.ruleSets || []).find((r) => r.id === id);
          if (!current) return showToast("Rule set not found", "error");
          const form = await showFormModal("Edit Rule Set", [
            { name: "name", label: "Rule set name", value: current.name },
            {
              name: "description",
              label: "Description",
              value: current.description || "",
              type: "textarea",
            },
            {
              name: "concept",
              label: "Concept (optional)",
              value: current.concept || "",
            },
          ]);
          if (!form) return;
          // let user edit the rules visually
          const updatedRules = await showRuleBuilder(
            "Edit Rules (visual)",
            current.rules || []
          );
          if (updatedRules === null) return;
          const body = {
            id,
            name: form.name,
            description: form.description,
            concept: form.concept,
            rules: updatedRules || [],
          };
          const res = await fetch(`/api/rules/${encodeURIComponent(id)}`, {
            method: "PUT",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(body),
          });
          const data = await res.json();
          if (data.ok) {
            showToast("Rule set updated", "success");
            await loadRules();
          } else showToast("Failed to update rule set: " + data.error, "error");
        } catch (e) {
          showToast("Error updating rule set: " + e.message, "error");
        }
      }

      async function deleteRuleSet(id) {
        try {
          const ok = await showConfirm("Delete this rule set?");
          if (!ok) return;
          const res = await fetch(`/api/rules/${encodeURIComponent(id)}`, {
            method: "DELETE",
          });
          const data = await res.json();
          if (data.ok) {
            showToast("Rule set deleted", "success");
            await loadRules();
          } else showToast("Failed to delete rule set: " + data.error, "error");
        } catch (e) {
          showToast("Error deleting rule set: " + e.message, "error");
        }
      }

      // Edit rules within a rule set (JSON editor modal)
      async function editRules(id) {
        try {
          const resList = await fetch("/api/rules");
          const listData = await resList.json();
          if (!listData.ok)
            return showToast("Failed to fetch rule sets", "error");
          const current = (listData.ruleSets || []).find((r) => r.id === id);
          if (!current) return showToast("Rule set not found", "error");
          // offer visual rule editor first
          const updated = await showRuleBuilder(
            "Edit Rules (visual)",
            current.rules || []
          );
          if (updated === null) return;
          const body = { id, rules: updated };
          // update rules using the canonical rule-set update endpoint
          const res = await fetch(`/api/rules/${encodeURIComponent(id)}`, {
            method: "PUT",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(body),
          });
          const data = await res.json();
          if (data.ok) {
            showToast("Rules updated", "success");
            await loadRules();
          } else showToast("Failed to update rules: " + data.error, "error");
        } catch (e) {
          showToast("Error editing rules: " + e.message, "error");
        }
      }

      // Return a list of available operators and metadata for the rule builder
      function getAvailableOperators() {
        return [
          { key: "eq", label: "=", arity: 2, desc: "Equal" },
          { key: "ne", label: "!=", arity: 2, desc: "Not equal" },
          { key: "lt", label: "<", arity: 2, desc: "Less than" },
          { key: "lte", label: "<=", arity: 2, desc: "Less than or equal" },
          { key: "gt", label: ">", arity: 2, desc: "Greater than" },
          { key: "gte", label: ">=", arity: 2, desc: "Greater than or equal" },
          {
            key: "in",
            label: "IN",
            arity: 2,
            desc: "Value in set (comma separated)",
          },
          {
            key: "not_in",
            label: "NOT IN",
            arity: 2,
            desc: "Value not in set",
          },
          {
            key: "between",
            label: "BETWEEN",
            arity: 3,
            desc: "Between two values",
          },
          {
            key: "like",
            label: "LIKE",
            arity: 2,
            desc: "SQL LIKE (use % as wildcard)",
          },
          {
            key: "not_like",
            label: "NOT LIKE",
            arity: 2,
            desc: "SQL NOT LIKE",
          },
          { key: "is_null", label: "IS NULL", arity: 1, desc: "Is null" },
          {
            key: "is_not_null",
            label: "IS NOT NULL",
            arity: 1,
            desc: "Is not null",
          },
          {
            key: "regex",
            label: "REGEX",
            arity: 2,
            desc: "Regular expression match",
          },
          {
            key: "contains",
            label: "CONTAINS",
            arity: 2,
            desc: "String contains",
          },
          {
            key: "starts",
            label: "STARTS WITH",
            arity: 2,
            desc: "String starts with",
          },
          {
            key: "ends",
            label: "ENDS WITH",
            arity: 2,
            desc: "String ends with",
          },
          // arithmetic
          { key: "add", label: "+", arity: 2, desc: "Addition" },
          { key: "sub", label: "-", arity: 2, desc: "Subtraction" },
          { key: "mul", label: "*", arity: 2, desc: "Multiplication" },
          { key: "div", label: "/", arity: 2, desc: "Division" },
          // aggregates (used in group/aggregate contexts)
          { key: "sum", label: "SUM()", arity: 1, desc: "Sum aggregate" },
          { key: "count", label: "COUNT()", arity: 1, desc: "Count aggregate" },
          { key: "avg", label: "AVG()", arity: 1, desc: "Average aggregate" },
          { key: "min", label: "MIN()", arity: 1, desc: "Minimum aggregate" },
          { key: "max", label: "MAX()", arity: 1, desc: "Maximum aggregate" },
        ];
      }

      // Visual Rule Builder modal
      async function showRuleBuilder(title, initialRules) {
        const root = document.createElement("div");
        root.style.display = "flex";
        root.style.flexDirection = "column";
        root.style.gap = "8px";
        const list = document.createElement("div");
        list.style.display = "flex";
        list.style.flexDirection = "column";
        list.style.gap = "8px";

        let rules = Array.isArray(initialRules)
          ? JSON.parse(JSON.stringify(initialRules))
          : [];

        function renderList() {
          list.innerHTML = "";
          rules.forEach((r, idx) => {
            const row = document.createElement("div");
            row.style.display = "flex";
            row.style.gap = "8px";
            row.style.alignItems = "center";
            const join = document.createElement("select");
            join.innerHTML =
              '<option value="AND">AND</option><option value="OR">OR</option>';
            join.value = r.join || (idx === 0 ? "AND" : "AND");
            join.addEventListener("change", () => {
              r.join = join.value;
            });
            const tableSel = document.createElement("select");
            tableSel.style.minWidth = "120px";
            const tables = Object.keys(globalThis.__lastDbTables || {});
            tableSel.innerHTML =
              '<option value="">(table)</option>' +
              tables
                .map(
                  (t) =>
                    `<option value="${t}" ${
                      r.table === t ? "selected" : ""
                    }>${t}</option>`
                )
                .join("");
            tableSel.addEventListener("change", () => {
              r.table = tableSel.value;
              r.column = "";
              renderList();
            });
            const colSel = document.createElement("select");
            colSel.style.minWidth = "120px";
            const cols =
              globalThis.__lastDbTables && globalThis.__lastDbTables[r.table]
                ? (globalThis.__lastDbTables[r.table].columns || []).map(
                    (c) => c.name || c
                  )
                : [];
            colSel.innerHTML =
              '<option value="">(column)</option>' +
              cols
                .map(
                  (c) =>
                    `<option value="${c}" ${
                      r.column === c ? "selected" : ""
                    }>${c}</option>`
                )
                .join("");
            colSel.addEventListener("change", () => {
              r.column = colSel.value;
            });
            const opSel = document.createElement("select");
            const ops = getAvailableOperators();
            opSel.innerHTML = ops
              .map(
                (o) =>
                  `<option value="${o.key}" ${
                    r.operator === o.key ? "selected" : ""
                  }>${o.label}</option>`
              )
              .join("");
            opSel.addEventListener("change", () => {
              r.operator = opSel.value;
            });
            // optional action attach selector (choose an action from taxonomy)
            const actionSel = document.createElement("select");
            actionSel.style.minWidth = "160px";
            try {
              const acts = taxonomy && taxonomy.actions ? taxonomy.actions : {};
              actionSel.innerHTML =
                '<option value="">(no action)</option>' +
                Object.keys(acts)
                  .map(
                    (a) =>
                      `<option value="${a}" ${
                        r.action === a ? "selected" : ""
                      }>${acts[a].name || a}</option>`
                  )
                  .join("");
            } catch (e) {
              actionSel.innerHTML = '<option value="">(no action)</option>';
            }
            actionSel.addEventListener("change", () => {
              r.action = actionSel.value;
            });
            const val = document.createElement("input");
            val.type = "text";
            val.placeholder = "value";
            val.value = r.value || "";
            val.addEventListener("input", () => {
              r.value = val.value;
            });
            const btnDel = document.createElement("button");
            btnDel.className = "btn btn-danger";
            btnDel.textContent = "Delete";
            btnDel.addEventListener("click", () => {
              rules.splice(idx, 1);
              renderList();
            });
            row.appendChild(join);
            row.appendChild(tableSel);
            row.appendChild(colSel);
            row.appendChild(opSel);
            row.appendChild(actionSel);
            row.appendChild(val);
            row.appendChild(btnDel);
            list.appendChild(row);
          });
        }

        const addBtn = document.createElement("button");
        addBtn.className = "btn btn-primary";
        addBtn.textContent = "Add Rule";
        addBtn.addEventListener("click", () => {
          rules.push({
            join: rules.length ? "AND" : "AND",
            table: "",
            column: "",
            operator: "eq",
            value: "",
            action: "",
          });
          renderList();
        });

        root.appendChild(list);
        root.appendChild(addBtn);

        // populate lastDbTables global for quick access to schema; attempt fetch if missing
        if (!globalThis.__lastDbTables) {
          try {
            const r = await fetch("/api/db/schema");
            if (r.ok) {
              const d = await r.json();
              globalThis.__lastDbTables = d.tables || {};
            } else globalThis.__lastDbTables = {};
          } catch (e) {
            console.warn(e);
            globalThis.__lastDbTables = {};
          }
        }

        // ensure taxonomy (actions) is loaded so action selector can populate
        if (!taxonomy) {
          try {
            await loadTaxonomy();
          } catch (e) {
            console.warn("loadTaxonomy failed for rule builder", e);
          }
        }

        renderList();

        const res = await _createModal({
          title: title || "Rule Builder",
          bodyEl: root,
          onConfirm: () => rules,
          confirmText: "Save Rules",
        });
        return res === true ? rules : res === null ? null : rules;
      }

      // Module mapping editor: loads /api/module-mapping and allows editing/saving
      async function openModuleMappingForAction(nodeId) {
        const nd = nodes.find((n) => n.id === nodeId);
        if (!nd) return showToast("Node not found", "error");
        // try to determine default module name from taxonomy action target
        const actionKey = nd.data.action;
        let defaultModule = actionKey || "";
        try {
          // taxonomy.actions is keyed by id; allow nd.data.action to be either id or name
          if (taxonomy && taxonomy.actions) {
            if (taxonomy.actions[actionKey]) {
              defaultModule =
                taxonomy.actions[actionKey].target ||
                taxonomy.actions[actionKey].module ||
                actionKey;
            } else {
              // try to find an action by name matching the stored value
              const match = Object.keys(taxonomy.actions).find(
                (k) => (taxonomy.actions[k] && taxonomy.actions[k].name) === actionKey
              );
              if (match) {
                const a = taxonomy.actions[match];
                defaultModule = a.target || a.module || actionKey;
              }
            }
          }
        } catch (e) {
          console.warn(e);
        }

        // build modal body
        const body = document.createElement("div");
        body.style.display = "flex";
        body.style.flexDirection = "column";
        body.style.gap = "8px";

        const row = document.createElement("div");
        row.style.display = "flex";
        row.style.gap = "8px";
        const lbl = document.createElement("label");
        lbl.textContent = "Module (navigation.nav)";
        lbl.style.minWidth = "160px";
        const input = document.createElement("input");
        input.type = "text";
        input.value = defaultModule;
        input.style.flex = "1";
        input.className = "form-input";
        row.appendChild(lbl);
        row.appendChild(input);
        body.appendChild(row);

        const info = document.createElement("div");
        info.textContent = "Loading mapping...";
        info.style.color = "#657786";
        body.appendChild(info);

        const container = document.createElement("div");
        container.style.display = "flex";
        container.style.flexDirection = "column";
        container.style.gap = "8px";
        container.style.marginTop = "6px";
        body.appendChild(container);

        const res = await _createModal({
          title: "Edit Module Mapping",
          bodyEl: body,
          confirmText: "Save",
          cancelText: "Close",
          onConfirm: async () => {
            showToast(
              "Module mapping persistence is deprecated and disabled",
              "error"
            );
            return null;
          },
        });

        // when modal opens, load mapping for provided module
        async function loadForModule(name) {
          container.innerHTML = "";
          info.textContent = "Loading mapping for " + name + " ...";
          try {
            // module-mapping is deprecated; loading persisted mappings removed
            info.textContent = "Module mapping is deprecated and disabled.";
            return;
          } catch (e) {
            console.warn(e);
          }
          const mr = document.createElement("div");
          mr.className = "mapping-row";
          mr.setAttribute("data-col", col);
          mr.style.display = "flex";
          mr.style.gap = "8px";
          mr.style.alignItems = "center";
          mr.style.padding = "6px 0";
          const lbl = document.createElement("div");
          lbl.textContent = col;
          lbl.style.minWidth = "140px";
          lbl.style.fontWeight = "600";
          const plug = document.createElement("select");
          plug.className = "plug-select form-select";
          plug.style.minWidth = "150px";
          const emptyOpt = document.createElement("option");
          emptyOpt.value = "";
          emptyOpt.textContent = "(none)";
          plug.appendChild(emptyOpt);
          (d.plugins || []).forEach((pn) => {
            const o = document.createElement("option");
            o.value = pn;
            o.textContent = pn;
            if (d.pluginMappings && d.pluginMappings[col] === pn)
              o.selected = true;
            plug.appendChild(o);
          });
          const ftype = document.createElement("select");
          ftype.className = "ftype-select form-select";
          ftype.style.minWidth = "150px";
          [
            "text",
            "number",
            "select",
            "textarea",
            "date",
            "datetime-local",
          ].forEach((t) => {
            const o = document.createElement("option");
            o.value = t;
            o.textContent = t;
            if (d.fieldTypeMappings && d.fieldTypeMappings[col] === t)
              o.selected = true;
            ftype.appendChild(o);
          });
          const freqWrap = document.createElement("label");
          freqWrap.style.display = "flex";
          freqWrap.style.alignItems = "center";
          freqWrap.style.gap = "6px";
          const freq = document.createElement("input");
          freq.type = "checkbox";
          freq.className = "freq-checkbox";
          if (d.fieldRequiredMappings && d.fieldRequiredMappings[col])
            freq.checked = true;
          const freqLbl = document.createElement("span");
          freqLbl.textContent = "Required";
          freqWrap.appendChild(freq);
          freqWrap.appendChild(freqLbl);
          const fopts = document.createElement("input");
          fopts.className = "fopts-input form-input";
          fopts.placeholder = "opt1,opt2";
          fopts.style.minWidth = "160px";
          if (d.fieldOptionsMappings && d.fieldOptionsMappings[col])
            fopts.value = d.fieldOptionsMappings[col];
          const fetchBtn = document.createElement("button");
          fetchBtn.className = "btn btn-secondary";
          fetchBtn.textContent = "Fetch DB Values";
          fetchBtn.addEventListener("click", async () => {
            showToast(
              "Fetching DB values via module-mapping is deprecated",
              "info"
            );
          });

          mr.appendChild(lbl);
          mr.appendChild(plug);
          mr.appendChild(ftype);
          mr.appendChild(freqWrap);
          mr.appendChild(fopts);
          mr.appendChild(fetchBtn);
          container.appendChild(mr);
        }

        // initial load
        if (input.value && input.value.trim())
          await loadForModule(input.value.trim());

        // when module input changes, reload mapping
        input.addEventListener("change", async () => {
          const v = input.value && input.value.trim();
          if (v) await loadForModule(v);
        });
      }
    </script>
    <script>
      // Material tab helpers: ink ripple and indicator initialization
      (function () {
        function createRipple(ev) {
          const btn = ev.currentTarget;
          const rect = btn.getBoundingClientRect();
          const size = Math.max(rect.width, rect.height) * 0.6;
          const ripple = document.createElement('span');
          ripple.className = 'ripple';
          ripple.style.width = ripple.style.height = size + 'px';
          const x = ev.clientX - rect.left - size / 2;
          const y = ev.clientY - rect.top - size / 2;
          ripple.style.left = x + 'px';
          ripple.style.top = y + 'px';
          btn.appendChild(ripple);
          // cleanup after animation
          setTimeout(() => {
            ripple.remove();
          }, 700);
        }

        function positionIndicatorForBtn(btn) {
          try {
            const tabsEl = document.querySelector('.tabs');
            if (!tabsEl) return;
            let md = tabsEl.querySelector('.md-indicator');
            if (!md) {
              md = document.createElement('div');
              md.className = 'md-indicator';
              tabsEl.appendChild(md);
            }
            if (!btn) { md.style.opacity = '0'; return; }
            const tabRect = btn.getBoundingClientRect();
            const tabsRect = tabsEl.getBoundingClientRect();
            const left = tabRect.left - tabsRect.left;
            md.style.transform = `translateX(${left}px)`;
            md.style.width = tabRect.width + 'px';
            md.style.opacity = '1';
          } catch (e) {
            console.warn('positionIndicatorForBtn', e);
          }
        }

        function attachTabBehavior() {
          const tabs = document.querySelectorAll('.tabs .tab');
          tabs.forEach((t) => {
            // only attach once
            if (t.__md_attached) return;
            t.addEventListener('pointerdown', createRipple);
            // reposition indicator on pointerup (after active class applied by switchTab)
            t.addEventListener('pointerup', () => setTimeout(() => positionIndicatorForBtn(t), 40));
            t.__md_attached = true;
          });
          // initial position
          const active = document.querySelector('.tabs .tab.active');
          if (active) positionIndicatorForBtn(active);
        }

        // attach handlers on DOM ready and whenever tabs are added dynamically
        document.addEventListener('DOMContentLoaded', attachTabBehavior);
        // also observe tabs container for changes (lazy-loaded fragments may add tabs)
        const tabsContainer = document.querySelector('.tabs');
        if (tabsContainer) {
          const mo = new MutationObserver(() => attachTabBehavior());
          mo.observe(tabsContainer, { childList: true, subtree: true });
        }
        window.addEventListener('resize', () => {
          const active = document.querySelector('.tabs .tab.active');
          if (active) positionIndicatorForBtn(active);
        });
      })();
    </script>
      <script>
        // Header hide/fade tied to scroll percentage (RAF-driven, smooth interpolation)
        (function () {
          const header = document.querySelector('.header');
          if (!header) return;

          const prefersReduced = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

          // Reduced-motion fallback: simple show/hide using class (less motion)
          if (prefersReduced) {
            let lastPercent = 0;
            let ticking = false;
            const DELTA_PERCENT = 1.5;
            const HIDE_PERCENT = 6;
            function onScrollReduced() {
              if (!ticking) {
                window.requestAnimationFrame(() => {
                  const currentY = window.scrollY || 0;
                  const docHeight = Math.max(document.documentElement.scrollHeight, document.body.scrollHeight || 0);
                  const scrollable = Math.max(docHeight - window.innerHeight, 0);
                  const percent = scrollable > 0 ? (currentY / scrollable) * 100 : 0;
                  const scrolledDown = percent > lastPercent + DELTA_PERCENT && percent > HIDE_PERCENT;
                  const scrolledUp = percent < lastPercent - DELTA_PERCENT || percent <= 0;
                  if (scrolledDown) header.classList.add('header-hidden');
                  else if (scrolledUp) header.classList.remove('header-hidden');
                  lastPercent = percent;
                  ticking = false;
                });
                ticking = true;
              }
            }
            window.addEventListener('scroll', onScrollReduced, { passive: true });
            window.addEventListener('focusin', () => header.classList.remove('header-hidden'));
            window.addEventListener('resize', () => header.classList.remove('header-hidden'));
            return;
          }

          // Tight binding parameters
          const baseBlur = 6; // px when fully visible
          const maxBlur = 20; // px when fully hidden
          const startPercent = 30; // percent at which fading begins
          const endPercent = 40; // percent at which header is fully hidden

          // Disable CSS transition so we can tightly control visuals per-pixel
          header.style.transition = 'none';

          let ticking = false;

          function clamp(v, a, b) { return Math.min(b, Math.max(a, v)); }

          function applyVisualsFromPercent(percent) {
            // normalized t in [0,1]
            let t = 0;
            if (percent <= startPercent) t = 0;
            else if (percent >= endPercent) t = 1;
            else t = (percent - startPercent) / (endPercent - startPercent);
            t = clamp(t, 0, 1);

            // apply visuals proportional to t
            const opacity = 1 - t;
            const blur = baseBlur + (maxBlur - baseBlur) * t;
            const translateY = -t * 100; // in percent

            header.style.opacity = String(opacity);
            header.style.backdropFilter = `blur(${blur}px) saturate(120%)`;
            header.style.transform = `translateY(${translateY}%)`;
            header.style.pointerEvents = t > 0.98 ? 'none' : 'auto';
          }

          function onScroll() {
            if (!ticking) {
              window.requestAnimationFrame(() => {
                const currentY = window.scrollY || 0;
                const docHeight = Math.max(document.documentElement.scrollHeight, document.body.scrollHeight || 0);
                const scrollable = Math.max(docHeight - window.innerHeight, 0);
                const percent = scrollable > 0 ? (currentY / scrollable) * 100 : 0;
                applyVisualsFromPercent(percent);
                ticking = false;
              });
              ticking = true;
            }
          }

          // listen to window scroll (page-level)
          window.addEventListener('scroll', onScroll, { passive: true });

          // Also listen to internal tab content scroll containers (e.g. .content-area)
          try {
            const innerScrollers = Array.from(document.querySelectorAll('.content-area'));
            innerScrollers.forEach((scroller) => {
              scroller.addEventListener('scroll', () => {
                if (!ticking) {
                  ticking = true;
                  window.requestAnimationFrame(() => {
                    const currentY = scroller.scrollTop || 0;
                    const scrollable = Math.max(scroller.scrollHeight - scroller.clientHeight, 0);
                    const percent = scrollable > 0 ? (currentY / scrollable) * 100 : 0;
                    applyVisualsFromPercent(percent);
                    ticking = false;
                  });
                }
              }, { passive: true });
            });
          } catch (e) { /* ignore */ }
          window.addEventListener('focusin', () => {
            // restore fully visible on focus
            header.style.opacity = '1';
            header.style.transform = 'translateY(0%)';
            header.style.backdropFilter = `blur(${baseBlur}px) saturate(120%)`;
            header.style.pointerEvents = 'auto';
          });
          window.addEventListener('resize', () => onScroll());

          // initial apply
          onScroll();
        })();
      </script>
  </body>
</html>
