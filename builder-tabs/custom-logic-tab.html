<div id="custom-logic-panel" class="tab-panel">
  <div class="toolbar">
    <button class="btn btn-secondary" onclick="loadCustomLogics()">
      üîÑ Refresh
    </button>
    <button
      id="toolbar-save-logic"
      class="btn btn-primary"
      style="margin-left: 8px"
      onclick="saveCustomLogic()"
    >
      üíæ Save Logic
    </button>
  </div>
  <div class="main" style="flex: 1; display: flex; gap: 12px; min-height: 0">
    <!-- Left: Logic List -->
    <div
      style="
        width: 280px;
        display: flex;
        flex-direction: column;
        border-right: 1px solid #e1e8ed;
        padding-right: 12px;
      "
    >
      <h3 style="margin: 0 0 12px 0; font-size: 0.95rem; color: #14171a">
        Custom Logic Functions
      </h3>
      <div
        id="custom-logic-list"
        style="flex: 1; overflow-y: auto; min-height: 0"
      ></div>
    </div>

    <!-- Right: Editor -->
    <div
      style="
        flex: 1;
        display: flex;
        flex-direction: column;
        min-height: 0;
        overflow: auto;
      "
    >
      <div id="custom-logic-editor" style="display: none">
        <div style="margin-bottom: 16px">
          <label style="display: block; margin-bottom: 4px; font-weight: 600"
            >Name</label
          >
          <input
            type="text"
            id="logic-name"
            placeholder="e.g., Calculate Invoice Total"
            style="
              width: 100%;
              padding: 8px;
              border: 1px solid #e1e8ed;
              border-radius: 4px;
            "
          />
        </div>

        <div style="margin-bottom: 16px">
          <div
            style="
              display: flex;
              justify-content: space-between;
              align-items: center;
              margin-bottom: 4px;
            "
          >
            <label style="font-weight: 600">Description</label>
            <button
              class="btn btn-primary"
              onclick="aiGenerateLogicCode()"
              style="font-size: 0.85rem; padding: 4px 12px"
              title="AI-powered code generation based on description and input variables"
            >
              ‚ú® AI Generate Code
            </button>
          </div>
          <textarea
            id="logic-description"
            rows="3"
            placeholder="Describe what this logic does... (AI will use this to generate JavaScript code)"
            style="
              width: 100%;
              padding: 8px;
              border: 1px solid #e1e8ed;
              border-radius: 4px;
            "
          ></textarea>
          <div style="font-size: 0.75rem; color: #657786; margin-top: 4px">
            üí° Tip: Describe your logic clearly, add input variables below, then
            click "AI Generate Code" for automatic JavaScript generation
          </div>
        </div>

        <!-- Input Sources -->
        <div style="margin-bottom: 16px">
          <label style="display: block; margin-bottom: 8px; font-weight: 600"
            >Input Sources</label
          >
          <div style="display: flex; gap: 8px; margin-bottom: 8px">
            <button
              class="btn btn-secondary"
              onclick="showEventInputSelector()"
              style="font-size: 0.85rem"
            >
              + Add Event Input
            </button>
            <button
              class="btn btn-secondary"
              onclick="showActionTestRunner()"
              style="font-size: 0.85rem"
              title="Test run an action and select result fields using parser paths"
            >
              üß™ Test Action & Select Fields
            </button>
            <button
              class="btn btn-secondary"
              onclick="showActionInputSelector()"
              style="font-size: 0.85rem"
            >
              + Add Action Input
            </button>
          </div>
          <div
            id="logic-inputs-list"
            style="
              border: 1px solid #e1e8ed;
              border-radius: 4px;
              padding: 8px;
              min-height: 80px;
              background: #f8f9fa;
            "
          >
            <em style="color: #657786; font-size: 0.85rem"
              >No inputs defined yet</em
            >
          </div>
        </div>

        <!-- Function Editor -->
        <div style="margin-bottom: 16px">
          <label style="display: block; margin-bottom: 4px; font-weight: 600"
            >Function Code</label
          >
          <div
            style="
              font-size: 0.75rem;
              color: #657786;
              margin-bottom: 6px;
              background: #fff3cd;
              padding: 6px 8px;
              border-radius: 4px;
            "
          >
            Write a JavaScript function that returns a value. Available
            variables: <code id="available-vars">none</code>
          </div>
          <!-- Enhanced Variable Preview with Input Shape Schema -->
          <div
            id="variable-preview"
            style="margin-top: 8px; font-size: 0.9rem; color: #333"
          >
            <div
              style="
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 6px;
              "
            >
              <div style="font-weight: 600; color: #14171a">
                Input Shape & Preview
              </div>
              <button
                class="btn btn-secondary"
                onclick="refreshInputShapePreview()"
                style="font-size: 0.75rem; padding: 2px 8px"
                title="Refresh preview from current inputs"
              >
                üîÑ Refresh
              </button>
            </div>

            <!-- Input Shape Schema -->
            <div
              style="
                background: #fff8e8;
                border: 1px solid #f4d03f;
                padding: 8px;
                border-radius: 4px;
                margin-bottom: 8px;
              "
            >
              <div
                style="
                  font-weight: 600;
                  font-size: 0.85rem;
                  color: #856404;
                  margin-bottom: 4px;
                "
              >
                üìã Input Structure
              </div>
              <pre
                id="input-shape-schema"
                style="
                  margin: 0;
                  font-size: 0.75rem;
                  color: #333;
                  background: #fffbf0;
                  padding: 6px;
                  border-radius: 4px;
                  overflow-x: auto;
                  max-height: 200px;
                "
              >
No inputs defined</pre
              >
            </div>

            <!-- Variable Preview List -->
            <div
              style="
                background: #e8f5e9;
                border: 1px solid #4caf50;
                padding: 8px;
                border-radius: 4px;
              "
            >
              <div
                style="
                  font-weight: 600;
                  font-size: 0.85rem;
                  color: #2e7d32;
                  margin-bottom: 4px;
                "
              >
                üëÅÔ∏è Sample Values Preview
              </div>
              <div
                id="variable-preview-list"
                style="
                  background: #f1f8f4;
                  border: 1px solid #c8e6c9;
                  padding: 8px;
                  border-radius: 4px;
                  color: #333;
                  max-height: 250px;
                  overflow-y: auto;
                "
              >
                No preview available
              </div>
            </div>

            <!-- Type Validation Status -->
            <div
              id="input-validation-status"
              style="
                margin-top: 8px;
                padding: 6px;
                border-radius: 4px;
                font-size: 0.8rem;
                display: none;
              "
            >
              <span id="validation-icon"></span>
              <span id="validation-message"></span>
            </div>
          </div>
          <textarea
            id="logic-function"
            rows="12"
            placeholder="// Example:&#10;return inputs.eventField + inputs.actionResult;"
            readonly
            title="Auto-generated code (read-only)"
            style="
              width: 100%;
              padding: 8px;
              border: 1px solid #e1e8ed;
              border-radius: 4px;
              font-family: &quot;Courier New&quot;, monospace;
              font-size: 0.85rem;
              background: #f8f9fa;
              cursor: not-allowed;
            "
          ></textarea>
          <div style="display: flex; gap: 8px; margin-top: 8px">
            <button
              id="inline-save-logic"
              class="btn btn-primary"
              onclick="saveCustomLogic()"
            >
              üíæ Save Logic
            </button>
            <button class="btn btn-secondary" onclick="clearLogicEditor()">
              Clear Editor
            </button>
          </div>
        </div>

        <!-- Test Section -->
        <div style="margin-bottom: 16px">
          <label style="display: block; margin-bottom: 4px; font-weight: 600"
            >Test Function</label
          >
          <textarea
            id="logic-test-data"
            rows="4"
            placeholder='{"eventField": 100, "actionResult": 50}'
            style="
              width: 100%;
              padding: 8px;
              border: 1px solid #e1e8ed;
              border-radius: 4px;
              font-size: 0.85rem;
              margin-bottom: 8px;
            "
          ></textarea>
          <button
            class="btn btn-primary"
            onclick="testCustomLogic()"
            style="margin-right: 8px"
          >
            Test Function
          </button>
          <div
            id="logic-test-result"
            style="
              margin-top: 8px;
              padding: 8px;
              border-radius: 4px;
              display: none;
            "
          ></div>
        </div>

        <!-- Actions -->
        <div
          style="
            display: flex;
            gap: 8px;
            padding-top: 12px;
            border-top: 1px solid #e1e8ed;
          "
        >
          <button class="btn btn-primary" onclick="saveCustomLogic()">
            Save Logic
          </button>
          <button class="btn btn-secondary" onclick="clearLogicEditor()">
            Clear
          </button>
          <button
            class="btn btn-danger"
            onclick="deleteCurrentLogic()"
            id="delete-logic-btn"
            style="margin-left: auto; display: none"
          >
            Delete
          </button>
        </div>
      </div>

      <div
        id="custom-logic-empty-state"
        style="
          flex: 1;
          display: flex;
          align-items: center;
          justify-content: center;
          color: #657786;
        "
      >
        <div style="text-align: center">
          <div style="font-size: 3rem; margin-bottom: 1rem; opacity: 0.5">
            ‚öôÔ∏è
          </div>
          <div
            style="font-size: 1.1rem; font-weight: 600; margin-bottom: 0.5rem"
          >
            No Custom Logic Selected
          </div>
          <div style="font-size: 0.9rem">
            Create or select a custom logic function to get started
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
  // Runtime config for AI integration
  async function ensureRuntimeConfig() {
    if (window.__RUNTIME_CONFIG__) {
      window.RUNTIME_CONFIG = window.__RUNTIME_CONFIG__;
      return window.RUNTIME_CONFIG;
    }
    try {
      const res = await fetch("/runtime-config");
      const cfg = await res.json();
      window.RUNTIME_CONFIG = cfg;
      return cfg;
    } catch (e) {
      console.warn("Could not load runtime config, using defaults", e);
      window.RUNTIME_CONFIG = {
        ai: { mode: "proxy", directUrl: "/large" },
      };
      return window.RUNTIME_CONFIG;
    }
  }

  // Custom Logic state
  let customLogics = [];
  let currentLogic = null;
  let logicInputs = [];

  window.initCustomLogicTab = async function () {
    try {
      await ensureRuntimeConfig();
      // Prefer the active workflow from the Workflow Editor (single source of truth)
      if (globalThis.currentWorkflow && globalThis.currentWorkflow.id) {
        await loadWorkflowLogics(globalThis.currentWorkflow.id);
      } else {
        const container = document.getElementById("custom-logic-list");
        if (container)
          container.innerHTML =
            '<div style="padding: 12px; color: #657786; font-size: 0.85rem;">Select a workflow in the Workflows toolbar to view its custom logic.</div>';
      }
      await loadAvailableEvents();
      await loadAvailableActions();
    } catch (e) {
      console.warn("initCustomLogicTab error", e);
    }
  };

  async function loadWorkflowsForLogics() {
    try {
      // Keep a cached list available for internal use, but do not render a selector here.
      const res = await fetch("/api/unified-workflows");
      const data = await res.json();
      if (data && data.ok)
        globalThis.__availableWorkflows = data.workflows || [];
    } catch (e) {
      console.warn(e);
    }
  }

  async function loadWorkflowLogics(workflowId) {
    const container = document.getElementById("custom-logic-list");
    if (!workflowId) {
      container.innerHTML =
        '<div style="padding: 12px; color: #657786; font-size: 0.85rem;">Select a workflow to view its custom logic nodes (add nodes in the workflow editor).</div>';
      return;
    }
    container.innerHTML =
      '<div style="padding: 12px; color: #657786; font-size: 0.85rem;">Loading workflow components...</div>';
    try {
      const res = await fetch(
        `/api/unified-workflows/${encodeURIComponent(workflowId)}/components`,
      );
      const data = await res.json();
      if (!data || !data.ok) {
        container.innerHTML =
          '<div style="padding: 12px; color: #657786; font-size: 0.85rem;">Failed to load components</div>';
        return;
      }
      const logics = Object.values(data.logics || {});
      if (!logics.length) {
        container.innerHTML =
          '<div style="padding: 12px; color: #657786; font-size: 0.85rem;">No Custom Logic defined for this workflow. Add Custom Logic nodes to the workflow canvas to create them.</div>';
        return;
      }
      container.innerHTML = logics
        .map(
          (l) =>
            `\n        <div class="list-item" style="margin-bottom:8px;">\n          <div style="font-weight:600">${l.name || l.id} <span class="muted">${l.id}</span></div>\n          <div style="font-size:0.85rem;color:#657786">${l.description || ""}</div>\n          <div style="margin-top:6px; display:flex; gap:8px">\n            <button class="btn btn-secondary" onclick="selectLogic('${l.id}')">Open</button>\n            <button class="btn btn-danger" onclick="deleteLogic('${l.id}')">Delete</button>\n          </div>\n        </div>\n      `,
        )
        .join("");
      // Auto-open first logic item for convenience
      try {
        if (logics && logics.length && typeof selectLogic === "function") {
          const first = logics[0];
          setTimeout(() => {
            try {
              selectLogic(first.id);
            } catch (e) {
              /* ignore */
            }
          }, 60);
        }
      } catch (e) {
        /* ignore */
      }
    } catch (e) {
      console.warn(e);
      container.innerHTML =
        '<div style="padding: 12px; color: #657786; font-size: 0.85rem;">Error loading components</div>';
    }
  }

  async function loadCustomLogics() {
    // Try API first, fall back to static config file so the editor works
    try {
      const res = await fetch("/api/custom-logic");
      if (res.ok) {
        const data = await res.json();
        if (data && data.ok) {
          customLogics = data.logics || [];
          renderLogicsList();
          return;
        }
      }
    } catch (e) {
      // ignore and try fallback
    }

    // Fallback: load from config metadata file (served statically)
    try {
      const res2 = await fetch("/config/metadata/custom-logic.json");
      if (res2.ok) {
        const arr = await res2.json();
        if (Array.isArray(arr)) {
          customLogics = arr;
          renderLogicsList();
          return;
        }
      }
    } catch (e) {
      console.error("Failed to load custom logics from fallback:", e);
    }

    // If all fails, show empty state
    customLogics = [];
    renderLogicsList();
  }

  function renderLogicsList() {
    const list = document.getElementById("custom-logic-list");
    if (!customLogics || customLogics.length === 0) {
      list.innerHTML =
        '<div style="padding: 12px; color: #657786; font-size: 0.85rem;">No custom logic functions yet</div>';
      return;
    }

    list.innerHTML = customLogics
      .map(
        (logic) => `
      <div class="list-item" onclick="selectLogic('${
        logic.id
      }')" style="margin-bottom: 8px; cursor: pointer;">
        <div style="font-weight: 600; color: #14171a; font-size: 0.9rem;">${
          logic.name
        }</div>
        <div style="font-size: 0.75rem; color: #657786; margin-top: 2px;">${
          logic.description || ""
        }</div>
        <div style="font-size: 0.7rem; color: #657786; margin-top: 4px;">
          Inputs: ${(logic.inputs || []).length} | Updated: ${new Date(
            logic.updatedAt || Date.now(),
          ).toLocaleDateString()}
        </div>
      </div>
    `,
      )
      .join("");
  }

  function addCustomLogic() {
    currentLogic = null;
    logicInputs = [];
    clearLogicEditor();
    showEditor();
  }

  function selectLogic(id) {
    const logic = customLogics.find((l) => l.id === id);
    if (!logic) return;

    currentLogic = logic;
    logicInputs = logic.inputs || [];

    document.getElementById("logic-name").value = logic.name || "";
    document.getElementById("logic-description").value =
      logic.description || "";
    document.getElementById("logic-function").value = logic.functionCode || "";

    renderInputsList();
    updateAvailableVars();
    showEditor();
    document.getElementById("delete-logic-btn").style.display = "block";

    // If exampleContext is provided, prefill the test data textarea
    try {
      const ctx = logic.exampleContext || logic.exampleContextUI || {};

      // Helper to attempt multiple key forms for lookups
      const getActionCtx = (actionsObj, inp) => {
        if (!actionsObj) return null;
        const candidates = [];
        const aid = inp.actionId || inp.actionName || inp.source;
        const actVar = normalizeVarName(aid);
        const parserVar = inp.parserVarName
          ? normalizeVarName(inp.parserVarName)
          : null;
        // try original id
        candidates.push(aid);
        // underscore variant
        candidates.push(aid && aid.replace(/-/g, "_"));
        // normalized id
        candidates.push(actVar);
        // parser var as top-level under actions[aid]
        // also check UI-style keys
        for (const c of candidates) {
          if (!c) continue;
          if (actionsObj[c] !== undefined) return actionsObj[c];
        }
        return null;
      };

      const getEventCtx = (eventsObj, inp) => {
        if (!eventsObj) return null;
        const eid = inp.eventId || inp.eventName || inp.source;
        const evVar = normalizeVarName(inp.eventName || inp.eventId || eid);
        const candidates = [
          eid,
          eid && eid.replace(/-/g, "_"),
          evVar,
          inp.eventName,
          inp.eventId,
        ];
        for (const c of candidates) {
          if (!c) continue;
          if (eventsObj[c] !== undefined) return eventsObj[c];
        }
        return null;
      };

      if (logic.exampleContext) {
        const testInputs = {};
        const extract = (obj, path) => {
          if (!path) return obj;
          const parts = path.split(".");
          let cur = obj;
          for (const p of parts) {
            const m = p.match(/^(\w+)\[(\d+)\]$/);
            if (m) {
              cur = cur && cur[m[1]] && cur[m[1]][parseInt(m[2])];
            } else {
              cur = cur && cur[p];
            }
            if (cur === undefined) return null;
          }
          return cur === undefined ? null : cur;
        };

        (logic.inputs || []).forEach((inp) => {
          if (inp.type === "event") {
            const ev = getEventCtx(ctx.events, inp) || {};
            const evName = inp.eventName || inp.eventId || inp.source;
            testInputs[evName] = testInputs[evName] || {};
            if (!inp.field) {
              testInputs[evName] = ev;
            } else {
              testInputs[evName][inp.field] = extract(ev, inp.field || "");
            }
          } else if (inp.type === "action") {
            const act = getActionCtx(ctx.actions, inp) || null;
            testInputs.actions = testInputs.actions || {};
            const aid = inp.actionId || inp.actionName || inp.source;
            if (Array.isArray(act) && act.length > 0) {
              if (!inp.field) testInputs.actions[aid] = act;
              else testInputs.actions[aid] = extract(act[0], inp.field || "");
            } else {
              if (!inp.field) testInputs.actions[aid] = act;
              else testInputs.actions[aid] = extract(act, inp.field || "");
            }
          }
        });

        document.getElementById("logic-test-data").value = JSON.stringify(
          testInputs,
          null,
          2,
        );
      }
    } catch (e) {
      console.warn("Failed to prefill test data from exampleContext", e);
    }
  }

  function showEditor() {
    const editor = document.getElementById("custom-logic-editor");
    const empty = document.getElementById("custom-logic-empty-state");
    if (editor) editor.style.display = "block";
    if (empty) empty.style.display = "none";
    // ensure editor is visible in scroll container
    try {
      editor.scrollIntoView({ behavior: "smooth", block: "nearest" });
      const name = document.getElementById("logic-name");
      if (name) {
        name.focus();
      }
    } catch (e) {}
  }

  function clearLogicEditor() {
    currentLogic = null;
    logicInputs = [];
    document.getElementById("logic-name").value = "";
    document.getElementById("logic-description").value = "";
    document.getElementById("logic-function").value = "";
    document.getElementById("logic-test-data").value = "";
    document.getElementById("logic-test-result").style.display = "none";
    document.getElementById("delete-logic-btn").style.display = "none";
    renderInputsList();
    updateAvailableVars();
  }

  function renderInputsList() {
    const container = document.getElementById("logic-inputs-list");
    if (!logicInputs || logicInputs.length === 0) {
      container.innerHTML =
        '<em style="color: #657786; font-size: 0.85rem;">No inputs defined yet</em>';
      return;
    }

    container.innerHTML = logicInputs
      .map(
        (input, idx) => `
      <div style="display: flex; justify-content: space-between; align-items: center; padding: 6px; background: white; border: 1px solid #e1e8ed; border-radius: 4px; margin-bottom: 4px;">
        <div style="flex:1;">
          <span style="font-weight: 600; font-size: 0.85rem;">${
            input.type === "event"
              ? input.eventName || input.eventId
              : input.actionName || input.actionId
          }</span>
          <span style="color: #657786; font-size: 0.75rem; margin-left: 8px;">${
            input.type === "event" ? "üìã Event" : "‚ö° Action"
          }</span>
          ${
            input.parserPath
              ? `<div style="color: #1a73e8; font-size: 0.75rem; margin-top:4px; font-family:monospace;">‚Üí <strong>${input.parserVarName}</strong> = ${input.parserPath}</div>`
              : input.field
                ? `<span style="color: #657786; font-size: 0.75rem;"> ‚Üí ${input.field}</span>`
                : '<span style="color:#657786; font-size:0.75rem; margin-left:8px;"> (full)</span>'
          }
        </div>
        <button class="btn btn-sm btn-danger" onclick="removeInput(${idx})" style="padding: 2px 8px; font-size: 0.75rem;">‚úï</button>
      </div>
    `,
      )
      .join("");
  }

  function removeInput(idx) {
    logicInputs.splice(idx, 1);
    renderInputsList();
    updateAvailableVars();
  }

  function updateAvailableVars() {
    const varsEl = document.getElementById("available-vars");
    if (!logicInputs || logicInputs.length === 0) {
      varsEl.textContent = "none";
      // Also update schema preview
      refreshInputShapePreview();
      return;
    }

    const parts = [];
    logicInputs.forEach((i) => {
      if (i.type === "event") {
        const name = i.eventName || i.eventId;
        if (i.field) parts.push(`inputs.${name}.${i.field}`);
        else parts.push(`inputs.${name}`);
      } else if (i.type === "action") {
        const id = i.actionId || i.actionName;
        if (i.parserPath) {
          // Parser path variable
          parts.push(`inputs.actions.${id}.${i.parserVarName}`);
        } else if (i.field) {
          parts.push(`inputs.actions.${id}.${i.field}`);
        } else {
          parts.push(`inputs.actions.${id}`);
        }
      }
    });
    varsEl.textContent = parts.join(", ");

    // Refresh input shape preview whenever inputs change
    refreshInputShapePreview();
  }

  async function showEventInputSelector() {
    // Show modal to select event and field
    const events = await loadAvailableEvents();
    if (!events || events.length === 0) {
      showToast("No events available", "info");
      return;
    }

    const eventSelect = events
      .map((e) => `<option value="${e.id}">${e.name}</option>`)
      .join("");

    // Prefetch payload schemas for events so we can render selectable field chips synchronously
    const schemaMap = {};
    await Promise.all(
      events.map(async (ev) => {
        try {
          schemaMap[ev.id] = await fetchEventPayloadSchema(ev);
        } catch (e) {
          schemaMap[ev.id] = null;
        }
      }),
    );

    // Expose schema map for the modal helpers
    window.__customLogicEventSchemaMap = schemaMap;

    // Helper to build fields HTML for a schema
    function buildFieldsHtml(schema) {
      if (!schema)
        return '<div class="muted">No schema available for this event</div>';
      const primary = schema.primaryFields || {};
      const metadata = schema.metadataFields || {};
      const parts = [];
      Object.keys(primary).forEach((k) => {
        const info = primary[k];
        const title = info.description || k;
        parts.push(
          `<span style=\"background:#f0f3f5;padding:6px 10px;border-radius:12px;cursor:pointer;border:1px solid #e1e8ed; font-size:0.85rem;\" data-field=\"${k}\" title=\"${title}\" onclick=\"window.__customLogicToggleField(this)\">${k}</span>`,
        );
      });
      Object.keys(metadata).forEach((k) => {
        const info = metadata[k];
        const title = info.description || k;
        parts.push(
          `<span style=\"background:#f8fafb;padding:4px 8px;border-radius:12px;cursor:pointer;border:1px solid #e9eef2;color:#657786;font-size:0.8rem;\" data-field=\"${k}\" title=\"${title}\" onclick=\"window.__customLogicToggleField(this)\">${k}</span>`,
        );
      });
      if (parts.length === 0)
        return '<div class="muted">No fields discovered</div>';
      return `<div style=\"display:flex;flex-wrap:wrap;gap:6px;\">${parts.join(
        "",
      )}</div>`;
    }

    // Build initial fields HTML for first event
    const firstSchemaHtml = buildFieldsHtml(schemaMap[events[0].id]);

    const html = `
      <div style="margin-bottom: 12px;">
        <label style="display: block; margin-bottom: 4px;">Event</label>
        <select id="event-input-select" data-events='${JSON.stringify(
          events,
        ).replace(
          /</g,
          "\\u003c",
        )}' style="width: 100%; padding: 8px; border: 1px solid #e1e8ed; border-radius: 4px;" onchange="window.populateCustomLogicEventFields && window.populateCustomLogicEventFields(this)">
          ${eventSelect}
        </select>
      </div>
      <div style="margin-bottom: 12px;">
        <div id="event-fields-container" style="max-height:260px; overflow:auto; border:1px solid #e1e8ed; padding:8px; border-radius:4px; background:white">
          ${firstSchemaHtml}
        </div>
      </div>
    `;

    // Provide helper functions used by the modal UI
    window.populateCustomLogicEventFields = async function (selectEl) {
      try {
        const val = selectEl.value;
        const container = document.getElementById("event-fields-container");
        container.__chosenFields = [];
        const schema =
          window.__customLogicEventSchemaMap &&
          window.__customLogicEventSchemaMap[val];
        container.innerHTML = buildFieldsHtml(schema);
      } catch (e) {
        console.warn("populateCustomLogicEventFields error", e);
      }
    };

    window.__customLogicToggleField = function (el) {
      try {
        const field = el.dataset.field;
        // find container
        let container = el.closest && el.closest("#event-fields-container");
        if (!container)
          container = document.getElementById("event-fields-container");
        if (!container.__chosenFields) container.__chosenFields = [];
        const idx = container.__chosenFields.indexOf(field);
        if (idx === -1) {
          container.__chosenFields.push(field);
          el.style.background = "#667eea";
          el.style.color = "white";
          el.style.borderColor = "#667eea";
        } else {
          container.__chosenFields.splice(idx, 1);
          el.style.background = "";
          el.style.color = "";
          el.style.borderColor = "";
        }
      } catch (e) {
        console.warn("toggle field", e);
      }
    };

    const result = await showCustomModal("Add Event Input", html, [
      { label: "Add", value: "add", primary: true },
      { label: "Cancel", value: null },
    ]);

    if (result === "add") {
      const eventId = document.getElementById("event-input-select").value;
      const event = events.find((e) => e.id === eventId);
      // fields added via chips will populate into a temporary holder on the container element
      const container = document.getElementById("event-fields-container");
      const chosen =
        container && container.__chosenFields ? container.__chosenFields : [];
      if (!chosen || chosen.length === 0) {
        // If none chosen, add the full event object as input
        logicInputs.push({
          type: "event",
          eventId: event.id,
          eventName: event.name || event.id,
          field: null,
        });
      } else {
        chosen.forEach((f) => {
          logicInputs.push({
            type: "event",
            eventId: event.id,
            eventName: event.name || event.id,
            field: f,
          });
        });
      }

      renderInputsList();
      updateAvailableVars();
    }
  }

  async function showActionInputSelector() {
    const actions = await loadAvailableActions();
    if (!actions || actions.length === 0) {
      showToast("No actions available", "info");
      return;
    }

    const actionSelect = actions
      .map((a) => `<option value="${a.id}">${a.name}</option>`)
      .join("");
    const html = `
      <div style="margin-bottom: 12px;">
        <label style="display: block; margin-bottom: 4px;">Action</label>
        <select id="action-input-select" style="width: 100%; padding: 8px; border: 1px solid #e1e8ed; border-radius: 4px;">
          ${actionSelect}
        </select>
      </div>
      <div style="margin-bottom: 12px;">
        <label style="display: block; margin-bottom: 4px;">Result Field (leave empty to use full action result)</label>
        <input type="text" id="action-field-input" placeholder="e.g., data[0].total" style="width: 100%; padding: 8px; border: 1px solid #e1e8ed; border-radius: 4px;" />
      </div>
      <div style="margin-bottom: 6px; color: #657786; font-size: 0.85rem">Alias is not required ‚Äî action results will be exposed under <code>inputs.actions.<i>actionId</i></code> or as field path.</div>
    `;

    const result = await showCustomModal("Add Action Input", html, [
      { label: "Add", value: "add", primary: true },
      { label: "Cancel", value: null },
    ]);

    if (result === "add") {
      const actionId = document.getElementById("action-input-select").value;
      const action = actions.find((a) => a.id === actionId);
      const field = document.getElementById("action-field-input").value.trim();

      logicInputs.push({
        type: "action",
        actionId: action.id,
        actionName: action.name || action.id,
        field: field || null,
      });

      renderInputsList();
      updateAvailableVars();
    }
  }

  async function loadAvailableEvents() {
    try {
      // Primary source: runtime-discovered event registry
      const r = await fetch("/api/event-registry");
      if (r.ok) {
        const dr = await r.json();
        const reg = dr && dr.registry ? dr.registry : {};
        const out = [];
        Object.keys(reg).forEach((mod) => {
          const m = reg[mod] || {};
          Object.keys(m.events || {}).forEach((evName) => {
            out.push({
              id: evName,
              name: evName,
              description: "(discovered)",
              target: mod,
            });
          });
        });
        return out;
      }
      // If registry endpoint not available or empty, return empty list
      return [];
    } catch (e) {
      console.error("Failed to load events", e);
      return [];
    }
  }

  async function loadAvailableActions() {
    try {
      // Prefer the central actions endpoint used by the Actions panel
      try {
        const resA = await fetch("/api/actions");
        if (resA.ok) {
          const dataA = await resA.json();
          console.debug("custom-logic: /api/actions ->", dataA);
          if (dataA && dataA.ok) {
            const arr = Object.values(dataA.actions || {}).map((a) => ({
              id: a.id || a.name,
              ...(a || {}),
            }));
            console.debug("custom-logic: actions count", arr.length);
            if (arr.length) return arr;
          }
        }
      } catch (e) {}

      return [];
    } catch (e) {
      console.error("Failed to load actions", e);
      return [];
    }
  }

  async function testCustomLogic() {
    const functionCode = document.getElementById("logic-function").value;
    const testDataStr = document.getElementById("logic-test-data").value;

    if (!functionCode.trim()) {
      showToast("Function code is required", "error");
      return;
    }

    let testData = {};
    try {
      testData = JSON.parse(testDataStr || "{}");
    } catch (e) {
      showToast("Invalid JSON in test data", "error");
      return;
    }

    try {
      // Update variable preview before execution
      showVariablePreviewFromTestData(testData);

      const result = await executeCustomLogic(functionCode, {
        inputs: testData,
      });

      const resultEl = document.getElementById("logic-test-result");
      resultEl.style.display = "block";
      resultEl.style.background = "#d4edda";
      resultEl.style.border = "1px solid #c3e6cb";
      resultEl.style.color = "#155724";

      // Enhanced result display with type information
      const resultType = Array.isArray(result) ? "array" : typeof result;
      const resultPreview = JSON.stringify(result, null, 2);

      resultEl.innerHTML =
        `<div style="margin-bottom: 8px;"><strong>‚úÖ Execution Successful</strong></div>` +
        `<div style="font-size: 0.85rem; color: #0c5a3a; margin-bottom: 4px;">Return Type: ${resultType}</div>` +
        `<pre style="margin-top: 4px; background: #f8f9fa; padding: 8px; border-radius: 4px; color: #14171a; max-height: 300px; overflow: auto;">${resultPreview}</pre>`;
    } catch (e) {
      const resultEl = document.getElementById("logic-test-result");
      resultEl.style.display = "block";
      resultEl.style.background = "#f8d7da";
      resultEl.style.border = "1px solid #f5c6cb";
      resultEl.style.color = "#721c24";

      // Enhanced error display with stack trace
      const errorDetails = e.stack
        ? `<pre style="margin-top: 8px; background: #fff; padding: 8px; border-radius: 4px; font-size: 0.75rem; overflow: auto; max-height: 200px;">${e.stack}</pre>`
        : "";

      resultEl.innerHTML =
        `<div style="margin-bottom: 8px;"><strong>‚ùå Execution Failed</strong></div>` +
        `<div style="font-size: 0.9rem; margin-bottom: 4px;">${e.message}</div>` +
        errorDetails;
    }
  }

  // ==================== BULLETPROOF INPUT PARSER ====================

  /**
   * Parse and validate inputs for execution with 100% reliability
   * This function ensures the inputs object EXACTLY matches the schema
   */
  function parseInputsForExecution(rawContext, inputDefinitions) {
    const inputs = {};
    const errors = [];
    const warnings = [];

    try {
      // Build schema for validation
      const schema = buildInputShapeSchema(inputDefinitions);

      // Process event inputs
      const eventInputs = inputDefinitions.filter((i) => i.type === "event");
      eventInputs.forEach((inp) => {
        try {
          const eventVarName = normalizeVarName(inp.eventName || inp.eventId);
          const eventId = inp.eventId || inp.eventName;

          // Find event data in raw context
          let eventData = null;
          if (rawContext.events && rawContext.events[eventId]) {
            eventData = rawContext.events[eventId];
          } else if (rawContext[eventVarName]) {
            eventData = rawContext[eventVarName];
          } else if (rawContext[eventId]) {
            eventData = rawContext[eventId];
          } else if (rawContext[inp.eventName]) {
            eventData = rawContext[inp.eventName];
          }

          if (eventData === null || eventData === undefined) {
            warnings.push(`Event data not found for: ${eventVarName}`);
            eventData = {};
          }

          // Initialize event object in inputs
          if (!inputs[eventVarName]) {
            inputs[eventVarName] = {};
          }

          // Extract specific field or use full event
          if (inp.field) {
            const fieldVarName = normalizeVarName(inp.field);
            const value = extractFieldValue(eventData, inp.field);
            inputs[eventVarName][fieldVarName] = value;
          } else {
            inputs[eventVarName] = eventData;
          }
        } catch (e) {
          errors.push(
            `Failed to parse event input ${inp.eventName}: ${e.message}`,
          );
        }
      });

      // Process action inputs
      const actionInputs = inputDefinitions.filter((i) => i.type === "action");
      if (actionInputs.length > 0) {
        inputs.actions = inputs.actions || {};

        actionInputs.forEach((inp) => {
          try {
            const actionVarName = normalizeVarName(inp.actionId);
            const actionId = inp.actionId;

            // Find action data in raw context
            let actionData = null;
            if (rawContext.actions && rawContext.actions[actionId]) {
              actionData = rawContext.actions[actionId];
            } else if (
              rawContext.actions &&
              rawContext.actions[actionVarName]
            ) {
              actionData = rawContext.actions[actionVarName];
            } else if (rawContext[actionVarName]) {
              actionData = rawContext[actionVarName];
            } else if (rawContext[actionId]) {
              actionData = rawContext[actionId];
            }

            if (actionData === null || actionData === undefined) {
              warnings.push(`Action data not found for: ${actionVarName}`);
              actionData = {};
            }

            // Initialize action object in inputs.actions
            if (!inputs.actions[actionVarName]) {
              inputs.actions[actionVarName] = {};
            }

            // Extract specific field, parser path, or use full action
            if (inp.parserPath && inp.parserVarName) {
              const parserVarName = normalizeVarName(inp.parserVarName);
              const value = extractFieldValue(actionData, inp.parserPath);
              inputs.actions[actionVarName][parserVarName] = value;
            } else if (inp.field) {
              const fieldVarName = normalizeVarName(inp.field);
              const value = extractFieldValue(actionData, inp.field);
              inputs.actions[actionVarName][fieldVarName] = value;
            } else {
              inputs.actions[actionVarName] = actionData;
            }
          } catch (e) {
            errors.push(
              `Failed to parse action input ${inp.actionId}: ${e.message}`,
            );
          }
        });
      }

      // Validate against schema
      const validation = validateInputsAgainstSchema(inputs, schema);
      if (!validation.valid) {
        errors.push(...validation.errors);
      }
      warnings.push(...validation.warnings);

      return {
        inputs,
        valid: errors.length === 0,
        errors,
        warnings,
        schema,
      };
    } catch (e) {
      return {
        inputs: {},
        valid: false,
        errors: [`Critical parsing error: ${e.message}`],
        warnings,
        schema: null,
      };
    }
  }

  /**
   * Extract field value from object using dot notation or array indices
   * Handles paths like "data.user.name" or "rows[0].phone_number"
   */
  function extractFieldValue(obj, path) {
    if (!obj || !path) return obj;

    try {
      const parts = path.split(/\.|\[/).map((p) => p.replace(/\]$/, ""));
      let value = obj;

      for (const part of parts) {
        if (value === null || value === undefined) return null;

        // Check if part is array index
        if (/^\d+$/.test(part)) {
          value = value[parseInt(part, 10)];
        } else {
          value = value[part];
        }
      }

      return value;
    } catch (e) {
      console.warn(`Failed to extract field ${path}:`, e);
      return null;
    }
  }

  async function executeCustomLogic(functionCode, context) {
    // Parse and validate inputs with 100% reliability
    const parsed = parseInputsForExecution(context, logicInputs);

    // Show warnings if any
    if (parsed.warnings.length > 0) {
      console.warn("Input parsing warnings:", parsed.warnings);
    }

    // Fail if parsing errors occurred
    if (!parsed.valid) {
      const error = new Error(
        `Input parsing failed:\n${parsed.errors.join("\n")}`,
      );
      error.parsingErrors = parsed.errors;
      throw error;
    }

    // Validate against schema before execution
    if (parsed.schema) {
      const validation = validateInputsAgainstSchema(
        parsed.inputs,
        parsed.schema,
      );
      if (!validation.valid) {
        console.warn("Input validation warnings:", validation.errors);
      }
    }

    // Create sandboxed function with enhanced error context
    try {
      const func = new Function("inputs", functionCode);
      const result = func(parsed.inputs);

      // Handle promises if the code is async
      if (result && typeof result.then === "function") {
        return await result;
      }

      return result;
    } catch (error) {
      // Enhance error message with context
      const enhancedError = new Error(
        `Custom Logic Execution Error: ${error.message}`,
      );
      enhancedError.stack = error.stack;
      enhancedError.originalError = error;
      throw enhancedError;
    }
  }

  async function saveCustomLogic() {
    const name = document.getElementById("logic-name").value.trim();
    const description = document
      .getElementById("logic-description")
      .value.trim();
    const functionCode = document.getElementById("logic-function").value.trim();

    if (!name) {
      showToast("Name is required", "error");
      return;
    }

    if (!functionCode) {
      showToast("Function code is required", "error");
      return;
    }

    const logic = {
      id: currentLogic ? currentLogic.id : generateId(),
      name,
      description,
      inputs: logicInputs,
      functionCode,
      updatedAt: new Date().toISOString(),
    };

    // Persist the current test payload so it can be re-used when selecting this logic later
    try {
      const testDataStr =
        document.getElementById("logic-test-data").value || "";
      if (testDataStr) {
        let uiTestData = null;
        try {
          uiTestData = JSON.parse(testDataStr);
        } catch (e) {
          logic.exampleContextRaw = testDataStr;
        }

        // Build an engine-friendly exampleContext (events/actions maps)
        try {
          const engineCtx = { events: {}, actions: {} };
          if (uiTestData) {
            for (const inp of logicInputs || []) {
              if (inp.type === "event") {
                const eid = inp.eventId || inp.eventName || inp.source;
                const evtVar = normalizeVarName(
                  inp.eventName || inp.eventId || eid,
                );
                const v =
                  uiTestData[evtVar] ??
                  uiTestData[inp.eventName] ??
                  uiTestData[inp.eventId] ??
                  null;
                engineCtx.events[eid] = v;
              } else if (inp.type === "action") {
                const aid = inp.actionId || inp.actionName || inp.source;
                const actVar = normalizeVarName(aid);
                const v =
                  (uiTestData.actions &&
                    (uiTestData.actions[actVar] ?? uiTestData.actions[aid])) ??
                  null;
                engineCtx.actions[aid] = v;
              }
            }
          }

          // Save both forms: engine-oriented and UI-oriented
          logic.exampleContext = engineCtx;
          if (uiTestData) logic.exampleContextUI = uiTestData;
        } catch (e) {
          console.warn("Failed to build engine exampleContext:", e);
          if (!logic.exampleContext && uiTestData)
            logic.exampleContext = uiTestData;
        }
      }
    } catch (e) {
      console.warn("Unable to capture exampleContext for custom logic", e);
    }

    try {
      const method = currentLogic ? "PUT" : "POST";
      const url = currentLogic
        ? `/api/custom-logic/${currentLogic.id}`
        : "/api/custom-logic";

      const res = await fetch(url, {
        method,
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(logic),
      });

      const data = await res.json();
      if (data.ok) {
        showToast("Custom logic saved", "success");
        await loadCustomLogics();
        currentLogic = logic;
      } else {
        showToast("Failed to save: " + (data.error || "unknown"), "error");
      }
    } catch (e) {
      showToast("Save error: " + e.message, "error");
    }
  }

  async function deleteCurrentLogic() {
    if (!currentLogic) return;
    if (!confirm(`Delete "${currentLogic.name}"?`)) return;

    try {
      const res = await fetch(`/api/custom-logic/${currentLogic.id}`, {
        method: "DELETE",
      });
      const data = await res.json();
      if (data.ok) {
        showToast("Deleted", "success");
        await loadCustomLogics();
        clearLogicEditor();
        document.getElementById("custom-logic-empty-state").style.display =
          "flex";
        document.getElementById("custom-logic-editor").style.display = "none";
      } else {
        showToast("Delete failed", "error");
      }
    } catch (e) {
      showToast("Delete error: " + e.message, "error");
    }
  }

  function generateId() {
    return (
      "logic_" + Date.now() + "_" + Math.random().toString(36).substr(2, 9)
    );
  }

  async function showCustomModal(title, content, buttons) {
    return new Promise((resolve) => {
      const overlay = document.createElement("div");
      overlay.style.cssText =
        "position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 10000; display: flex; align-items: center; justify-content: center;";

      const modal = document.createElement("div");
      modal.style.cssText =
        "background: white; border-radius: 8px; padding: 20px; min-width: 400px; max-width: 800px; max-height: 80vh; overflow: auto; box-shadow: 0 4px 12px rgba(0,0,0,0.3);";

      const titleEl = document.createElement("h3");
      titleEl.textContent = title;
      titleEl.style.cssText = "margin: 0 0 16px 0;";

      const contentEl = document.createElement("div");
      contentEl.innerHTML = content;

      const buttonContainer = document.createElement("div");
      buttonContainer.style.cssText =
        "display: flex; gap: 8px; margin-top: 16px; justify-content: flex-end;";

      buttons.forEach((btn) => {
        const button = document.createElement("button");
        button.textContent = btn.label;
        button.className = btn.primary
          ? "btn btn-primary"
          : "btn btn-secondary";
        button.onclick = () => {
          document.body.removeChild(overlay);
          resolve(btn.value);
        };
        buttonContainer.appendChild(button);
      });

      modal.appendChild(titleEl);
      modal.appendChild(contentEl);
      modal.appendChild(buttonContainer);
      overlay.appendChild(modal);
      document.body.appendChild(overlay);

      overlay.onclick = (e) => {
        if (e.target === overlay) {
          document.body.removeChild(overlay);
          resolve(null);
        }
      };
    });
  }

  // Action Test Runner - Test execute actions and select result fields with parser paths
  window.showActionTestRunner = async function () {
    const actions = await loadAvailableActions();
    if (!actions || actions.length === 0) {
      showToast("No actions available", "info");
      return;
    }

    const actionSelect = actions
      .map((a) => `<option value="${a.id}">${a.name || a.id}</option>`)
      .join("");

    const html = `
      <div style="margin-bottom: 16px;">
        <label style="display: block; font-weight: 600; margin-bottom: 8px;">1. Select Action to Test</label>
        <select id="test-action-selector" style="width: 100%; padding: 8px; border: 1px solid #e1e8ed; border-radius: 4px;">
          <option value="">-- Choose an action --</option>
          ${actionSelect}
        </select>
      </div>

      <!-- Removed test parameters JSON input per UX decision; Custom Logic tester will use persisted executedQuery or action query directly -->

      <div id="test-action-query-section" style="display:none; margin-bottom: 8px;">
        <label style="display: block; font-weight: 600; margin-bottom: 8px;">2. SQL To Execute</label>
        <div style="background: #f6f8fa; border: 1px solid #e1e8ed; border-radius: 4px; padding: 8px;">
          <pre id="test-action-query-display" style="margin:0; font-size:0.85rem; white-space: pre-wrap;"></pre>
        </div>
      </div>

      <div id="test-action-result-section" style="display:none; margin-bottom: 16px;">
        <label style="display: block; font-weight: 600; margin-bottom: 8px;">3. Action Result</label>
        <div style="background: #f5f5f5; border: 1px solid #ddd; border-radius: 4px; padding: 12px; max-height: 300px; overflow: auto;">
          <pre id="test-action-result-display" style="margin: 0; font-size: 0.85rem; white-space: pre-wrap;"></pre>
        </div>
      </div>
      <div id="test-action-table-section" style="display:none; margin-bottom:16px;">
        <label style="display: block; font-weight: 600; margin-bottom: 8px;">3b. Result Table (select cells to build output shape)</label>
        <div id="test-action-table-container" style="max-height:300px; overflow:auto; background:#fff; border:1px solid #e1e8ed; border-radius:6px; padding:8px"></div>
        <div style="margin-top:8px; display:flex; gap:8px; align-items:center;">
          <button class="btn btn-primary" id="save-output-shape-btn" style="display:none;">üíæ Save Output Shape</button>
          <div style="color:#657786; font-size:0.85rem">Select the cells you want to include in the output POJO, then click Save Output Shape.</div>
        </div>
      </div>

      <div id="test-action-fields-section" style="display:none; margin-bottom: 16px;">
        <label style="display: block; font-weight: 600; margin-bottom: 8px;">4. Select Fields to Use as Variables</label>
        <div style="font-size: 0.85rem; color: #657786; margin-bottom: 8px;">Click on fields below to add them as parser path variables:</div>
        <div id="test-action-fields-tree" style="background: #fff; border: 1px solid #ddd; border-radius: 4px; padding: 12px; max-height: 300px; overflow: auto;"></div>
        <div id="test-action-metadata-fields" style="margin-top:12px; background:#fff; border:1px dashed #e9eef2; padding:10px; border-radius:4px; display:none;">
          <div style="font-weight:600; color:#14171a; margin-bottom:6px;">Metadata / Event Fields</div>
          <div id="test-action-metadata-fields-list" style="max-height:200px; overflow:auto; font-size:0.9rem; color:#333"></div>
        </div>
      </div>

      <div id="selected-parser-paths-section" style="display:none; margin-bottom: 16px;">
        <label style="display: block; font-weight: 600; margin-bottom: 8px;">Selected Variables (Parser Paths)</label>
        <div id="selected-parser-paths-list" style="background: #f9f9f9; border: 1px solid #ddd; border-radius: 4px; padding: 12px;"></div>
      </div>
    `;

    // Track test state
    window.__actionTestState = {
      selectedAction: null,
      testResult: null,
      selectedPaths: new Map(),
      // stash available actions so execute can reference them
      availableActions: actions,
    };

    // Watch for action selection changes
    setTimeout(() => {
      const selector = document.getElementById("test-action-selector");
      if (selector) {
        selector.onchange = () => {
          const actionId = selector.value;
          if (actionId) {
            window.__actionTestState.selectedAction = actionId;
          } else {
            window.__actionTestState.selectedAction = null;
          }
          // reset UI
          const resultSec = document.getElementById(
            "test-action-result-section",
          );
          const fieldsSec = document.getElementById(
            "test-action-fields-section",
          );
          const selSec = document.getElementById(
            "selected-parser-paths-section",
          );
          if (resultSec) resultSec.style.display = "none";
          if (fieldsSec) fieldsSec.style.display = "none";
          if (selSec) selSec.style.display = "none";

          // Auto-run the test for the selected action and show the SQL that will be used
          try {
            console.debug("action-test: selector changed, actionId=", actionId);
            try {
              const qSec = document.getElementById("test-action-query-section");
              const qDisp = document.getElementById(
                "test-action-query-display",
              );
              if (qDisp && qSec) {
                const act = actions.find((a) => a && a.id === actionId) || null;
                const vm =
                  act && act.variableMappings ? act.variableMappings : {};
                const qText =
                  (vm && vm.executedQuery) ||
                  (act && (act.sql || act.query || act.template)) ||
                  "";
                qDisp.textContent = qText || "(no SQL available)";
                qSec.style.display = actionId ? "block" : "none";
              }
            } catch (e) {
              console.warn("failed to set query preview", e);
            }
            if (actionId) window.__executeTestAction();
          } catch (e) {
            console.error("action-test: auto-run failed", e);
          }
        };
      }
    }, 100);

    // Show modal but don't block ‚Äî we want to auto-run a saved sample if available
    const modalPromise = showCustomModal(
      "üß™ Test Action & Select Result Fields",
      html,
      [
        { label: "Add Selected Variables", value: "save", primary: true },
        { label: "Cancel", value: null },
      ],
    );

    // After the modal is inserted into the DOM, try to auto-select an action
    // that has a saved successful sample (or other sample fields) and run it.
    setTimeout(() => {
      try {
        const selectorEl = document.getElementById("test-action-selector");
        if (!selectorEl) return;

        // Find an action that is useful for testing: has a stored executedQuery,
        // a template, or parser paths. Avoid relying on verbose example blobs.
        const autoAction = actions.find((a) => {
          if (!a) return false;
          if (a.sample || a.successSample || a.exampleParams) return true;
          if (
            a.variableMappings &&
            (a.variableMappings.executedQuery || a.variableMappings.template)
          )
            return true;
          if (
            a.variableMappings &&
            a.variableMappings.parserPaths &&
            a.variableMappings.parserPaths.length > 0
          )
            return true;
          return false;
        });

        if (!autoAction) return;

        // select it in the UI
        selectorEl.value = autoAction.id;

        // run the test to populate preview and fields
        try {
          window.__executeTestAction();
        } catch (e) {
          console.warn("auto-run execute failed", e);
        }
      } catch (e) {
        console.warn("auto-select sample failed", e);
      }
    }, 80);

    const result = await modalPromise;

    if (result === "save" && window.__actionTestState.selectedPaths.size > 0) {
      // Add selected parser paths to logic inputs (skip ones already added)
      const actionId = window.__actionTestState.selectedAction;
      let added = 0;
      for (const [
        path,
        data,
      ] of window.__actionTestState.selectedPaths.entries()) {
        const exists = logicInputs.some(
          (li) =>
            li &&
            li.type === "action" &&
            li.parserPath === path &&
            li.actionId === actionId,
        );
        if (!exists) {
          logicInputs.push({
            type: "action",
            actionId: actionId,
            actionName: actionId,
            field: null,
            parserPath: path,
            parserVarName: data.varName,
            sampleValue: data.value,
          });
          added++;
        }
      }
      if (added > 0) {
        renderInputsList();
        updateAvailableVars();
      }
      showToast(`Added ${added} new parser path variable(s)`, "success");
      // Parser paths and selected variables are stored in `logicInputs` above
      // and will be persisted together when the user saves the Custom Logic
      // function (via `saveCustomLogic()`). No action metadata is modified here.
      showToast(
        "Selected parser path variables added to the Custom Logic inputs ‚Äî save the logic to persist.",
        "success",
      );
    }
  };

  window.__executeTestAction = async function () {
    const actionId = window.__actionTestState.selectedAction;
    if (!actionId) return;

    try {
      // Ensure we have access to the available actions (may be out of scope)
      let actions =
        (window.__actionTestState &&
          window.__actionTestState.availableActions) ||
        null;
      if (!actions || !Array.isArray(actions)) {
        try {
          actions = await loadAvailableActions();
        } catch (e) {
          actions = [];
        }
      }

      // Use stored executedQuery if available, otherwise fall back to action.query/template
      const action = actions.find((a) => a.id === actionId) || {};
      const vm = action.variableMappings || {};
      let queryText =
        (vm && vm.executedQuery) ||
        action.sql ||
        action.query ||
        action.template ||
        null;
      // Reflect the chosen SQL in the modal UI
      try {
        const qSec = document.getElementById("test-action-query-section");
        const qDisp = document.getElementById("test-action-query-display");
        if (qDisp && qSec) {
          qDisp.textContent = queryText || "(no SQL available)";
          qSec.style.display = "block";
        }
      } catch (e) {
        console.warn("Failed to render query preview in modal", e);
      }
      if (!queryText) {
        showToast("Action has no SQL defined", "error");
        return;
      }

      // Execute using the stored query from action metadata. Do not require user-supplied JSON params here.
      console.debug("action-test: executing action", { actionId, queryText });
      // Determine eventName to pass to the resolver: prefer explicit variable in template,
      // otherwise fall back to the first bound event for the action (if any).
      let eventNameForRequest = null;
      try {
        const matchEvent = String(queryText).match(/\{\{([^\.\}]+)\./);
        if (matchEvent) eventNameForRequest = matchEvent[1];
        else if (
          action &&
          action.eventBindings &&
          action.eventBindings.length === 1
        )
          eventNameForRequest = action.eventBindings[0].eventName;
      } catch (e) {
        console.warn("Failed to compute eventNameForRequest", e);
      }

      // Build a best-effort sample payload so template variables can be resolved.
      let payloadForRequest = null;
      try {
        if (
          vm &&
          Array.isArray(vm._exampleOutputs) &&
          vm._exampleOutputs.length > 0
        ) {
          payloadForRequest = vm._exampleOutputs[0].payload;
        } else if (
          action &&
          Array.isArray(action.exampleOutputs) &&
          action.exampleOutputs.length > 0
        ) {
          payloadForRequest = action.exampleOutputs[0].payload;
        } else if (
          action &&
          action.eventBindings &&
          action.eventBindings.length > 0
        ) {
          const binding = action.eventBindings[0] || {};
          const schema = binding.payloadSchema || {};
          const setAtPath = (obj, path, value) => {
            if (!path) return;
            const parts = path.split(".");
            let cur = obj;
            for (let i = 0; i < parts.length; i++) {
              const p = parts[i];
              if (i === parts.length - 1) {
                cur[p] = value;
              } else {
                if (!cur[p] || typeof cur[p] !== "object") cur[p] = {};
                cur = cur[p];
              }
            }
          };
          const pld = {};
          if (schema.primaryFields) {
            Object.keys(schema.primaryFields).forEach((k) => {
              const fld = schema.primaryFields[k] || {};
              if (fld.path && fld.sample !== undefined)
                setAtPath(pld, fld.path, fld.sample);
              else if (fld.sample !== undefined) pld[k] = fld.sample;
            });
          }
          if (schema.metadataFields) {
            Object.keys(schema.metadataFields).forEach((k) => {
              const mf = schema.metadataFields[k] || {};
              if (mf.sample !== undefined) pld[k] = mf.sample;
            });
          }
          if (!pld.event)
            pld.event =
              binding.eventName || binding.eventId || eventNameForRequest;
          if (!pld.module && binding.eventName)
            pld.module = String(binding.eventName).split(":")[0];
          payloadForRequest = pld;
        }
      } catch (e) {
        console.warn("Failed to build sample payload for action test", e);
      }

      const reqBody = { query: queryText, eventName: eventNameForRequest };
      if (payloadForRequest) reqBody.payload = payloadForRequest;

      console.debug("action-test: reqBody", reqBody);
      const res = await fetch("/api/event/execute", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(reqBody),
      });
      console.debug("action-test: fetch completed, status=", res.status);

      let data;
      try {
        data = await res.json();
        console.debug("action-test: response json", data);
      } catch (parseErr) {
        const txt = await res.text().catch(() => "<no body>");
        console.error("action-test: non-json response", {
          status: res.status,
          body: txt,
        });
        throw new Error(
          "Server returned non-JSON response: " +
            (txt.length > 400 ? txt.substring(0, 400) + "..." : txt),
        );
      }

      // Normalize response shape from /api/event/execute to the test UI
      if (data && data.ok) {
        const result = {
          rows: data.data || data.rows || [],
          rowCount:
            data.rowCount != null
              ? data.rowCount
              : Array.isArray(data.data)
                ? data.data.length
                : 0,
          sql: data.executedQuery || data.query || queryText,
          actionId: actionId,
        };
        window.__actionTestState.testResult = result;
        document.getElementById("test-action-result-display").textContent =
          JSON.stringify(result, null, 2);
        document.getElementById("test-action-result-section").style.display =
          "block";
        __renderActionResultFieldsTree(result);
        document.getElementById("test-action-fields-section").style.display =
          "block";
        try {
          showVariablePreviewFromActionResult(result);
        } catch (e) {
          console.warn("showVariablePreview error", e);
        }

        // Also render metadata/event fields if present on the action
        try {
          __renderActionMetadataFields(action);
        } catch (e) {
          console.warn("render metadata fields error", e);
        }
        // Render selectable table for output shape selection
        try {
          __renderActionResultTable(result);
        } catch (e) {
          console.warn("__renderActionResultTable error", e);
        }
      } else {
        const errMsg =
          data && (data.error || data.message)
            ? data.error || data.message
            : "Unknown error";
        const executed =
          data && (data.executedQuery || data.query)
            ? data.executedQuery || data.query
            : null;
        const display = executed
          ? `${errMsg}\nExecutedQuery:\n${executed}`
          : errMsg;
        showToast("Action execution failed: " + display, "error");
      }
    } catch (e) {
      console.error("executeTestAction error", e);
      showToast("Failed to execute action: " + e.message, "error");
    }
  };

  function __renderActionResultFieldsTree(result, parentPath = "", indent = 0) {
    const container = document.getElementById("test-action-fields-tree");
    if (indent === 0) container.innerHTML = "";

    if (!result || typeof result !== "object") {
      if (indent === 0)
        container.innerHTML =
          '<div style="color:#666; padding:8px;">No structured data to display</div>';
      return;
    }

    const entries = Array.isArray(result)
      ? result.slice(0, 10).map((v, i) => [i, v]) // Limit array items for performance
      : Object.entries(result);

    for (const [key, value] of entries) {
      const path = parentPath ? `${parentPath}.${key}` : String(key);
      const isObject = value && typeof value === "object";
      const isArray = Array.isArray(value);
      const displayValue = isObject
        ? isArray
          ? `[${value.length} items]`
          : "{...}"
        : JSON.stringify(value).substr(0, 50);

      const fieldDiv = document.createElement("div");
      fieldDiv.style.cssText = `margin-left:${
        indent * 20
      }px; padding:6px 8px; cursor:pointer; border-radius:4px; margin-bottom:2px; display:flex; justify-content:space-between; align-items:center;`;
      fieldDiv.innerHTML = `
        <div>
          <span style="font-weight: 600; color: #1a73e8;">${key}</span>:
          <span style="color: #666; font-size: 0.9rem;">${displayValue}</span>
        </div>
        <button class="btn btn-sm" onclick="window.__selectParserPath('${path.replace(
          /'/g,
          "\\'",
        )}')" style="padding: 2px 8px; font-size: 0.75rem;">+ Add Variable</button>
      `;
      fieldDiv.onmouseover = () => (fieldDiv.style.background = "#f0f0f0");
      fieldDiv.onmouseout = () => (fieldDiv.style.background = "transparent");
      container.appendChild(fieldDiv);

      // Recursively render nested objects (limit depth to prevent performance issues)
      if (isObject && indent < 3) {
        if (isArray && value.length > 0 && typeof value[0] === "object") {
          __renderActionResultFieldsTree(value[0], `${path}[0]`, indent + 1);
        } else if (!isArray && Object.keys(value).length < 20) {
          __renderActionResultFieldsTree(value, path, indent + 1);
        }
      }
    }
  }

  // Populate the Variable Preview panel from action result
  function showVariablePreviewFromActionResult(result) {
    const container = document.getElementById("variable-preview-list");
    if (!container) return;
    const rows = result && result.rows ? result.rows : null;
    let sample = null;
    if (Array.isArray(rows) && rows.length > 0) sample = rows[0];
    else if (rows && typeof rows === "object") sample = rows;
    else if (result && typeof result === "object") sample = result;

    if (!sample || typeof sample !== "object") {
      container.innerHTML =
        '<div style="color:#666">No tabular preview available</div>';
      return;
    }

    const parts = [];
    Object.keys(sample)
      .slice(0, 40)
      .forEach((k) => {
        let v = sample[k];
        try {
          v = JSON.stringify(v);
        } catch (e) {
          v = String(v);
        }
        if (v.length > 120) v = v.substring(0, 120) + "...";
        parts.push(
          `<div style="display:flex; justify-content:space-between; gap:12px; padding:4px 0; border-bottom:1px dashed #eee"><div style="font-family:monospace; color:#1a73e8">${k}</div><div style="color:#333; font-family:monospace">${v}</div></div>`,
        );
      });

    container.innerHTML =
      parts.join("") || '<div style="color:#666">No preview fields</div>';
  }

  window.__selectParserPath = function (path) {
    try {
      const result = window.__actionTestState.testResult;
      const value = __getNestedValue(result, path);

      const actId = window.__actionTestState.selectedAction || null;
      const actions = window.__actionTestState.availableActions || [];
      const act = actions.find((a) => a && a.id === actId) || null;
      const rawActionName = act ? act.name || act.id : actId || "action";

      // build a normalized base variable name: include action name + path
      const normalize = (s) =>
        String(s)
          .replace(/\s+/g, "_")
          .replace(/[^a-zA-Z0-9_]/g, "_")
          .replace(/_+/g, "_")
          .replace(/^_+|_+$/g, "")
          .toLowerCase();

      const maxLen = 60;
      const normalizedAction = normalize(rawActionName).slice(0, 20);
      const normalizedPath = normalize(path).slice(
        0,
        maxLen - normalizedAction.length - 1,
      );
      let baseVarName =
        `${normalizedAction}_${normalizedPath}` || normalize(path) || "var";
      if (!/^[a-zA-Z_]/.test(baseVarName)) baseVarName = `v_${baseVarName}`;

      // ensure uniqueness against existing logicInputs and already selected parser vars
      const usedNames = new Set();
      (logicInputs || []).forEach((li) => {
        if (li && li.parserVarName) usedNames.add(li.parserVarName);
      });
      for (const [, d] of window.__actionTestState.selectedPaths.entries())
        usedNames.add(d.varName);

      let uniqueName = baseVarName;
      let suffix = 2;
      while (usedNames.has(uniqueName)) {
        uniqueName = `${baseVarName}_${suffix}`;
        suffix += 1;
      }

      const varName = prompt(
        `Enter variable name for path "${path}":`,
        uniqueName || "var",
      );
      if (!varName) return;
      if (!varName) return;

      const entry = { varName, value, path };
      window.__actionTestState.selectedPaths.set(path, entry);
      // Also add immediately to logic inputs so it appears in Input Sources list
      try {
        addParserPathToLogicInputs(path, entry);
      } catch (e) {
        console.warn("addParserPathToLogicInputs failed", e);
      }
      __renderSelectedParserPaths();
      document.getElementById("selected-parser-paths-section").style.display =
        "block";
    } catch (e) {
      console.error("selectParserPath error", e);
      showToast("Failed to select path: " + e.message, "error");
    }
  };

  function __getNestedValue(obj, path) {
    const parts = path.split(/\.|\[|\]/).filter(Boolean);
    let current = obj;
    for (const part of parts) {
      if (current == null) return undefined;
      current = current[part];
    }
    return current;
  }

  function __renderSelectedParserPaths() {
    const container = document.getElementById("selected-parser-paths-list");
    if (window.__actionTestState.selectedPaths.size === 0) {
      container.innerHTML =
        '<div style="color:#666; padding:8px;">No variables selected</div>';
      return;
    }

    let html = '<div style="display: flex; flex-direction: column; gap: 8px;">';
    for (const [
      path,
      data,
    ] of window.__actionTestState.selectedPaths.entries()) {
      html += `
        <div style="display: flex; align-items: center; justify-content: space-between; padding: 8px; background: #fff; border: 1px solid #ddd; border-radius: 4px;">
          <div style="flex:1;">
            <div style="font-weight: 600; color: #1a73e8; margin-bottom:4px;">${
              data.varName
            }</div>
            <div style="font-size: 0.85rem; color: #666; font-family: monospace;">Path: ${path}</div>
            <div style="font-size: 0.85rem; color: #888; margin-top:4px;">Sample: ${JSON.stringify(
              data.value,
            )}</div>
          </div>
          <button class="btn btn-sm btn-danger" onclick="window.__removeParserPath('${path.replace(
            /'/g,
            "\\'",
          )}')" style="padding: 4px 12px;">Remove</button>
        </div>
      `;
    }
    html += "</div>";
    container.innerHTML = html;
  }

  // Render a selectable table from action test result so user can pick cells
  function __renderActionResultTable(result) {
    const container = document.getElementById("test-action-table-container");
    const section = document.getElementById("test-action-table-section");
    const saveBtn = document.getElementById("save-output-shape-btn");
    if (!container || !section || !saveBtn) return;
    container.innerHTML = "";
    section.style.display = "none";
    saveBtn.style.display = "none";

    const rows = result && result.rows ? result.rows : null;
    if (!rows || !Array.isArray(rows) || rows.length === 0) return;

    // Build table with selectable cells
    const columns = Object.keys(rows[0] || {});
    const table = document.createElement("table");
    table.style.cssText =
      "width:100%; border-collapse:collapse; font-size:0.85rem;";

    // header
    const thead = document.createElement("thead");
    const htr = document.createElement("tr");
    htr.style.background = "#f8f9fa";
    columns.forEach((col) => {
      const th = document.createElement("th");
      th.style.cssText =
        "padding:8px; text-align:left; border-bottom:2px solid #e1e8ed;";
      th.textContent = col;
      htr.appendChild(th);
    });
    thead.appendChild(htr);
    table.appendChild(thead);

    const tbody = document.createElement("tbody");
    rows.slice(0, 200).forEach((row, rIdx) => {
      const tr = document.createElement("tr");
      columns.forEach((col) => {
        const td = document.createElement("td");
        td.style.cssText =
          "padding:8px; border-bottom:1px solid #eef2f7; cursor:pointer; user-select:none;";
        const val =
          row[col] !== null && row[col] !== undefined ? row[col] : null;

        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.dataset.col = col;
        checkbox.dataset.row = String(rIdx);
        checkbox.style.marginRight = "8px";

        // display value
        const disp = document.createElement("span");
        disp.style.fontFamily = "monospace";
        disp.textContent = val === null ? "<NULL>" : String(val);

        td.appendChild(checkbox);
        td.appendChild(disp);

        // Clicking cell toggles checkbox
        td.addEventListener("click", (e) => {
          // ignore clicks directly on input to avoid double toggle
          if (e.target && e.target.tagName === "INPUT") return;
          checkbox.checked = !checkbox.checked;
        });

        tbody.appendChild(tr);
        tr.appendChild(td);
      });
    });
    table.appendChild(tbody);
    container.appendChild(table);

    // show section and save button
    section.style.display = "block";
    saveBtn.style.display = "inline-block";

    // wire save button
    saveBtn.onclick = async function () {
      try {
        const actionId = window.__actionTestState.selectedAction;
        if (!actionId) {
          showToast("No action selected", "error");
          return;
        }

        // Gather selected cells and build POJO using first selected row preference
        const checked = Array.from(
          container.querySelectorAll("input[type=checkbox]:checked"),
        );
        if (checked.length === 0) {
          showToast("No cells selected", "error");
          return;
        }

        // Build mapping: use column names as keys, prefer first checked row for each column
        const output = {};
        // group by column
        const byCol = {};
        checked.forEach((ch) => {
          const col = ch.dataset.col;
          const rowIdx = Number(ch.dataset.row);
          if (!byCol[col]) byCol[col] = [];
          byCol[col].push(rowIdx);
        });

        for (const col of Object.keys(byCol)) {
          const rowsIdx = byCol[col].sort((a, b) => a - b);
          const pickIdx = rowsIdx[0];
          const row = rows[pickIdx];
          const val = row ? row[col] : null;
          output[col] = val === undefined ? null : val;
        }

        // Build output shape metadata: include types and example values
        const outputShape = { properties: {}, example: {} };
        for (const [k, v] of Object.entries(output)) {
          outputShape.properties[k] = { type: inferType(v) };
          outputShape.example[k] = v === undefined ? null : v;
        }

        // Persist to action metadata via PUT /api/actions/:id
        const res = await fetch(
          `/api/actions/${encodeURIComponent(actionId)}`,
          {
            method: "PUT",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ variableMappings: { outputShape } }),
          },
        );
        const data = await res.json();
        if (res.ok && data && data.ok) {
          showToast("Output shape saved to action metadata", "success");
          // update local action list if present
          try {
            const acts = window.__actionTestState.availableActions || [];
            const act = acts.find((a) => a && a.id === actionId);
            if (act) act.variableMappings = act.variableMappings || {};
            if (act) act.variableMappings.outputShape = outputShape;
          } catch (e) {}
        } else {
          console.error("Save output shape failed", data);
          showToast(
            "Failed to save output shape: " +
              (data && data.error ? data.error : "unknown"),
            "error",
          );
        }
      } catch (e) {
        console.error("save output shape error", e);
        showToast("Failed saving output shape: " + e.message, "error");
      }
    };
  }

  function addParserPathToLogicInputs(path, entry) {
    try {
      const actId = window.__actionTestState.selectedAction || null;
      const actions = window.__actionTestState.availableActions || [];
      const act = actions.find((a) => a && a.id === actId) || null;
      const actionName = act ? act.name || act.id : actId;

      // avoid duplicates
      const exists = logicInputs.some(
        (li) =>
          li &&
          li.type === "action" &&
          li.parserPath === path &&
          li.actionId === actId,
      );
      if (exists) return;

      logicInputs.push({
        type: "action",
        actionId: actId,
        actionName: actionName || actId,
        field: null,
        parserPath: path,
        parserVarName: entry.varName,
        sampleValue: entry.value,
      });
      renderInputsList();
      updateAvailableVars();
    } catch (e) {
      console.warn("addParserPathToLogicInputs error", e);
    }
  }

  // Render metadata/event payload schema fields for the selected action
  function __renderActionMetadataFields(action) {
    try {
      const containerWrap = document.getElementById(
        "test-action-metadata-fields",
      );
      const list = document.getElementById("test-action-metadata-fields-list");
      if (
        !action ||
        !action.eventBindings ||
        action.eventBindings.length === 0
      ) {
        if (containerWrap) containerWrap.style.display = "none";
        return;
      }

      // We'll list fields from the first binding and include primary + metadata fields
      const binding = action.eventBindings[0] || {};
      const schema = binding.payloadSchema || {};
      const primary = schema.primaryFields || {};
      const metadata = schema.metadataFields || {};

      const parts = [];
      Object.keys(primary).forEach((k) => {
        const info = primary[k] || {};
        const sample = info.sample !== undefined ? info.sample : "";
        const path = info.path || k;
        // Build a candidate parser path using the event id + path
        const candidate = `${binding.eventId}.${path}`;
        parts.push({
          label: k,
          candidate,
          sample,
          field: k,
          section: "primary",
        });
      });
      Object.keys(metadata).forEach((k) => {
        const info = metadata[k] || {};
        const sample = info.sample !== undefined ? info.sample : "";
        const path = info.path || k;
        const candidate = `${binding.eventId}.${path}`;
        parts.push({
          label: k,
          candidate,
          sample,
          field: k,
          section: "metadata",
        });
      });

      if (parts.length === 0) {
        list.innerHTML =
          '<div style="color:#666">No metadata fields available</div>';
        if (containerWrap) containerWrap.style.display = "none";
        return;
      }

      let html = "";
      parts.forEach((p) => {
        html += `
          <div style="display:flex; justify-content:space-between; align-items:center; padding:8px; border-bottom:1px solid #f1f5f7;">
            <div style="flex:1">
              <div style="font-weight:600; color:#1a73e8">${p.label}</div>
              <div style="font-size:0.85rem; color:#444; font-family:monospace">Path: ${
                p.candidate
              }</div>
              <div style="font-size:0.85rem; color:#666; margin-top:4px">Sample: ${JSON.stringify(
                p.sample,
              )}</div>
            </div>
            <div style="margin-left:8px">
              <button class="btn btn-sm" onclick="window.__addMetadataParser('${p.candidate.replace(
                /'/g,
                "\\'",
              )}', '${p.field.replace(/'/g, "\\'")}')">+ Add</button>
            </div>
          </div>
        `;
      });

      list.innerHTML = html;
      if (containerWrap) containerWrap.style.display = "block";
    } catch (e) {
      console.warn("__renderActionMetadataFields error", e);
    }
  }

  // Add a metadata-derived parser path to selectedPaths (invoked from metadata UI)
  window.__addMetadataParser = function (candidatePath, fieldName) {
    try {
      const defaultVar = fieldName || candidatePath.split(".").pop();
      const varName = prompt(
        `Enter variable name for path "${candidatePath}":`,
        defaultVar || "var",
      );
      if (!varName) return;
      const sampleVal =
        window.__actionTestState && window.__actionTestState.testResult
          ? __getNestedValue(window.__actionTestState.testResult, candidatePath)
          : undefined;
      const entry = {
        varName,
        value: sampleVal,
        path: candidatePath,
        field: fieldName,
      };
      window.__actionTestState.selectedPaths.set(candidatePath, entry);
      try {
        addParserPathToLogicInputs(candidatePath, entry);
      } catch (e) {
        console.warn("addParserPathToLogicInputs failed", e);
      }
      __renderSelectedParserPaths();
      document.getElementById("selected-parser-paths-section").style.display =
        "block";
    } catch (e) {
      console.error("__addMetadataParser error", e);
      showToast("Failed to add parser path: " + e.message, "error");
    }
  };

  window.__removeParserPath = function (path) {
    window.__actionTestState.selectedPaths.delete(path);
    // Remove any corresponding logic input that was created from this parser path
    try {
      const actId = window.__actionTestState.selectedAction || null;
      let removed = false;
      for (let i = logicInputs.length - 1; i >= 0; i--) {
        const li = logicInputs[i];
        if (
          li &&
          li.type === "action" &&
          li.parserPath === path &&
          (actId == null || li.actionId === actId)
        ) {
          logicInputs.splice(i, 1);
          removed = true;
        }
      }
      if (removed) {
        renderInputsList();
        updateAvailableVars();
      }
    } catch (e) {
      console.warn("Failed removing logic input for parser path", e);
    }
    __renderSelectedParserPaths();
  };

  function showToast(message, type = "info") {
    console.log(`[Toast ${type}]`, message);
    alert(message);
  }

  // AI Code Generation for Custom Logic
  async function aiGenerateLogicCode() {
    const description = document
      .getElementById("logic-description")
      .value.trim();

    if (!description) {
      showToast(
        "Please provide a description of what the logic should do",
        "error",
      );
      return;
    }

    if (!logicInputs || logicInputs.length === 0) {
      showToast(
        "Please add at least one input variable before generating code",
        "error",
      );
      return;
    }

    // Find the AI Generate button
    const aiBtn = document.querySelector(
      'button[onclick="aiGenerateLogicCode()"]',
    );

    try {
      // Build comprehensive context from input variables
      const context = await buildLogicInputContext();

      // Create AI prompt with description and input context
      const prompt = buildAIPrompt(description, context);

      // Show loading state
      if (aiBtn) {
        aiBtn.disabled = true;
        aiBtn.textContent = "‚è≥ Generating...";
      }

      // Ensure runtime config is loaded
      await ensureRuntimeConfig();

      // Determine AI endpoint (proxy mode uses /ai/send, direct mode uses directUrl)
      const aiTarget =
        window.RUNTIME_CONFIG &&
        window.RUNTIME_CONFIG.ai &&
        window.RUNTIME_CONFIG.ai.mode === "direct"
          ? window.RUNTIME_CONFIG.ai.directUrl
          : "/ai/send";

      // Call AI service
      const response = await fetch(aiTarget, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          sessionId: "custom-logic-" + Date.now(),
          aiquestion: prompt,
        }),
      });

      const data = await response.json();

      // Normalize envelope response from /ai/send
      let aiResult = "";
      if (data && typeof data === "object") {
        // Server returns envelope: { ok, statusCode, data, error, diagnostics }
        const payload = data.data || data;
        if (typeof payload === "string") {
          aiResult = payload;
        } else if (typeof payload === "object") {
          aiResult =
            payload.response || payload.result || JSON.stringify(payload);
        }
      }

      if (aiResult && aiResult.trim()) {
        // Parse JavaScript code from AI response with robust parser
        const code = parseJavaScriptFromAI(aiResult);

        if (code) {
          // Populate function code textarea
          document.getElementById("logic-function").value = code;

          // Auto-populate test data with sample values
          await populateTestDataFromSamples(context);

          showToast(
            "JavaScript code generated successfully! Review and test it.",
            "success",
          );

          // Auto-scroll to function code section
          document
            .getElementById("logic-function")
            .scrollIntoView({ behavior: "smooth", block: "center" });
        } else {
          showToast(
            "Failed to extract valid JavaScript code from AI response",
            "error",
          );
          console.error("AI response parsing failed:", data.result);
        }
      } else {
        showToast(
          "AI generation failed: " + (data.error || "Unknown error"),
          "error",
        );
      }

      // Restore button state
      if (aiBtn) {
        aiBtn.disabled = false;
        aiBtn.textContent = "‚ú® AI Generate Code";
      }
    } catch (e) {
      console.error("AI code generation error:", e);
      showToast("AI generation error: " + e.message, "error");

      // Restore button state
      if (aiBtn) {
        aiBtn.disabled = false;
        aiBtn.textContent = "‚ú® AI Generate Code";
      }
    }
  }

  // Helper to normalize variable names to JavaScript-safe identifiers
  function normalizeVarName(name) {
    if (!name) return "var";
    // Convert to string and normalize
    let normalized = String(name)
      .replace(/[^a-zA-Z0-9_$]/g, "_") // Replace invalid chars with underscore
      .replace(/^[0-9]/, "_$&") // Prefix with underscore if starts with number
      .replace(/_+/g, "_") // Collapse multiple underscores
      .replace(/^_+|_+$/g, ""); // Trim leading/trailing underscores

    // Ensure it doesn't start with a number after cleanup
    if (/^[0-9]/.test(normalized)) {
      normalized = "v_" + normalized;
    }

    // Ensure it's not empty
    if (!normalized || normalized.length === 0) {
      normalized = "var";
    }

    // Ensure it's a valid JS identifier
    if (!/^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(normalized)) {
      normalized = "var_" + normalized.replace(/[^a-zA-Z0-9_$]/g, "");
    }

    return normalized;
  }

  // ==================== INPUT SHAPE SCHEMA SYSTEM ====================

  /**
   * Build comprehensive input shape schema with type information
   * This creates a strict contract for what the function will receive
   */
  function buildInputShapeSchema(inputs) {
    const schema = {
      type: "object",
      properties: {},
      required: [],
      description: "Input structure for custom logic function",
    };

    // Group inputs by type
    const eventInputs = inputs.filter((i) => i.type === "event");
    const actionInputs = inputs.filter((i) => i.type === "action");

    // Build event properties
    eventInputs.forEach((inp) => {
      const eventVarName = normalizeVarName(inp.eventName || inp.eventId);

      if (!schema.properties[eventVarName]) {
        schema.properties[eventVarName] = {
          type: "object",
          description: `Event: ${inp.eventName || inp.eventId}`,
          properties: {},
          source: "event",
          sourceId: inp.eventId,
        };
        schema.required.push(eventVarName);
      }

      if (inp.field) {
        const fieldVarName = normalizeVarName(inp.field);
        schema.properties[eventVarName].properties[fieldVarName] = {
          type: inferType(inp.sampleValue || null),
          description: `Field: ${inp.field}`,
          path: inp.field,
          sample: inp.sampleValue,
        };
      }
    });

    // Build action properties
    if (actionInputs.length > 0) {
      schema.properties.actions = {
        type: "object",
        description: "Action results",
        properties: {},
        source: "actions",
      };
      schema.required.push("actions");

      actionInputs.forEach((inp) => {
        const actionVarName = normalizeVarName(inp.actionId);

        if (!schema.properties.actions.properties[actionVarName]) {
          schema.properties.actions.properties[actionVarName] = {
            type: "object",
            description: `Action: ${inp.actionName || inp.actionId}`,
            properties: {},
            source: "action",
            sourceId: inp.actionId,
          };
        }

        if (inp.parserVarName) {
          const parserVarName = normalizeVarName(inp.parserVarName);
          schema.properties.actions.properties[actionVarName].properties[
            parserVarName
          ] = {
            type: inferType(inp.sampleValue),
            description: `Parser path: ${inp.parserPath}`,
            path: inp.parserPath,
            sample: inp.sampleValue,
          };
        } else if (inp.field) {
          const fieldVarName = normalizeVarName(inp.field);
          schema.properties.actions.properties[actionVarName].properties[
            fieldVarName
          ] = {
            type: inferType(inp.sampleValue),
            description: `Field: ${inp.field}`,
            path: inp.field,
            sample: inp.sampleValue,
          };
        } else {
          // Full action result
          schema.properties.actions.properties[actionVarName].type = inferType(
            inp.sampleValue,
          );
          schema.properties.actions.properties[actionVarName].sample =
            inp.sampleValue;
        }
      });
    }

    return schema;
  }

  /**
   * Infer JavaScript type from sample value
   */
  function inferType(value) {
    if (value === null || value === undefined) return "any";
    if (Array.isArray(value)) return "array";
    return typeof value;
  }

  /**
   * Generate human-readable TypeScript-style interface from schema
   */
  function schemaToInterface(schema) {
    if (!schema || !schema.properties) return "// No inputs defined";

    let lines = ["interface Inputs {"];

    for (const [key, prop] of Object.entries(schema.properties)) {
      const isRequired = schema.required && schema.required.includes(key);
      const optional = isRequired ? "" : "?";

      if (prop.type === "object" && prop.properties) {
        lines.push(`  ${key}${optional}: {`);
        for (const [subKey, subProp] of Object.entries(prop.properties)) {
          const subType = subProp.type || "any";
          const desc = subProp.description ? ` // ${subProp.description}` : "";
          const sample =
            subProp.sample !== undefined
              ? ` = ${JSON.stringify(subProp.sample)}`
              : "";
          lines.push(`    ${subKey}: ${subType};${desc}${sample}`);
        }
        lines.push(`  };`);
      } else {
        const propType = prop.type || "any";
        const desc = prop.description ? ` // ${prop.description}` : "";
        lines.push(`  ${key}${optional}: ${propType};${desc}`);
      }
    }

    lines.push("}");
    return lines.join("\n");
  }

  /**
   * Validate input structure against schema
   */
  function validateInputsAgainstSchema(inputs, schema) {
    const errors = [];
    const warnings = [];

    if (!schema || !schema.properties) {
      return { valid: true, errors, warnings };
    }

    // Check required properties
    for (const reqKey of schema.required || []) {
      if (!inputs || inputs[reqKey] === undefined) {
        errors.push(`Missing required input: ${reqKey}`);
      }
    }

    // Validate types
    for (const [key, value] of Object.entries(inputs || {})) {
      const schemaProp = schema.properties[key];
      if (!schemaProp) {
        warnings.push(`Unexpected input property: ${key}`);
        continue;
      }

      const expectedType = schemaProp.type;
      const actualType = Array.isArray(value) ? "array" : typeof value;

      if (expectedType !== "any" && expectedType !== actualType) {
        errors.push(
          `Type mismatch for ${key}: expected ${expectedType}, got ${actualType}`,
        );
      }

      // Validate nested properties
      if (
        schemaProp.type === "object" &&
        schemaProp.properties &&
        typeof value === "object"
      ) {
        for (const [subKey, subValue] of Object.entries(value || {})) {
          const subSchemaProp = schemaProp.properties[subKey];
          if (!subSchemaProp) {
            warnings.push(`Unexpected nested property: ${key}.${subKey}`);
            continue;
          }

          const subExpectedType = subSchemaProp.type;
          const subActualType = Array.isArray(subValue)
            ? "array"
            : typeof subValue;

          if (subExpectedType !== "any" && subExpectedType !== subActualType) {
            errors.push(
              `Type mismatch for ${key}.${subKey}: expected ${subExpectedType}, got ${subActualType}`,
            );
          }
        }
      }
    }

    return {
      valid: errors.length === 0,
      errors,
      warnings,
    };
  }

  /**
   * Refresh the input shape preview panel
   */
  function refreshInputShapePreview() {
    try {
      if (!logicInputs || logicInputs.length === 0) {
        document.getElementById("input-shape-schema").textContent =
          "// No inputs defined";
        document.getElementById("validation-icon").textContent = "";
        document.getElementById("validation-message").textContent = "";
        document.getElementById("input-validation-status").style.display =
          "none";
        return;
      }

      // Build schema
      const schema = buildInputShapeSchema(logicInputs);

      // Generate interface representation
      const interfaceStr = schemaToInterface(schema);
      document.getElementById("input-shape-schema").textContent = interfaceStr;

      // Show validation status
      const statusEl = document.getElementById("input-validation-status");
      statusEl.style.display = "block";
      statusEl.style.background = "#d4edda";
      statusEl.style.border = "1px solid #c3e6cb";
      statusEl.style.color = "#155724";

      document.getElementById("validation-icon").textContent = "‚úÖ ";
      document.getElementById("validation-message").textContent =
        `Input shape defined: ${logicInputs.length} variable${
          logicInputs.length > 1 ? "s" : ""
        }`;

      // Also update the variable preview with structured view
      updateStructuredPreview(schema);
    } catch (e) {
      console.error("Failed to refresh input shape preview:", e);
      const statusEl = document.getElementById("input-validation-status");
      statusEl.style.display = "block";
      statusEl.style.background = "#f8d7da";
      statusEl.style.border = "1px solid #f5c6cb";
      statusEl.style.color = "#721c24";

      document.getElementById("validation-icon").textContent = "‚ùå ";
      document.getElementById("validation-message").textContent =
        `Error: ${e.message}`;
    }
  }

  /**
   * Update variable preview with structured hierarchical view
   */
  function updateStructuredPreview(schema) {
    const container = document.getElementById("variable-preview-list");
    if (!container) return;

    const parts = [];

    const renderProperty = (key, prop, path = "") => {
      const fullPath = path ? `${path}.${key}` : key;
      const type = prop.type || "any";
      const sample =
        prop.sample !== undefined ? JSON.stringify(prop.sample) : "null";

      return `
        <div style="margin-bottom: 4px; padding: 4px; border-left: 3px solid #4caf50;">
          <div style="display: flex; justify-content: space-between; gap: 8px;">
            <span style="font-family: monospace; color: #1a73e8; font-weight: 600;">${fullPath}</span>
            <span style="font-family: monospace; color: #666; font-size: 0.85rem;">${type}</span>
          </div>
          <div style="color: #555; font-size: 0.75rem; margin-top: 2px;">
            Sample: <code style="background: #f5f5f5; padding: 2px 4px; border-radius: 2px;">${sample}</code>
          </div>
        </div>
      `;
    };

    for (const [key, prop] of Object.entries(schema.properties || {})) {
      if (prop.type === "object" && prop.properties) {
        parts.push(
          `<div style="margin-bottom: 8px;"><strong>${key}:</strong></div>`,
        );
        for (const [subKey, subProp] of Object.entries(prop.properties)) {
          parts.push(renderProperty(subKey, subProp, key));
        }
      } else {
        parts.push(renderProperty(key, prop));
      }
    }

    container.innerHTML =
      parts.length > 0
        ? parts.join("")
        : '<div style="color:#666; padding: 8px;">No variables available</div>';
  }

  // Build comprehensive context from all input variables
  async function buildLogicInputContext() {
    const context = {
      variables: [],
      events: {},
      actions: {},
      description: "",
    };

    // Process each input to gather context and sample values
    for (const input of logicInputs) {
      if (input.type === "event") {
        const eventInfo = await gatherEventContext(input);
        const eventVarName = normalizeVarName(input.eventName || input.eventId);
        const fieldVarName = input.field ? normalizeVarName(input.field) : null;

        // Build safe access path using bracket notation for safety
        let accessPath;
        if (input.field) {
          accessPath = `inputs['${eventVarName}']['${fieldVarName}']`;
        } else {
          accessPath = `inputs['${eventVarName}']`;
        }

        context.variables.push({
          type: "event",
          name: input.eventName || input.eventId,
          field: input.field,
          varName: eventVarName,
          fieldVarName: fieldVarName,
          accessPath: accessPath,
          schema: eventInfo.schema,
          sample: eventInfo.sample,
        });
        context.events[input.eventId] = eventInfo;
      } else if (input.type === "action") {
        const actionInfo = await gatherActionContext(input);
        const actionVarName = normalizeVarName(input.actionId);
        const parserVarName = input.parserVarName
          ? normalizeVarName(input.parserVarName)
          : null;
        const fieldVarName = input.field ? normalizeVarName(input.field) : null;

        // Build safe access path
        let accessPath;
        if (parserVarName) {
          accessPath = `inputs.actions['${actionVarName}']['${parserVarName}']`;
        } else if (fieldVarName) {
          accessPath = `inputs.actions['${actionVarName}']['${fieldVarName}']`;
        } else {
          accessPath = `inputs.actions['${actionVarName}']`;
        }

        // Derive a strong sample value for this input using multiple fallbacks
        let resolvedSample = null;
        if (input.sampleValue !== undefined) {
          resolvedSample = input.sampleValue;
        } else if (
          actionInfo &&
          actionInfo.sample !== undefined &&
          actionInfo.sample !== null
        ) {
          // If parserPath present, try to extract specific sample value
          if (input.parserPath) {
            resolvedSample = extractFieldValue(
              actionInfo.sample,
              input.parserPath,
            );
            // If extract yields null/undefined, try representative sample from result
            if (resolvedSample === null || resolvedSample === undefined) {
              resolvedSample = findRepresentativeSample(actionInfo.sample);
            }
          } else if (input.field) {
            resolvedSample = extractFieldValue(actionInfo.sample, input.field);
            if (resolvedSample === null || resolvedSample === undefined) {
              resolvedSample = findRepresentativeSample(actionInfo.sample);
            }
          } else {
            // No field specified: try to find a primitive representative sample
            resolvedSample =
              findRepresentativeSample(actionInfo.sample) || actionInfo.sample;
          }
        } else {
          // As last resort, try global action test state (if user ran a test earlier)
          try {
            const globalTest =
              window.__actionTestState && window.__actionTestState.testResult;
            if (globalTest && globalTest[actionVarName]) {
              resolvedSample =
                findRepresentativeSample(globalTest[actionVarName]) ||
                globalTest[actionVarName];
            }
          } catch (e) {}
        }

        context.variables.push({
          type: "action",
          name: input.actionName || input.actionId,
          actionId: input.actionId,
          field: input.field,
          parserPath: input.parserPath,
          parserVarName: parserVarName,
          fieldVarName: fieldVarName,
          varName: actionVarName,
          accessPath: accessPath,
          schema: actionInfo.schema,
          sample: resolvedSample,
          resultStructure: actionInfo.resultStructure,
        });
        context.actions[input.actionId] = actionInfo;
      }
    }

    return context;
  }

  // Gather event context including schema and sample data
  async function gatherEventContext(input) {
    try {
      const events = await loadAvailableEvents();
      const event = events.find((e) => e.id === input.eventId);

      if (event) {
        const schema = await fetchEventPayloadSchema(event);
        let sample = null;

        if (schema) {
          // Build sample from schema
          sample = {};
          if (schema.primaryFields) {
            Object.keys(schema.primaryFields).forEach((k) => {
              const field = schema.primaryFields[k];
              if (field.sample !== undefined) {
                sample[k] = field.sample;
              }
            });
          }
          if (schema.metadataFields) {
            Object.keys(schema.metadataFields).forEach((k) => {
              const field = schema.metadataFields[k];
              if (field.sample !== undefined) {
                sample[k] = field.sample;
              }
            });
          }
        }

        return { schema, sample, event };
      }
    } catch (e) {
      console.warn("Failed to gather event context:", e);
    }

    return { schema: null, sample: null };
  }

  // Gather action context including schema and sample result
  async function gatherActionContext(input) {
    try {
      const actions = await loadAvailableActions();
      const action = actions.find((a) => a.id === input.actionId);

      if (action) {
        let sample = null;
        let resultStructure = null;

        // Try to get sample from various sources (ordered heuristics)
        const candidateSources = [
          "successSample",
          "sample",
          "lastResult",
          "lastRunResult",
          "_lastResult",
          "exampleResult",
        ];

        for (const key of candidateSources) {
          if (action[key] !== undefined && action[key] !== null) {
            sample = action[key];
            break;
          }
        }

        // Check variableMappings examples and parser-provided examples
        if (!sample && action.variableMappings) {
          if (action.variableMappings._exampleOutputs) {
            const examples = action.variableMappings._exampleOutputs;
            if (Array.isArray(examples) && examples.length > 0) {
              sample = examples[0].result || examples[0];
            }
          }

          if (!sample && action.variableMappings.parserExamples) {
            // parserExamples: { path: value }
            const pe = action.variableMappings.parserExamples;
            const keys = Object.keys(pe || {});
            if (keys.length > 0) sample = pe[keys[0]];
          }
        }

        // If still no sample, attempt to read from action.lastSuccessfulRun or metadata
        if (!sample && action.metadata && action.metadata.lastSuccessfulRun) {
          sample =
            action.metadata.lastSuccessfulRun.result ||
            action.metadata.lastSuccessfulRun;
        }

        // If we found a sample, derive result structure
        if (sample !== null && sample !== undefined) {
          resultStructure = extractStructure(sample);
        }

        return { schema: null, sample, resultStructure, action };
      }
    } catch (e) {
      console.warn("Failed to gather action context:", e);
    }

    return { schema: null, sample: null, resultStructure: null };
  }

  // Extract structure from sample data
  function extractStructure(sample) {
    if (sample === null || sample === undefined) return null;

    const structure = {};

    if (Array.isArray(sample)) {
      structure.type = "array";
      structure.length = sample.length;
      if (sample.length > 0) {
        // analyze first N items to infer itemType
        const first = sample[0];
        structure.itemType = inferType(first);
        if (typeof first === "object" && first !== null) {
          structure.fields = Object.keys(first);
          // include nested field types for clarity
          structure.fieldTypes = {};
          Object.keys(first).forEach((k) => {
            structure.fieldTypes[k] = inferType(first[k]);
          });
        }
      }
    } else if (typeof sample === "object") {
      structure.type = "object";
      structure.fields = Object.keys(sample);
      structure.fieldTypes = {};
      Object.keys(sample).forEach((k) => {
        structure.fieldTypes[k] = inferType(sample[k]);
      });
    } else {
      structure.type = inferType(sample);
    }

    return structure;
  }

  /**
   * Find a representative primitive sample inside a nested object/array
   * Scans breadth-first up to a reasonable depth and prefers non-null primitives
   */
  function findRepresentativeSample(sample, maxDepth = 4) {
    try {
      if (sample === null || sample === undefined) return null;
      if (typeof sample !== "object") return sample;

      const queue = [{ value: sample, depth: 0 }];

      while (queue.length > 0) {
        const { value, depth } = queue.shift();
        if (depth > maxDepth) continue;

        if (Array.isArray(value)) {
          for (let i = 0; i < Math.min(value.length, 6); i++) {
            const item = value[i];
            if (item === null || item === undefined) continue;
            if (typeof item !== "object") return item;
            queue.push({ value: item, depth: depth + 1 });
          }
        } else if (typeof value === "object") {
          for (const k of Object.keys(value)) {
            const v = value[k];
            if (v === null || v === undefined) continue;
            if (typeof v !== "object") return v;
            queue.push({ value: v, depth: depth + 1 });
          }
        }
      }
    } catch (e) {
      console.warn("findRepresentativeSample failed:", e);
    }
    return null;
  }

  // Build AI prompt with description and comprehensive context
  function buildAIPrompt(description, context) {
    let prompt = `You are an expert JavaScript developer. Generate a SIMPLE, SINGLE JavaScript function body for the Custom Logic Engine.\n\n`;

    prompt += `=== CUSTOM LOGIC ENGINE EXECUTION MODEL ===\n\n`;
    prompt += `The Custom Logic Engine executes your code using:\n`;
    prompt += `  const func = new Function("inputs", yourCodeHere);\n`;
    prompt += `  const result = func(inputs);\n\n`;

    prompt += `CONSTRAINTS:\n`;
    prompt += `‚Ä¢ Your code is the FUNCTION BODY ONLY (no 'function' keyword, no declaration)\n`;
    prompt += `‚Ä¢ You receive exactly ONE parameter: 'inputs' object\n`;
    prompt += `‚Ä¢ You MUST return a value (object, array, string, number, or boolean)\n`;
    prompt += `‚Ä¢ The engine supports both sync and async execution\n`;
    prompt += `‚Ä¢ NO external modules, NO require(), NO imports\n`;
    prompt += `‚Ä¢ ONLY use standard JavaScript built-ins (Math, Date, String, Array, Object, JSON, etc.)\n\n`;

    // ===== ADD INPUT SHAPE SCHEMA =====
    prompt += `=== INPUT SHAPE SCHEMA (STRICT CONTRACT) ===\n\n`;

    try {
      const schema = buildInputShapeSchema(logicInputs);
      const interfaceStr = schemaToInterface(schema);
      prompt += `This is the EXACT structure of the 'inputs' parameter you will receive:\n\n`;
      prompt += `${interfaceStr}\n\n`;
      prompt += `CRITICAL:\n`;
      prompt += `‚Ä¢ You MUST ONLY access properties defined in this schema\n`;
      prompt += `‚Ä¢ Use EXACT property names as shown above\n`;
      prompt += `‚Ä¢ Types are enforced - check the type annotations\n`;
      prompt += `‚Ä¢ Sample values are provided for reference\n`;
      prompt += `‚Ä¢ Use bracket notation: inputs['propertyName']['nestedProperty']\n\n`;
    } catch (e) {
      console.warn("Failed to build input shape schema for AI prompt:", e);
    }
    // ===== END INPUT SHAPE SCHEMA =====

    prompt += `=== GRAMMAR AND STRUCTURE ===\n\n`;
    prompt += `INPUTS OBJECT STRUCTURE:\n`;
    prompt += `{\n`;
    prompt += `  "eventName": { ...eventPayload },           // Event data\n`;
    prompt += `  "actions": {                                // Action results\n`;
    prompt += `    "actionId": { ...actionResult }\n`;
    prompt += `  }\n`;
    prompt += `}\n\n`;

    prompt += `DESCRIPTION:\n${description}\n\n`;

    prompt += `AVAILABLE INPUT VARIABLES:\n`;
    context.variables.forEach((v, idx) => {
      prompt += `${idx + 1}. ${v.accessPath}\n`;
      prompt += `   Type: ${v.type}\n`;
      if (v.sample !== undefined && v.sample !== null) {
        prompt += `   Sample Value: ${JSON.stringify(v.sample).substring(
          0,
          200,
        )}\n`;
      }
      if (v.resultStructure) {
        prompt += `   Structure: ${JSON.stringify(v.resultStructure)}\n`;
      }
      prompt += `\n`;
    });

    prompt += `\n=== MANDATORY SYNTAX RULES ===\n\n`;
    prompt += `1. PROPERTY ACCESS: Use bracket notation for all property access\n`;
    prompt += `   ‚úì inputs['eventName']['field']\n`;
    prompt += `   ‚úì inputs.actions['actionId']['field']\n`;
    prompt += `   ‚úó inputs.field - variableName  (This is SUBTRACTION, not property access!)\n\n`;

    prompt += `2. VARIABLE REFERENCES: ONLY use variables from the "AVAILABLE INPUT VARIABLES" list above\n`;
    prompt += `   ‚úì const value = inputs.actions['actionId']['phone_number'];\n`;
    prompt += `   ‚úó const value = someUndefinedVariable;\n\n`;

    prompt += `3. NULL SAFETY: Always check for null/undefined before accessing nested properties\n`;
    prompt += `   ‚úì const value = inputs.actions?.['actionId']?.['field'] || null;\n`;
    prompt += `   ‚úì if (inputs.actions && inputs.actions['actionId']) { ... }\n\n`;

    prompt += `4. SIMPLE LOGIC: Keep logic simple and focused - ONE clear purpose\n`;
    prompt += `   ‚úì Validate one field\n`;
    prompt += `   ‚úì Transform one value\n`;
    prompt += `   ‚úì Compare two values\n`;
    prompt += `   ‚úó Complex multi-step workflows\n`;
    prompt += `   ‚úó Database operations\n`;
    prompt += `   ‚úó Network requests\n\n`;

    prompt += `5. ERROR HANDLING: Wrap in try-catch, return structured error objects\n`;
    prompt += `   ‚úì try { ...logic... } catch (error) { return { error: error.message }; }\n\n`;

    prompt += `6. RETURN VALUE: Always return something meaningful\n`;
    prompt += `   ‚úì return { isValid: true, value: result };\n`;
    prompt += `   ‚úì return processedValue;\n`;
    prompt += `   ‚úó No return statement\n`;
    prompt += `   ‚úó return undefined;\n\n`;

    prompt += `=== RESPONSE FORMAT ===\n\n`;
    prompt += `Provide ONLY the JavaScript code block.\n`;
    prompt += `‚Ä¢ NO markdown formatting (no \`\`\`javascript)\n`;
    prompt += `‚Ä¢ NO explanations before or after the code\n`;
    prompt += `‚Ä¢ NO function declaration\n`;
    prompt += `‚Ä¢ Start directly with JavaScript statements\n`;
    prompt += `‚Ä¢ End with a return statement\n\n`;

    prompt += `=== CORRECT EXAMPLE ===\n\n`;
    prompt += `try {\n`;
    prompt += `  // Extract phone number from action result\n`;
    prompt += `  const phoneNumber = inputs.actions?.['actionId']?.['phone_number'];\n`;
    prompt += `  \n`;
    prompt += `  // Validate phone number format\n`;
    prompt += `  if (!phoneNumber || typeof phoneNumber !== 'string') {\n`;
    prompt += `    return { isValid: false, error: 'Phone number is required' };\n`;
    prompt += `  }\n`;
    prompt += `  \n`;
    prompt += `  const phoneRegex = /^\\d{3}-\\d{3}-\\d{4}$/;\n`;
    prompt += `  const isValid = phoneRegex.test(phoneNumber);\n`;
    prompt += `  \n`;
    prompt += `  return {\n`;
    prompt += `    isValid,\n`;
    prompt += `    phoneNumber,\n`;
    prompt += `    error: isValid ? null : 'Invalid phone number format (expected: XXX-XXX-XXXX)'\n`;
    prompt += `  };\n`;
    prompt += `} catch (error) {\n`;
    prompt += `  console.error('Logic error:', error);\n`;
    prompt += `  return { isValid: false, error: error.message };\n`;
    prompt += `}\n\n`;

    prompt += `=== WRONG EXAMPLES (DO NOT DO THIS) ===\n\n`;
    prompt += `‚ùå function validatePhone(inputs) { ... }  // NO function declaration!\n`;
    prompt += `‚ùå const result = inputs.field - variableName;  // Subtraction operator is NOT property access!\n`;
    prompt += `‚ùå inputs.actions.actionId.crmToDelivery - phone_number;  // Syntax error!\n`;
    prompt += `‚ùå const axios = require('axios');  // NO external modules!\n`;
    prompt += `‚ùå await fetch('...');  // NO network requests!\n`;
    prompt += `‚ùå return;  // MUST return a value!\n\n`;

    prompt += `NOW GENERATE THE JAVASCRIPT CODE FOLLOWING ALL RULES ABOVE:`;

    return prompt;
  }

  // Robust JavaScript parser to extract code from AI response
  function parseJavaScriptFromAI(response) {
    if (!response) return null;

    let code = response.trim();

    // Remove markdown code blocks if present
    code = code.replace(/^```(?:javascript|js)?\s*\n/i, "");
    code = code.replace(/\n```\s*$/, "");
    code = code.replace(/^```(?:javascript|js)?\s*/i, "");
    code = code.replace(/```\s*$/, "");

    // Remove any leading/trailing explanatory text
    const patterns = [
      /(?:Here's|Here is|Here are).*?code.*?:\s*\n/gi,
      /^.*?(?=(?:try|const|let|var|if|return|function)\s*[\{\(])/s,
      /^[^\n]*(?:code|solution|implementation).*?:\s*\n/gi,
    ];

    for (const pattern of patterns) {
      code = code.replace(pattern, "");
    }

    // Clean up the code
    code = code.trim();

    // Remove function wrapper if AI added it despite instructions
    code = code.replace(/^function\s+\w*\s*\([^)]*\)\s*\{/i, "");
    code = code.replace(/^\([^)]*\)\s*=>\s*\{/i, "");

    // Remove trailing closing brace if it's a wrapper
    if (
      code.endsWith("}") &&
      !code.includes("try") &&
      !code.includes("if") &&
      !code.includes("for")
    ) {
      code = code.substring(0, code.lastIndexOf("}")).trim();
    }

    // Fix common AI errors: property access with subtraction operator
    // Pattern: inputs.something.field - variableName
    // Should be: inputs.something['field_variableName'] or similar
    code = code.replace(
      /(inputs(?:\.[\w]+|\['[^']+'])+)\s*-\s*([\w]+)/g,
      (match, path, varName) => {
        console.warn(`Fixed AI syntax error: ${match} ‚Üí ${path}['${varName}']`);
        return `${path}['${varName}']`;
      },
    );

    // Validate JavaScript syntax
    try {
      new Function("inputs", code);
      return code;
    } catch (syntaxError) {
      console.error("JavaScript syntax validation failed:", syntaxError);
      console.error("Code that failed:", code);

      // Try aggressive cleanup
      const lines = code.split("\n");
      const cleanedLines = lines.filter((line) => {
        const trimmed = line.trim();
        // Remove obvious non-code lines
        return !trimmed.startsWith("//") || trimmed.length < 100;
      });

      const cleanedCode = cleanedLines.join("\n").trim();

      try {
        new Function("inputs", cleanedCode);
        return cleanedCode;
      } catch (e) {
        console.error("Cleaned code still invalid:", e);
        console.error("Cleaned code:", cleanedCode);
        return null;
      }
    }
  }

  // Auto-populate test data textarea with real sample values
  async function populateTestDataFromSamples(context) {
    try {
      const testData = {};

      // Build test data object from context with normalized variable names
      for (const variable of context.variables) {
        if (variable.type === "event") {
          const eventVarName =
            variable.varName || normalizeVarName(variable.name);

          if (!testData[eventVarName]) {
            testData[eventVarName] = {};
          }

          if (variable.field && variable.sample) {
            const fieldVarName =
              variable.fieldVarName || normalizeVarName(variable.field);
            // Extract specific field value
            const fieldValue =
              variable.sample[variable.field] !== undefined
                ? variable.sample[variable.field]
                : null;
            testData[eventVarName][fieldVarName] = fieldValue;
          } else if (variable.sample) {
            // Use full event sample
            testData[eventVarName] = variable.sample;
          }
        } else if (variable.type === "action") {
          if (!testData.actions) {
            testData.actions = {};
          }

          const actionVarName =
            variable.varName || normalizeVarName(variable.actionId);
          if (!testData.actions[actionVarName]) {
            testData.actions[actionVarName] = {};
          }

          if (
            variable.parserVarName &&
            variable.sample !== undefined &&
            variable.sample !== null
          ) {
            // Use parser path variable with normalized name
            const parserVarName = normalizeVarName(variable.parserVarName);
            testData.actions[actionVarName][parserVarName] = variable.sample;
          } else if (
            variable.field &&
            variable.sample !== undefined &&
            variable.sample !== null
          ) {
            // Extract specific field with normalized name
            const fieldVarName =
              variable.fieldVarName || normalizeVarName(variable.field);
            const fieldValue =
              typeof variable.sample === "object" &&
              variable.sample[variable.field] !== undefined
                ? variable.sample[variable.field]
                : variable.sample;
            testData.actions[actionVarName][fieldVarName] = fieldValue;
          } else if (
            variable.sample !== undefined &&
            variable.sample !== null
          ) {
            // Use full action result
            testData.actions[actionVarName] = variable.sample;
          } else {
            // Try to fallback to full action sample from context if available
            try {
              const act = context.actions && context.actions[variable.actionId];
              const fallback =
                act && (act.sample || (act.action && act.action.sample));
              const rep = fallback ? findRepresentativeSample(fallback) : null;
              if (rep !== null && rep !== undefined) {
                testData.actions[actionVarName] = rep;
              }
            } catch (e) {}
          }
        }
      }

      // Populate the test data textarea and make it read-only
      const testDataTextarea = document.getElementById("logic-test-data");
      testDataTextarea.value = JSON.stringify(testData, null, 2);
      testDataTextarea.readOnly = true;
      testDataTextarea.style.backgroundColor = "#f8f9fa";
      testDataTextarea.style.cursor = "not-allowed";
      testDataTextarea.title =
        "Auto-generated from real action outputs (read-only)";

      // Update variable preview
      showVariablePreviewFromTestData(testData);
    } catch (e) {
      console.error("Failed to populate test data:", e);
    }
  }

  // Update variable preview panel with test data
  function showVariablePreviewFromTestData(testData) {
    const container = document.getElementById("variable-preview-list");
    if (!container) return;

    const parts = [];

    // Flatten test data for preview
    const flatten = (obj, prefix = "") => {
      if (!obj || typeof obj !== "object") return;

      Object.keys(obj)
        .slice(0, 20)
        .forEach((key) => {
          const value = obj[key];
          const path = prefix ? `${prefix}.${key}` : key;

          if (value && typeof value === "object" && !Array.isArray(value)) {
            flatten(value, path);
          } else {
            let displayValue = JSON.stringify(value);
            if (displayValue.length > 100) {
              displayValue = displayValue.substring(0, 100) + "...";
            }

            parts.push(
              `<div style="display:flex; justify-content:space-between; gap:12px; padding:4px 0; border-bottom:1px dashed #eee">` +
                `<div style="font-family:monospace; color:#1a73e8; font-weight:600">${path}</div>` +
                `<div style="color:#333; font-family:monospace; font-size:0.85rem">${displayValue}</div>` +
                `</div>`,
            );
          }
        });
    };

    flatten(testData);

    container.innerHTML =
      parts.length > 0
        ? parts.join("")
        : '<div style="color:#666">No preview available</div>';
  }

  // Helper to fetch event payload schema
  async function fetchEventPayloadSchema(event) {
    try {
      const res = await fetch(`/api/event-registry/${event.id}/schema`);
      if (res.ok) {
        const data = await res.json();
        return data.schema || null;
      }
    } catch (e) {
      console.warn("Failed to fetch event schema:", e);
    }
    return null;
  }
</script>
